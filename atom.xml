<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>unreal-engine-channel</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-27T18:30:35.953Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jocoboy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Graphic-Drawing-System</title>
    <link href="http://example.com/2020/11/27/Graphic-Drawing-System/"/>
    <id>http://example.com/2020/11/27/Graphic-Drawing-System/</id>
    <published>2020-11-27T13:16:36.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>图形绘制系统的主要内容：Modeling(建模)、Geometric processing(几何处理)、Rasterization(光栅化)、Fragment processing(片元处理)、Frame buffer(帧缓存)。</p><a id="more"></a><h1 id="Geometric-processing-几何处理"><a href="#Geometric-processing-几何处理" class="headerlink" title="Geometric processing(几何处理)"></a>Geometric processing(几何处理)</h1><p><img src='https://img-blog.csdnimg.cn/20201127213955149.png'></p><blockquote><ul><li><p>完整的图形绘制管道</p><ol><li>通过给P添加分量1将其扩展为齐次4元组；</li><li>用这个4元组乘上矩阵modelview，得到视点坐标系下的4元组；</li><li>再将点乘上投影矩阵，得到裁剪坐标下的4元组；</li><li>对以此点为端点的边实施裁剪操作；</li><li>执行透视除法，得到一个3元组（规范化的设备坐标）；</li><li>在视区变换过程中3元组被乘上一个矩阵：得到的结果被用于绘制和深度计算（窗口坐标）。</li></ol></li><li><p>从三维空间到二维平面，就如同用相机拍照一样，通常都要经历以下几个步骤（括号内表示的是相应的图形学概念） </p><ol><li><p>将相机置于三角架上，让它对准三维景物（视点变换，Viewing Transformation）； </p></li><li><p>将三维物体放在适当的位置（模型变换，Modeling Transformation ）； </p></li><li><p>选择相机镜头并调焦，使三维物体投影在二维胶片上（投影变换，Projection Transformation ）;</p></li><li><p>决定二维像片的大小（视口变换，Viewport Transformation ）。 </p></li></ol><p>这样，一个三维空间里的物体就可以用相应的二维平面物体表示了，也就能在二维的计算机屏幕上正确显示了。</p></li></ul></blockquote><h2 id="Viewing-amp-Modeling-Transformation-视点-amp-模型变换"><a href="#Viewing-amp-Modeling-Transformation-视点-amp-模型变换" class="headerlink" title="Viewing &amp; Modeling  Transformation(视点&amp;模型变换)"></a>Viewing &amp; Modeling  Transformation(视点&amp;模型变换)</h2><h3 id="摄像机的定位和定向"><a href="#摄像机的定位和定向" class="headerlink" title="摄像机的定位和定向"></a>摄像机的定位和定向</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src='https://img-blog.csdnimg.cn/20201128001507408.png'></p><p>给定eye、look和up，我们得到：</p><p><img src='https://img-blog.csdnimg.cn/20201128002206685.png'></p><h4 id="Modelview-matrix-模型视点矩阵"><a href="#Modelview-matrix-模型视点矩阵" class="headerlink" title="Modelview matrix(模型视点矩阵)"></a>Modelview matrix(模型视点矩阵)</h4><p><img src='https://img-blog.csdnimg.cn/20201128013208174.png'></p><p><img src='https://img-blog.csdnimg.cn/20201128013227487.png'></p><p>模型视点矩阵的作用是把世界坐标系转换成摄像机坐标系。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>考虑一个摄像机，其eye=(4,4,4)，look=(0,1,0)，up为(0,1,0)，求出u，v，n。</p><p>n=(4,4,4)-(0,1,0)=(4,3,4)</p><script type="math/tex; mode=display">\left[ \begin{matrix}   i & j & k \\   0 & 1 & 0 \\   4 & 3 & 4  \end{matrix}  \right]</script><p>u=(0,1,0)×(4,3,4)=(4,0,-4)</p><script type="math/tex; mode=display">\left[ \begin{matrix}   i & j & k \\   4 & 3 & 4 \\   4 & 0 & -4  \end{matrix}  \right]</script><p>v=(4,3,4)×(4,0,-4)=(-12,32,-12)</p></blockquote><h4 id="OpenGL视点变换API"><a href="#OpenGL视点变换API" class="headerlink" title="OpenGL视点变换API"></a>OpenGL视点变换API</h4><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glulookat">gluLookAt(GLdouble eyex,   GLdouble eyey,   GLdouble eyez,   GLdouble centerx,   GLdouble centery,   GLdouble centerz,   GLdouble upx,   GLdouble upy,   GLdouble upz)</a></li></ul><h2 id="Projection-Transformation-投影变换"><a href="#Projection-Transformation-投影变换" class="headerlink" title="Projection Transformation(投影变换)"></a>Projection Transformation(投影变换)</h2><h3 id="平行投影-正交投影"><a href="#平行投影-正交投影" class="headerlink" title="平行投影(正交投影)"></a>平行投影(正交投影)</h3><h4 id="平行投影矩阵"><a href="#平行投影矩阵" class="headerlink" title="平行投影矩阵"></a>平行投影矩阵</h4><p><img src='https://img-blog.csdnimg.cn/20201128020858774.png'></p><p><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">推导过程</a></p><h4 id="OpenGL平行投影API"><a href="#OpenGL平行投影API" class="headerlink" title="OpenGL平行投影API"></a>OpenGL平行投影API</h4><ul><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glortho">glOrtho(GLdouble left,   GLdouble right,   GLdouble bottom,   GLdouble top,   GLdouble zNear,   GLdouble zFar)</a></p></li><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gluortho2d">gluOrtho2D(GLdouble left,   GLdouble right,   GLdouble top,   GLdouble bottom)</a></p></li></ul><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><h4 id="透视除法"><a href="#透视除法" class="headerlink" title="透视除法"></a>透视除法</h4><p><img src='https://img-blog.csdnimg.cn/20201128020312218.png'></p><p><img src='https://img-blog.csdnimg.cn/20201128020336728.png'></p><p>在Eye coordinates(观察坐标）被Projection matrix相乘后，得到的Clip coordinates(裁剪坐标)仍然是homogeneous coordinates(齐次坐标)。最终它需要除以Clip coordinates的w分量，才能变成Normalized device coordinates(规范化设备坐标NDC)。因此，我们可以把裁剪坐标的Wc分量设置为-Ze，则投影矩阵第4行变为(0, 0, -1, 0)。</p><h4 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h4><p><img src='https://img-blog.csdnimg.cn/20201128020621398.png'></p><p><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">推导过程</a></p><h4 id="OpenGL透视投影API"><a href="#OpenGL透视投影API" class="headerlink" title="OpenGL透视投影API"></a>OpenGL透视投影API</h4><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glfrustum">glFrustum(GLdouble left,   GLdouble right,   GLdouble bottom,   GLdouble top,   GLdouble zNear,   GLdouble zFar)</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gluperspective">gluPerspective(GLdouble fovy,   GLdouble aspect,   GLdouble zNear,   GLdouble zFar)</a></li></ul><h2 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a>Viewport Transformation(视口变换)</h2><p><img src='https://img-blog.csdnimg.cn/20201127214343608.png'></p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>仿射变换可以很容易地对物体实施缩放、旋转和平移操作</li><li>一系列仿射变换可以组合成一个单一的仿射变换</li><li>仿射变换可以使用一个紧凑的矩阵形式表示</li></ol><h4 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h4><ul><li>平移<img src='https://img-blog.csdnimg.cn/2020112723281810.png'></li><li>缩放<img src='https://img-blog.csdnimg.cn/20201127232917795.png'></li><li>旋转<img src='https://img-blog.csdnimg.cn/20201127234421587.png'><img src='https://img-blog.csdnimg.cn/20201127234441934.png'></li></ul><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><blockquote><p>假设裁剪矩形的左下角坐标为（wxl=10,wyb=10），右上角坐标为（wxr=50，wyt=50）。</p><p>设备坐标系中视口的左下角坐标为（vxl=10,vyb=30），右上角坐标为（vxr=50,vyt=90）。</p><p>已知在窗口内有一点p(20,30)，要将点p映射到视区内的点p’，请问p’点在设备坐标系中的坐标是多少？</p><ol><li><p>将窗口坐标系（window coordinates）左下角（10,10）平移至观察坐标系的坐标原点（0,0），平移矢量为（-10，-10）。</p></li><li><p>针对坐标原点进行比例变换，使窗口大小和视区相等，比例因子为 Sx=(50-10)/(50-10)=1， Sy=(90-30)/(50-10)=1.5。</p></li><li><p>将窗口内的点映射到设备坐标系（device coordinates）的视区中，再进行反平移，将视区的左下角移回到设备坐标系中的位置（10,30），平移矢量为（10,30）。</p></li><li><p>计算得到变换矩阵T。<br><img src='https://img-blog.csdnimg.cn/20201127225018489.png'><br><img src='https://img-blog.csdnimg.cn/20201127225157233.png'></p></li><li><p>将变换矩阵T左乘p点齐次坐标得到p’齐次坐标。</p><p><img src='https://img-blog.csdnimg.cn/20201127234649217.png'></p></li></ol></blockquote><h3 id="OpenGL视口变换API"><a href="#OpenGL视口变换API" class="headerlink" title="OpenGL视口变换API"></a>OpenGL视口变换API</h3><ul><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glviewport">glViewport(GLint x, GLint y , GLsizei width , GLsizei height)</a></p></li><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gldepthrange">glDepthRange(GLclampd zNear, GLclampd zFar )</a></p></li></ul><h1 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization(光栅化)"></a>Rasterization(光栅化)</h1><h1 id="Fragment-processing-片元处理"><a href="#Fragment-processing-片元处理" class="headerlink" title="Fragment processing(片元处理)"></a>Fragment processing(片元处理)</h1><h1 id="Frame-buffer-帧缓存"><a href="#Frame-buffer-帧缓存" class="headerlink" title="Frame buffer(帧缓存)"></a>Frame buffer(帧缓存)</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;图形绘制系统的主要内容：Modeling(建模)、Geometric processing(几何处理)、Rasterization(光栅化)、Fragment processing(片元处理)、Frame buffer(帧缓存)。&lt;/p&gt;</summary>
    
    
    
    <category term="Theories" scheme="http://example.com/categories/Theories/"/>
    
    
    <category term="Computer Graphics" scheme="http://example.com/tags/Computer-Graphics/"/>
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(二十二)</title>
    <link href="http://example.com/2020/11/22/RPG-Dev-Log-22/"/>
    <id>http://example.com/2020/11/22/RPG-Dev-Log-22/</id>
    <published>2020-11-22T07:14:25.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：联网测试交易物品，RPC。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>说明：</p><p>为了描述方便，定义<strong>SWAP_SLOT_INFO</strong> =(FromInventoryIndex(Integer),ToInventoryIndex(Integer),FromInventorySlotType(E_InventorySlotType),ToInventoryType(E_InventorySlotType)）</p><h2 id="联网测试交易物品"><a href="#联网测试交易物品" class="headerlink" title="联网测试交易物品"></a>联网测试交易物品</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="相关枚举及结构体"><a href="#相关枚举及结构体" class="headerlink" title="相关枚举及结构体"></a>相关枚举及结构体</h4><ol><li>创建枚举E_InventorySlotType[PlayerInventory,DrugStore]；</li><li>打开S_ActorContainerInfo，新增成员InventorySlotType(E_InventorySlotType)；</li></ol><h4 id="相关蓝图接口"><a href="#相关蓝图接口" class="headerlink" title="相关蓝图接口"></a>相关蓝图接口</h4><h5 id="BPI-InventoryInterface相关"><a href="#BPI-InventoryInterface相关" class="headerlink" title="BPI_InventoryInterface相关"></a>BPI_InventoryInterface相关</h5><ol><li>接口函数功能扩展：将GetContainerProperties返回值[Name,InventorySize]扩展至[Name,InventorySize,InventorySlotType]；</li><li>创建接口函数[PlayersViewing(PlayerState[])GetPlayersViewing();</li></ol><h5 id="BPI-HUDInterface相关"><a href="#BPI-HUDInterface相关" class="headerlink" title="BPI_HUDInterface相关"></a>BPI_HUDInterface相关</h5><ol><li>创建接口函数[void]UIOpenTransactionWindow(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))；</li><li>创建接口函数[Level(Integer),Moneny(Integer)]GetPlayerStatus()；</li><li>创建接口函数[void]AddMoney(Money)；</li><li>创建接口函数[void]UISplitInventoryItem(<strong>SWAP_SLOT_INFO</strong>,Amount(Integer));</li></ol><h5 id="BPI-UsableActorContainer相关"><a href="#BPI-UsableActorContainer相关" class="headerlink" title="BPI_UsableActorContainer相关"></a>BPI_UsableActorContainer相关</h5><ol><li>创建接口函数[Success(Boolean)]OnActorUsed(Controller(PlayerController))；</li></ol><h3 id="BP-DragDrop相关"><a href="#BP-DragDrop相关" class="headerlink" title="BP_DragDrop相关"></a>BP_DragDrop相关</h3><ol><li>新增变量InventorySlotType(E_InventorySlotType)；</li></ol><h3 id="W-InventorySlot相关"><a href="#W-InventorySlot相关" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol><li>函数功能扩展：对拽取物品的来源和去向InventorySlotType类型进行判断。若相同=&gt;若为玩家背包，则可直接拖拽；否则不执行任何动作。若不相同=&gt;调用蓝图接口事件UIOpenTransactionWindow，完成物品交易；<img src='https://img-blog.csdnimg.cn/2020112414060153.png'></li></ol><h3 id="W-TransactionWindow相关"><a href="#W-TransactionWindow相关" class="headerlink" title="W_TransactionWindow相关"></a>W_TransactionWindow相关</h3><ol><li>创建函数[void]Update(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))，完成交易物品信息的更新；<img src='https://img-blog.csdnimg.cn/20201124142235157.png'></li><li>创建函数[Value(Integer),Success(Boolean)]CheckMoneyforShopping()，调用蓝图接口函数GetPlayerStatus获取玩家Money信息，用于检查玩家是否有足够的金额完成物品交易；<img src='https://img-blog.csdnimg.cn/20201124144439936.png'></li><li>为标题Text文本内容绑定函数；<img src='https://img-blog.csdnimg.cn/20201124142437710.png'></li><li>为交易物品Text文本内容及文本颜色绑定函数；<img src='https://img-blog.csdnimg.cn/20201124142522849.png'><img src='https://img-blog.csdnimg.cn/20201124142703490.png'></li><li>为交易数量EditableTextBox文本输入内容绑定函数，并添加OnTextCommitted事件；<img src='https://img-blog.csdnimg.cn/20201124142703490.png'><img src='https://img-blog.csdnimg.cn/20201124143142740.png'></li><li>为交易金额Text文本内容绑定函数。买入是全额，卖出将收取40%税收；<img src='https://img-blog.csdnimg.cn/20201124143451360.png'></li><li>为TextToolTip添加文本内容和文本颜色绑定函数；<img src='https://img-blog.csdnimg.cn/2020112419420578.png'><img src='https://img-blog.csdnimg.cn/20201124194330426.png'></li><li>为Minus和Plus按钮添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194820238.png'></li><li>为Min和Max按钮添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194928322.png'></li><li>为CancelButton和ConfirmButton添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194629484.png'></li></ol><h3 id="C-Inventory相关"><a href="#C-Inventory相关" class="headerlink" title="C_Inventory相关"></a>C_Inventory相关</h3><ol><li>创建函数[Index(Integer),Success(Boolean)]GetEmptyInventorySpace()，用于背包空闲slot的寻找；<img src='https://img-blog.csdnimg.cn/20201124182952573.png'></li></ol><h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol><li>创建函数[void]OpenTransactionWindow(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))，调用函数[void]Update(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))；<img src='https://img-blog.csdnimg.cn/20201124144935982.png'></li><li>创建函数[void]CountMoney()，将BP_Player中的CountMoney函数迁移过来；<img src='https://img-blog.csdnimg.cn/20201124145309889.png'></li><li>创建函数[StructOut(S_InventoryItem)]AddToItemAmount(ItemInformation(S_InventoryItem),AmountToAdd(Integer))，将修改后的ItemInformation导出；<img src='https://img-blog.csdnimg.cn/20201124163958914.png'></li><li>创建函数[void]SetActorContainerSlotItem(ActorContainerIndex)；<img src='https://img-blog.csdnimg.cn/20201124181438471.png'></li><li>创建函数[void]SetViewersActorContainerSlot(ActorContainerSlot(Integer),ItemInformation(S_InventoryItem))，，调用客户端事件ClientSetActorContainerSlotItem，用于同步客户端交易信息；<img src='https://img-blog.csdnimg.cn/20201124180507375.png'></li><li>函数功能扩展：为函数AddItem添加Inventory判断，若为PlayerInventory则正常移动，否则调用函数SetViewersActorContainerSlot;<img src='https://img-blog.csdnimg.cn/20201124164936346.png'></li><li>创建函数[RemainingAmount(Integer)]AddItemToStack(InventoryComponent(C_Inventory),InventoryIndex(Integer),Amount(Integer))，根据叠加上限MaxStackSize减去叠加数目Amount计算出剩余生成数量RemainingAmount，调用函数AddToItemAmount完成InventoryItem信息修改，并返回RemainingAmount；<img src='https://img-blog.csdnimg.cn/20201124164315887.png'><img src='https://img-blog.csdnimg.cn/2020112416440786.png'><img src='https://img-blog.csdnimg.cn/20201124164435782.png'></li><li>创建函数[Struct(S_InventoryItem)]SetItemAmount(InventoryItem(S_InventoryItem),Amount(Integer))，用于物品数量的修改；<img src='https://img-blog.csdnimg.cn/20201124182550508.png'></li><li>创建函数[Output_Get(Integer),WasFullAmountRemove(Boolean),StructOut(S_InventoryItem)]RemoveFromItemAmount(InventoryItem(S_InventoryItem),AmountToRemove(Integer))；<img src='https://img-blog.csdnimg.cn/20201124191915761.png'></li><li><p>函数功能扩展：为函数MoveItem添加两个新的传入参数FromInventoryComponent和ToComponent</p><ul><li><p>判断是否为有效移动，若为有效移动，将传入参数创建为本地变量<img src='https://img-blog.csdnimg.cn/20201124184819754.png'></p></li><li><p>判断移动到另一物品上还是空白位置<img src='https://img-blog.csdnimg.cn/20201124184927617.png'></p><ul><li><p>移动到空白位置<img src='https://img-blog.csdnimg.cn/20201124185055331.png'></p></li><li><p>移动到另一物品上，判断是否为相同物品<img src='https://img-blog.csdnimg.cn/2020112418501065.png'></p><ul><li>为相同物品，判断是否超出堆叠上限<img src='https://img-blog.csdnimg.cn/20201124185330475.png'><ul><li>未超出，直接进行叠加<img src='https://img-blog.csdnimg.cn/20201124185413385.png'></li><li>超出，需要寻找空白位置并额外创建物品<img src='https://img-blog.csdnimg.cn/20201124185603858.png'></li></ul></li><li>不是相同物品，判断是否为玩家背包<img src='https://img-blog.csdnimg.cn/20201124185747664.png'><ul><li>若为玩家背包，直接进行物品对调<img src='https://img-blog.csdnimg.cn/20201124185836885.png'></li><li>若为商店背包<img src='https://img-blog.csdnimg.cn/20201124195641468.png'></li></ul></li></ul></li></ul></li></ul></li><li>创建函数[void]SplitItem(FromInventory(C_Inventory),ToInventory(C_Inventory),FromInventoryIndex(Integer),ToInventoryIndex(Integer),Amount(Integer))，具体思路同MoveItem函数；<img src='https://img-blog.csdnimg.cn/20201124193737972.png'></li><li>创建函数[void]CloseActorContainer()，调用接口函数GetPlayersViewing和客户端事件Client_CloseActorContainer；<img src='https://img-blog.csdnimg.cn/20201124172748143.png'></li><li>创建函数[void]ClearContainerSlotItem(ContainerSlot(Integer))；<img src='https://img-blog.csdnimg.cn/20201124200200108.png'></li><li>创建函数[void]ClearViewersActorContainer(ActorContainerSlot(Integer))，调用客户端事件Client_ClearActorContainerSlotItems；<img src='https://img-blog.csdnimg.cn/2020112420035559.png'></li></ol><h3 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h3><ol><li>实现接口函数GetPlayersViewing，将PlayerState信息导出；<img src='https://img-blog.csdnimg.cn/20201124165756372.png'></li><li>将蓝图接口BPI_UsableActorContainer添加进来，并实现接口函数OnActorUsed，调用服务端事件ServerUseContainer；<img src='https://img-blog.csdnimg.cn/20201124170731704.png'></li></ol><h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol><li><p>实现蓝图接口事件EventUIOpenTransactionWindow，调用客户端事件Client_OpenTransactionWindow；<img src='https://img-blog.csdnimg.cn/20201124141309624.png'></p></li><li><p>实现蓝图接口事件EventAddMoney，调用客户端事件Client_AddMoney；<img src='https://img-blog.csdnimg.cn/20201124152053403.png'></p></li><li><p>实现蓝图接口事件EventUISplitInventoryItem，调用客户端事件ServerSplitInventoryItem；<img src='https://img-blog.csdnimg.cn/2020112415291059.png'></p></li><li><p>实现接口函数[Level(Integer),Moneny(Integer)]GetPlayerStatus()，将服务端Replicated到客户端的变量Level和Money信息导出；<img src='https://img-blog.csdnimg.cn/20201124150829781.png'></p></li><li><p>创建函数[HitActor(Actor)]GetUsableActor()，HitActor在BP_Player中完成设置；</p><p><img src='https://img-blog.csdnimg.cn/20201124171800115.png'><img src='https://img-blog.csdnimg.cn/202011241715382.png'></p></li><li><p>创建函数[void]OnActorUsed()，调用函数GetUsableActor和接口函数OnActorUsed；<img src='https://img-blog.csdnimg.cn/20201124172200596.png'></p></li></ol><h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-SplitInventoryItem"><a href="#Server-SplitInventoryItem" class="headerlink" title="Server_SplitInventoryItem"></a>Server_SplitInventoryItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SplitItem；<img src='https://img-blog.csdnimg.cn/20201124153530678.png'></p><h4 id="Server-OnActorUsed"><a href="#Server-OnActorUsed" class="headerlink" title="Server_OnActorUsed"></a>Server_OnActorUsed</h4><p>在RPG_PlayerController事件图表中创建，调用函数OnActorUsed和客户端事件Client_OpenInventory；<img src='https://img-blog.csdnimg.cn/20201124171333609.png'></p><h4 id="Server-CloseActorContainer"><a href="#Server-CloseActorContainer" class="headerlink" title="Server_CloseActorContainer"></a>Server_CloseActorContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseActorContainer；<img src='https://img-blog.csdnimg.cn/20201124195158920.png'></p><h4 id="Server-TransactionItem"><a href="#Server-TransactionItem" class="headerlink" title="Server_TransactionItem"></a>Server_TransactionItem</h4><p>在W_TransactionWindow事件图表中创建；<img src='https://img-blog.csdnimg.cn/20201124195108141.png'></p><h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-OpenTransactionWindow"><a href="#Client-OpenTransactionWindow" class="headerlink" title="Client_OpenTransactionWindow"></a>Client_OpenTransactionWindow</h4><p>在C_InventoryManager事件图表中创建，调用函数OpenTransactionWindow；<img src='https://img-blog.csdnimg.cn/20201124140959167.png'></p><h4 id="Client-AddMoney"><a href="#Client-AddMoney" class="headerlink" title="Client_AddMoney"></a>Client_AddMoney</h4><p>在C_InventoryManager事件图表中创建，将BP_Player中的自定义事件GetMoney迁移过来；<img src='https://img-blog.csdnimg.cn/20201124145658353.png'></p><h4 id="Client-CloseActorContainer"><a href="#Client-CloseActorContainer" class="headerlink" title="Client_CloseActorContainer"></a>Client_CloseActorContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseActorContainerWindow;<img src='https://img-blog.csdnimg.cn/20201124173309109.png'></p><h4 id="Client-SetActorContainerSlotItem"><a href="#Client-SetActorContainerSlotItem" class="headerlink" title="Client_SetActorContainerSlotItem"></a>Client_SetActorContainerSlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SetActorContainerSlotItem;<img src='https://img-blog.csdnimg.cn/20201124181051489.png'></p><h4 id="Client-ClearActorContainerSlotItems"><a href="#Client-ClearActorContainerSlotItems" class="headerlink" title="Client_ClearActorContainerSlotItems"></a>Client_ClearActorContainerSlotItems</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearContainerSlotItem;<img src='https://img-blog.csdnimg.cn/20201124195950691.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p>(Bug尚未解决，后续补上)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：联网测试交易物品，RPC。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(二十一)</title>
    <link href="http://example.com/2020/11/21/RPG-Dev-Log-21/"/>
    <id>http://example.com/2020/11/21/RPG-Dev-Log-21/</id>
    <published>2020-11-21T08:41:36.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建NPC交易窗口，RPC。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="创建NPC交易窗口"><a href="#创建NPC交易窗口" class="headerlink" title="创建NPC交易窗口"></a>创建NPC交易窗口</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>打开E_ItemType，新增枚举[恢复物品]；</li><li>打开ItemList，将Mana_Blue和Health_Red的ItemType更改为恢复物品；</li><li>创建结构体S_ActorContainerInfo，包含商店名字和商店格子数信息；<img src='https://img-blog.csdnimg.cn/20201121180731205.png'></li></ol><h3 id="BPI-InventoryInterface相关"><a href="#BPI-InventoryInterface相关" class="headerlink" title="BPI_InventoryInterface相关"></a>BPI_InventoryInterface相关</h3><ol><li>创建接口函数[Name(Text),InventorySize(Integer)]GetContainerProperties()；</li><li>创建接口函数[InventoryComponent(C_Inventory)]GetContainerInventory()：</li></ol><h3 id="BPI-HUDInterface相关"><a href="#BPI-HUDInterface相关" class="headerlink" title="BPI_HUDInterface相关"></a>BPI_HUDInterface相关</h3><ol><li>新增接口函数[void]UIOpenDrugStore(NPCActor(Actor))；</li></ol><h3 id="W-TransactionWindow相关"><a href="#W-TransactionWindow相关" class="headerlink" title="W_TransactionWindow相关"></a>W_TransactionWindow相关</h3><ol><li>创建控件W_TransActionWindow，作为玩家与NPC交易的窗口；<img src='https://img-blog.csdnimg.cn/20201121190422457.png'></li></ol><h3 id="W-Window相关"><a href="#W-Window相关" class="headerlink" title="W_Window相关"></a>W_Window相关</h3><ol><li>创建函数[void]InitializeWindow()，用于初始化窗口大小，并根据是否为玩家背包设置与背包有关的UI控件的可视性。此函数在EventPreConstruct中调用；<img src='https://img-blog.csdnimg.cn/20201121182921756.png'></li></ol><h3 id="W-PC-Main相关"><a href="#W-PC-Main相关" class="headerlink" title="W_PC_Main相关"></a>W_PC_Main相关</h3><ol><li>复制W_InventoryWindow并重命名为W_StoreWindow，作为商店窗口，并修改默认属性；</li></ol><h3 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h3><ol><li>添加组件C_Inventory，初始化构造函数中调用服务端事件ServerInitializeInventory，初始化商店格数InventorySize为40；<img src='https://img-blog.csdnimg.cn/20201121165624322.png'></li><li>创建函数[LocalInventoryItems(S_InventoryItem[])]GetDrugStoreList()，用于返回ItemList中类型为恢复物品的物品；<img src='https://img-blog.csdnimg.cn/20201121170545847.png'></li><li>创建函数[Success(Boolean)]LoadingInventoryItems(InventorySize(Integer),InventoryItems(S_InventoryItem[]))，调用C_Inventory中的LoadInventoryItem，将InventoryItems中的物品信息加载到C_Inventory；<img src='https://img-blog.csdnimg.cn/20201121171623894.png'></li><li>创建函数[Success(Boolean)]InitializeInventory()，调用函数GetDrugStoreList和LoadingInventoryItems完成药品商店初始化。此函数在事件图表EventBeginPlay中调用；<img src='https://img-blog.csdnimg.cn/202011211719312.png'></li><li>打开ClassSettings，将蓝图接口BPI_InventoryInterface添加进来，并实现接口函数GetContainerProperties和GetContainerInventory；<img src='https://img-blog.csdnimg.cn/20201121173006831.png'><img src='https://img-blog.csdnimg.cn/20201121173047376.png'></li><li>实现自定义事件OnClickedDrugStore，调用接口函数UIOpenDrugStore，并调用OnClickedEndTalk，打开商店窗口时结束对话；<img src='https://img-blog.csdnimg.cn/2020112118591311.png'></li></ol><h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol><li>创建函数[void]ClearActorContainerSize()，用于初始化W_Window中的变量AcotrContainerSlots并清空InventorySlotWrapBox中的子控件；<img src='https://img-blog.csdnimg.cn/20201121183836481.png'></li><li>创建函数[void]CreateContainerSize(ContainerSize(Interger))，调用函数ClearActorContainerSize，并根据AcotrContainerSlots创建W_InventorySlot的控件实例，并添加至InventorySlotWrapBox中；<img src='https://img-blog.csdnimg.cn/20201121184312962.png'></li><li>创建函数[void]SetStoreInventorySlot(StoreContainerIndex(Integer),ItemInformation(S_InventoryItem))，根据商店物品索引从ActorContainerSlots中获取ItemInformation；<img src='https://img-blog.csdnimg.cn/20201121184626593.png'></li><li>创建函数[void]OpenStoreContainerWindow()和[void]CloseStoreContainerWindow()，控制商店的显示和隐藏；<img src='https://img-blog.csdnimg.cn/20201121185413105.png'><img src='https://img-blog.csdnimg.cn/20201121185439139.png'></li><li>创建函数[void]LocalContainerSlots(ItemInformation(S_InventoryItem),ActorContainerProperties(S_ActorContainerInfo))，调用函数CreateContainerSize和SetStoreInventorySlot，循环添加商店物品，循环结束调用函数OpenStoreContainerWindow，打开商店窗口；<img src='https://img-blog.csdnimg.cn/20201121181311172.png'></li><li>创建函数[void]OpenContainer(ActorContainer(Actor))，调用接口函数GetContainerProperties和GetContainerInventory，并调用客户端事件Client_OpenContainer;<img src='https://img-blog.csdnimg.cn/2020112118024116.png'></li><li>创建函数[void]UseContainer(ActorContainer(Actor))，调用函数OpenContainer；<img src='https://img-blog.csdnimg.cn/20201121175646264.png'></li></ol><h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol><li>调用蓝图接口事件EventUIOpenDrugStore，调用服务端事件ServerUseContainer和ClientOpenInventory；<img src='https://img-blog.csdnimg.cn/20201121174630228.png'></li></ol><h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-UseContainer"><a href="#Server-UseContainer" class="headerlink" title="Server_UseContainer"></a>Server_UseContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数UseContainer；<img src='https://img-blog.csdnimg.cn/20201121175304205.png'></p><h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-OpenContainer"><a href="#Client-OpenContainer" class="headerlink" title="Client_OpenContainer"></a>Client_OpenContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数LocalContainerSlots；<img src='https://img-blog.csdnimg.cn/20201122145956711.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p>(Bug尚未解决，后续补上)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建NPC交易窗口，RPC。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(二十)</title>
    <link href="http://example.com/2020/11/18/RPG-Dev-Log-20/"/>
    <id>http://example.com/2020/11/18/RPG-Dev-Log-20/</id>
    <published>2020-11-18T07:07:40.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：ToolTip，拖拽功能，RPC。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="修复W-Window关闭按钮"><a href="#修复W-Window关闭按钮" class="headerlink" title="修复W_Window关闭按钮"></a>修复W_Window关闭按钮</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建蓝图接口BPI_HUDInterface;</li><li>创建接口函数[Void]UICloseInventoryWindow();</li></ol><h3 id="W-Window相关"><a href="#W-Window相关" class="headerlink" title="W_Window相关"></a>W_Window相关</h3><ol><li>修改CloseButton点击事件，更改为调用RPG_PlayerController中的接口事件UICloseInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201118172800898.png'></li></ol><h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol><li>实现接口函数事件EventUICloseInventoryWindow，调用服务端事件Client_CloseInventory；<img src='https://img-blog.csdnimg.cn/20201118172537733.png'></li></ol><h2 id="使用ToolTip添加物品描述"><a href="#使用ToolTip添加物品描述" class="headerlink" title="使用ToolTip添加物品描述"></a>使用ToolTip添加物品描述</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建结构体E_UseType [Health,Mana,HealthAndMana]；</li><li>打开结构体S_InventoryItem，新增Health、Mana、Duration、UseType物品属性；<img src='https://img-blog.csdnimg.cn/20201118153607658.png'></li><li>打开蓝图接口BPI_HUDInterface创建接口函数，[InventoryInformation(S_InventoryItem)]GetToolTip(ID(Name));</li><li>打开ItemList，新增物品Health_Red和Mana_Blue，用于测试ToolTip；<img src='https://img-blog.csdnimg.cn/20201118155809237.png'><img src='https://img-blog.csdnimg.cn/20201118155834342.png'></li></ol><h3 id="W-ToolTip相关"><a href="#W-ToolTip相关" class="headerlink" title="W_ToolTip相关"></a>W_ToolTip相关</h3><ol><li>创建控件W_ToolTip，添加物品名称、类别、使用信息、描述信息、价格；<img src='https://img-blog.csdnimg.cn/2020111815241557.png'></li><li>对NameText控件添加文本内容和颜色的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118152520842.png'><img src='https://img-blog.csdnimg.cn/20201118153029489.png'></li><li>对ItemType控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118153142211.png'></li><li>对UseInfo控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118153928751.png'></li><li>对Description控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/2020111815414278.png'></li><li>对ValueText控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118154310493.png'></li></ol><h3 id="W-InventorySlot相关"><a href="#W-InventorySlot相关" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol><li>为SizeBox的ToolTipWidget添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118155639966.png'></li></ol><h3 id="RPG-PlayerController相关-1"><a href="#RPG-PlayerController相关-1" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol><li>点击ClassSettings，将蓝图接口BPI_HUDInterface添加进来；</li><li>实现接口函数GetToolTip，根据物品ID从ItemList中获取物品信息；<img src='https://img-blog.csdnimg.cn/20201118155108526.png'></li><li>修改变量InventoryID，将新增的物品Health_Red和Mana_Blue添加进来；<img src='https://img-blog.csdnimg.cn/20201118160116361.png'></li></ol><h2 id="拖拽功能"><a href="#拖拽功能" class="headerlink" title="拖拽功能"></a>拖拽功能</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>打开蓝图接口BPI_HUDInterface，创建接口函数[Void]UIMoveInventoryItem(FromInventoryIndex(Integer),ToInventoryIndex(Integer));</li></ol><h3 id="W-DragItem相关"><a href="#W-DragItem相关" class="headerlink" title="W_DragItem相关"></a>W_DragItem相关</h3><ol><li>创建控件W_DragItem，用于拖拽物品时生成的图标；<img src='https://img-blog.csdnimg.cn/20201118160913939.png'></li><li>对Icon控件的BurshImage添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118161148857.png'></li><li>对Text控件的文本内容添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118161259306.png'></li></ol><h3 id="W-InventorySlot相关-1"><a href="#W-InventorySlot相关-1" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol><li>为UseButton内的Border添加OnMouseButtonDown绑定事件，监控鼠标左键；<img src='https://img-blog.csdnimg.cn/20201118160454867.png'></li><li>创建蓝图BP_DragDrop，选取父类为DragDropOperation，并创建变量InventoryItem(S_InventoryItem)和InventoryIndex(Integer)；</li><li>创建重载函数OnDragDetected，当鼠标左键拖拽物品时生成相应的拖拽图标(W_DragItem)实例，并创建拖拽Operation实例(BP_DragDrop)，将物品信息和物品索引保存在BP_DragDrop中；<img src='https://img-blog.csdnimg.cn/20201118162311682.png'></li><li>创建重载函数OnDrop，当拖拽后鼠标左键释放后，从BP_DragDrop中获取InventoryIndex(FromInventoryIndex)和InventorySlotIndex(ToInventoryIndex)，并调用接口函数UIMoveInventoryItem；<img src='https://img-blog.csdnimg.cn/2020111816420391.png'></li></ol><h3 id="C-Inventory相关"><a href="#C-Inventory相关" class="headerlink" title="C_Inventory相关"></a>C_Inventory相关</h3><ol><li>创建函数[Output(S_InventoryItem)]GetInventoryItem(InventoryIndex(Integer))，根据物品索引获取物品信息；<img src='https://img-blog.csdnimg.cn/2020111816541335.png'></li></ol><h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol><li>创建函数[Void]ClearInventoryIndexItem(ToInventoryIndex(Integer))，用于根据索引删除对应插槽处的物品；<img src='https://img-blog.csdnimg.cn/20201118170944877.png'></li><li>创建函数[Void]AddItem(Inventory(C_Inventory),ToInventoryIndex(Integer),InventoryItem(S_InventoryItem))，调用客户端事件Client_SetInventorySlotItem；<img src='https://img-blog.csdnimg.cn/20201118170440602.png'></li><li>创建函数[Void]RemoveItem(Inventory(C_Inventory),FromInventoryIndex(Integer))，调用客户端事件Client_ClearInventoryIndexItem；<img src='https://img-blog.csdnimg.cn/20201118171358351.png'></li><li>创建函数[Void]MoveItem(FromInventoryIndex(Integer),ToInventoryIndex(Integer))，调用C_Inventory的GetInventoryItem获取From和To插槽处的物品信息（可能为空）。若为空，则调用AddItem和RemoveItem函数，实现物品拖拽后背包UI更新；<img src='https://img-blog.csdnimg.cn/20201118165913588.png'><img src='https://img-blog.csdnimg.cn/20201118165939535.png'></li></ol><h3 id="RPG-PlayerController相关-2"><a href="#RPG-PlayerController相关-2" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol><li>实现接口函数事件EventUIMoveInventoryItem，调用服务端事件Server_MoveInventoryItem；<img src='https://img-blog.csdnimg.cn/20201118172144413.png'></li></ol><h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-MoveInventoryItem"><a href="#Server-MoveInventoryItem" class="headerlink" title="Server_MoveInventoryItem"></a>Server_MoveInventoryItem</h4><p>在C_InventoryManager事件图表中创建，调用函数MoveItem；<img src='https://img-blog.csdnimg.cn/20201118164516806.png'></p><h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-ClearInventoryIndexItem"><a href="#Client-ClearInventoryIndexItem" class="headerlink" title="Client_ClearInventoryIndexItem"></a>Client_ClearInventoryIndexItem</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearInventoryIndexItem；<img src='https://img-blog.csdnimg.cn/20201118170841858.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="物品描述"><a href="#物品描述" class="headerlink" title="物品描述"></a>物品描述</h2><p><img src='https://img-blog.csdnimg.cn/20201118151239939.png'></p><h2 id="拖拽效果"><a href="#拖拽效果" class="headerlink" title="拖拽效果"></a>拖拽效果</h2><p><img src='https://img-blog.csdnimg.cn/20201118151448629.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：ToolTip，拖拽功能，RPC。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十九)</title>
    <link href="http://example.com/2020/11/17/RPG-Dev-Log-19/"/>
    <id>http://example.com/2020/11/17/RPG-Dev-Log-19/</id>
    <published>2020-11-17T07:43:14.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：背包系统数据绑定，服务端客户端初讲，RPC。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="背包系统数据绑定"><a href="#背包系统数据绑定" class="headerlink" title="背包系统数据绑定"></a>背包系统数据绑定</h2><h3 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h3><ol><li>创建枚举E_ItemType [其他物品,武器装备,消耗物品,任务物品]，用于设置物品类别；</li><li>创建枚举E_QualityType [Poor,Common,Uncommon,Rare,Epic,Legendary]，用于设置物品品级；</li></ol><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ol><li><p>创建结构体S_InventoryItem，用于设置物品的ID、图标、名字、描述、品级、类别、数量、价值、是否可堆叠、堆叠上限、是否可拖拽等信息；<img src='https://img-blog.csdnimg.cn/2020111716025619.png'></p></li><li><p>创建结构体S_InventoryID，用于设置物品ID等从服务端发送过来的简单字符串；<img src='https://img-blog.csdnimg.cn/20201117171747606.png'></p></li><li><p>创建结构体S_QualityColor，用于设置不同品级的物品颜色；<img src='https://img-blog.csdnimg.cn/20201117181151413.png'></p></li></ol><h3 id="创建数据表ItemList"><a href="#创建数据表ItemList" class="headerlink" title="创建数据表ItemList"></a>创建数据表ItemList</h3><ol><li>选择S_InventoryItem，创建数据表ItemList;<img src='https://img-blog.csdnimg.cn/20201117161557370.png'><img src='https://img-blog.csdnimg.cn/20201117161720162.png'></li><li>创建任务物品Food_Grain；<img src='https://img-blog.csdnimg.cn/20201117161014212.png'></li><li>创建其他物品Rock；<img src='https://img-blog.csdnimg.cn/20201117161122363.png'></li><li>创建消耗物品Food_Cupcake;<img src='https://img-blog.csdnimg.cn/2020111716124483.png'></li><li>创建消耗物品Bush;<img src='https://img-blog.csdnimg.cn/20201117161320380.png'></li></ol><h3 id="创建组件C-Inventory"><a href="#创建组件C-Inventory" class="headerlink" title="创建组件C_Inventory"></a>创建组件C_Inventory</h3><ol><li>创建函数[Success(Boolean)] InitializeInventory(InventorySize(Integer))，用于初始化Inventory(S_InventoryItem[])数组;<img src='https://img-blog.csdnimg.cn/20201117162452567.png'></li><li>创建函数[Inventory(S_InventoryItem[])] GetInventoryItem()，用于获取Inventory数组；<img src='https://img-blog.csdnimg.cn/20201117163625345.png'></li><li>创建函数[Success(Boolean)] SetInventoryItem(Index(Integer),Item(S_InventoryItem))，用于设置Inventory[Index]物品属性；<img src='https://img-blog.csdnimg.cn/20201117162831113.png'></li><li>创建函数[Success(Boolean)]LoadInventoryItem (InventorySize(Integer),TargetArray(S_InventoryItem[]))，调用函数InitializeInventory和SetInventoryItem，加载所有物品属性；<img src='https://img-blog.csdnimg.cn/20201117164028913.png'></li></ol><h3 id="创建组件C-InventoryManager"><a href="#创建组件C-InventoryManager" class="headerlink" title="创建组件C_InventoryManager"></a>创建组件C_InventoryManager</h3><ol><li>创建函数[Void]Initialize_UI_PC_Main()，用于初始化PC_Main(W_PC_Main)；<img src='https://img-blog.csdnimg.cn/20201117172454711.png'></li><li>创建函数[Void]InitializePlayerInventoryComponent，用于初始化PlayerInventory(C_Inventory)；<img src='https://img-blog.csdnimg.cn/20201117172848864.png'></li><li>创建函数[Void]LoadInventory(),用于根据背包物品属性创建W_InventorySlot实例，并添加到W_InventoryWindow内的InventorySlotWrapBox内，创建的实例个数由InventorySize决定。最后调用服务端事件Server_RefreshInventory；<img src='https://img-blog.csdnimg.cn/20201117174722222.png'></li><li>创建函数[Void]ClearInventorySlotItem()，用于初始化W_InventorySlot中的变量ItemInformation；<img src='https://img-blog.csdnimg.cn/20201117180831721.png'></li><li>创建函数[Void]SetInventorySlotItem()，用于设置InventorySlot[SlotIndex]的ItemInformation属性;<img src='https://img-blog.csdnimg.cn/20201117182259271.png'></li><li>创建函数[Void]RefreshInventorySlots()，调用客户端事件Client_SetInventorySlotItem和Client_SetInventorySlotItem，刷新背包数据并更新Slot；<img src='https://img-blog.csdnimg.cn/20201117182927647.png'><img src='https://img-blog.csdnimg.cn/20201117182532491.png'></li><li>创建函数[Void]OpenInventoryWindow()，用于显示背包窗口；<img src='https://img-blog.csdnimg.cn/20201117183626422.png'></li><li>创建函数[Void]CloseInventoryWindow()，用于隐藏背包窗口；<img src='https://img-blog.csdnimg.cn/20201117183710298.png'></li></ol><h3 id="W-InventorySlot属性绑定"><a href="#W-InventorySlot属性绑定" class="headerlink" title="W_InventorySlot属性绑定"></a>W_InventorySlot属性绑定</h3><ol><li>物品边框BrushColor属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181452720.png'></li><li>物品图表BrushImage属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181717696.png'></li><li>物品数量Text属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181817509.png'></li></ol><h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="RPG-PlayerController"><a href="#RPG-PlayerController" class="headerlink" title="RPG_PlayerController"></a>RPG_PlayerController</h3><ol><li><p>添加组件C_Inventory和C_InventoryManager；</p></li><li><p>勾选Replication&gt;Replicates，将自身复制到服务端；</p></li><li><p>创建函数Server_LoadPlayerItem，限制事件执行位置位于服务端，本地创建InventoryID数组模拟解包后的数据（此处省略了服务端向客户端发送数据包的过程）。根据从服务器获取的InventoryID，从本地ItemList加载物品属性，并存入本地变量LocalInventory。添加完成后，调用C_Inventory的函数LoadInventoryItem加载背包物品，传入的参数InventorySize来自C_InventoryManager的变量InventorySlot(Replicated)；</p><p><img src='https://img-blog.csdnimg.cn/20201117171957372.png'><img src='https://img-blog.csdnimg.cn/20201117171456274.png'></p></li><li><p>在EventBeginPlay中调用函数InitializePlayerInventoryComponent初始化C_Inventory，随后调用ServerLoadPlayerItem从服务端加载（简单）数据，然后调用函数Initialize_UI_PC_Main初始化W_PC_Main，最后调用事件Client_LoadInventory，从客户端加载（更为详细的）数据;<img src='https://img-blog.csdnimg.cn/2020111717564280.png'></p></li><li><p>删除BP_Player中的热键I事件，更改为在RPG_PlayerController中调用，根据InventoryManager中的IsInventoryOpen布尔值，判断是调用客户端事件Client_OpenInventory，还是调用Client_ClosenInventory；<img src='https://img-blog.csdnimg.cn/2020111718430680.png'></p></li></ol><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-InitializeInventory"><a href="#Server-InitializeInventory" class="headerlink" title="Server_InitializeInventory"></a>Server_InitializeInventory</h4><p>在C_Inventory事件图表中创建，调用函数InitializeInventory；<img src='https://img-blog.csdnimg.cn/20201117164840990.png'></p><h4 id="Server-RefreshInventory"><a href="#Server-RefreshInventory" class="headerlink" title="Server_RefreshInventory"></a>Server_RefreshInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数RefreshInventorySlots；<img src='https://img-blog.csdnimg.cn/20201117180225333.png'></p><h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-LoadInventory"><a href="#Client-LoadInventory" class="headerlink" title="Client_LoadInventory"></a>Client_LoadInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数LoadInventory;<img src='https://img-blog.csdnimg.cn/20201117173447637.png'></p><h4 id="Client-ClearInventorySlotItem"><a href="#Client-ClearInventorySlotItem" class="headerlink" title="Client_ClearInventorySlotItem"></a>Client_ClearInventorySlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearInventorySlotItem;<img src='https://img-blog.csdnimg.cn/2020111718045423.png'></p><h4 id="Client-SetInventorySlotItem"><a href="#Client-SetInventorySlotItem" class="headerlink" title="Client_SetInventorySlotItem"></a>Client_SetInventorySlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SetInventorySlotItem;<img src='https://img-blog.csdnimg.cn/20201117182358410.png'></p><h4 id="Client-OpenInventory"><a href="#Client-OpenInventory" class="headerlink" title="Client_OpenInventory"></a>Client_OpenInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数OpenInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201117183848642.png'></p><h4 id="Client-CloseInventory"><a href="#Client-CloseInventory" class="headerlink" title="Client_CloseInventory"></a>Client_CloseInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201117183911582.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201117155229532.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：背包系统数据绑定，服务端客户端初讲，RPC。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十八)</title>
    <link href="http://example.com/2020/11/16/RPG-Dev-Log-18/"/>
    <id>http://example.com/2020/11/16/RPG-Dev-Log-18/</id>
    <published>2020-11-16T07:24:17.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：脚部IK制作。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="脚部IK制作"><a href="#脚部IK制作" class="headerlink" title="脚部IK制作"></a>脚部IK制作</h2><h3 id="事件图表"><a href="#事件图表" class="headerlink" title="事件图表"></a>事件图表</h3><h4 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h4><ol><li><p>创建宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Start(Vector),End(Vector)]TraceStart&#x2F;End(X(Float),Y(Float),Z(Float))</span><br></pre></td></tr></table></figure><p>用于计算射线检测的起点和终点位置;<img src='https://img-blog.csdnimg.cn/20201116155309202.png'></p></li><li><p>创建宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ClampedOffset(Vector)]ClampOffset(Roll(Float),Pitch(Float),Z(Float))</span><br></pre></td></tr></table></figure><p>用于限制X,Y,Z轴的偏移距离；<img src='https://img-blog.csdnimg.cn/20201116161451526.png'></p></li><li><p>创建宏</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Return(Vector)]InterpOffsets(Current(Vector),Target(Vector))</span><br></pre></td></tr></table></figure><p>用于从Current到Target插值计算X,Y,Z轴偏移量;<img src='https://img-blog.csdnimg.cn/20201116164750110.png'></p><blockquote><p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/Vector2DInterpTo/index.html">Vector2DInterpTo</a></strong></p><p>Interpolate vector2D from Current to Target.</p><p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/FInterpTo/index.html">FInterpTo</a></strong></p><p>Interpolate float from Current to Target.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CORE_API <span class="keyword">float</span> <span class="title">FMath::FInterpTo</span><span class="params">( <span class="keyword">float</span> Current, <span class="keyword">float</span> Target, <span class="keyword">float</span> DeltaTime, <span class="keyword">float</span> InterpSpeed )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If no interp speed, jump to target value</span></span><br><span class="line">    <span class="keyword">if</span>( InterpSpeed &lt;= <span class="number">0.f</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distance to reach</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> Dist = Target - Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If distance is too small, just set the desired location</span></span><br><span class="line">    <span class="keyword">if</span>( FMath::Square(Dist) &lt; SMALL_NUMBER )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delta Move, Clamp so we do not over shoot.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> DeltaMove = Dist * FMath::Clamp&lt;<span class="keyword">float</span>&gt;(DeltaTime * InterpSpeed, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Current + DeltaMove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ol><li><p>折叠函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OutHit_bBlockingHit(Boolean),ClampedOffset(Vector)]TraceFootIK(A_Z(Float),B_X(Float),B_Y(Float))</span><br></pre></td></tr></table></figure><blockquote><p><strong><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/Collision/LineTraceByChannel/index.html">LineTraceByChannel</a></strong></p><p>Does a collision trace along the given line and returns the first blocking hit encountered. This trace finds the objects that RESPONDS to the given TraceChannel</p></blockquote><p>调用宏TraceStart/End和函数LineTraceByChannel，计算脚部Roll,Pitch轴的Rotation偏移量和Z轴偏移量，并调用宏ClampOffset，限制偏移范围。具体计算方式为：</p><p>Roll = arctan(OutHitNormal.y/OutHitNormal.z)</p><p>Pitch = arctan(OutHitNormal.x/OutHitNormal.z)</p><p>z = WorldLoaction.z - OutHitLocation.z；<img src='https://img-blog.csdnimg.cn/20201116163019606.png'></p></li><li><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[void]FootIK()</span><br></pre></td></tr></table></figure><p>脚部IK数值计算汇总（此函数在EventBlueprintUpdateAnimation中调用）：当角色不在跳跃状态时，获取foot_l和foot_r的骨骼位置，调用函数TraceFootIK，根据Hit布尔值设置LeftFootOffsetsTarget的值(ClampedOffset or Zero)。循环调用宏InterpOffsets实现脚部偏移过渡效果，并设置Pelvis.z=Min(LeftFootOffset.z,RightFootOffset.z);</p><p><img src='https://img-blog.csdnimg.cn/2020111617001856.png'></p><p><img src='https://img-blog.csdnimg.cn/2020111616594744.png'></p><p><img src='https://img-blog.csdnimg.cn/20201116165832569.png'></p></li></ol><h3 id="动画图表"><a href="#动画图表" class="headerlink" title="动画图表"></a>动画图表</h3><ol><li>现有Pose：Base—&gt;UpBody—&gt;LocalPose;<img src='https://img-blog.csdnimg.cn/20201116170745543.png'></li><li>打开骨骼树，添加虚拟骨骼VB thigh_l_calf_l和VB thigh_r_calf_r；<img src='https://img-blog.csdnimg.cn/20201116171006740.png'></li><li>添加Pose：LocalPose—&gt;FootIKPose</li></ol><ul><li><p>pelvis</p><p><img src='https://img-blog.csdnimg.cn/20201116172111319.png'></p></li><li><p>ik_foot_l &amp; VB thigh_l_calf_l</p><p><img src='https://img-blog.csdnimg.cn/20201116172150724.png'><img src='https://img-blog.csdnimg.cn/20201116172216387.png'></p></li><li><p>ik_foot_r &amp; VB thigh_r_calf_r</p><p><img src='https://img-blog.csdnimg.cn/20201116172256840.png'><img src='https://img-blog.csdnimg.cn/2020111617232282.png'></p></li></ul><p><img src='https://img-blog.csdnimg.cn/20201116172648890.png'></p><ol><li>最后按布尔输出混合姿势<br><img src='https://img-blog.csdnimg.cn/20201116172617594.png'>  </li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="添加前Shinbi右脚悬空"><a href="#添加前Shinbi右脚悬空" class="headerlink" title="添加前Shinbi右脚悬空"></a>添加前Shinbi右脚悬空</h2><p><img src='https://img-blog.csdnimg.cn/20201116152721533.png'></p><h2 id="添加后Shinbi右脚落地"><a href="#添加后Shinbi右脚落地" class="headerlink" title="添加后Shinbi右脚落地"></a>添加后Shinbi右脚落地</h2><p><img src='https://img-blog.csdnimg.cn/20201116160346496.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：脚部IK制作。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十七)</title>
    <link href="http://example.com/2020/11/14/RPG-Dev-Log-17/"/>
    <id>http://example.com/2020/11/14/RPG-Dev-Log-17/</id>
    <published>2020-11-14T07:55:56.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：Npc对话系统续，创建背包。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="NPC对话系统（续篇）"><a href="#NPC对话系统（续篇）" class="headerlink" title="NPC对话系统（续篇）"></a>NPC对话系统（续篇）</h2><ol><li>打开枚举E_SelectSubGoalType，添加两个新的枚举BackToLastQuest和FinishQuest;</li><li>打开结构体S_Conversation，添加两个新的成员RecieveTalkTypeInfo(Text)和RecieveQuestTalkInfo(S_SpeechContent[]);</li><li>打开BP_RPG_NPC，完善自定义事件OnClickBack，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114161008148.png'></li><li>修改自定义事件EventOnInteractWith,对TalkInfo做一次Select。交互NPC时将根据玩家是否已经接取任务，显示不同的对话信息条；<img src='https://img-blog.csdnimg.cn/20201114161616981.png'></li><li>修改自定义事件OnClickedQuestInfo，分别对SpeechContent和TalkInfo做一次Select。点击类型为QuestInfo的对话信息条时，将根据玩家是否已经接取任务，显示不同的下级对话信息条和对话信息盒内容；<img src='https://img-blog.csdnimg.cn/20201114161932684.png'></li><li>创建自定义事件SkipTalkInfo，用于跳过对话信息；<img src='https://img-blog.csdnimg.cn/20201114162118327.png'></li><li>打开W_TalkBorder，为HorizatontalBox添加一个SkipButton，并添加绑定事件SkipTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114162351432.png'><img src='https://img-blog.csdnimg.cn/20201114162420284.png'></li><li>创建函数UpdateQuestInfo(HasRecievedQuest?)，用于接取任务时更新对应的对话信息条，在OnClickAddQuest自定义事件中调用；<img src='https://img-blog.csdnimg.cn/20201114164749817.png'></li><li>创建自定义事件OnBackToLastSelect，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114164037125.png'></li><li>创建自定义事件OnFinishQuest，完成任务时根据当前索引移除对应的对话信息条,并返回上一级对话；<img src='https://img-blog.csdnimg.cn/20201114164220856.png'></li><li>更新自定义事件ContinueSelect，添加事件OnBackToLastSelect和OnFinishQuest的调用；<img src='https://img-blog.csdnimg.cn/20201114165003579.png'></li><li>打开D_NPC_Conversation，将TalkInfo[7].SelectSubGoalInfo[1].SelectSubGoalType改为Back，将TalkInfo[8].SelectSubGoalInfo[2].SelectSubGoalType改为BackToLastSelect;<img src='https://img-blog.csdnimg.cn/20201114163211314.png'></li><li>设置新增成员RecieveTalkTypeInfo和RecieveQuestTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114163638476.png'></li></ol><h2 id="创建背包"><a href="#创建背包" class="headerlink" title="创建背包"></a>创建背包</h2><blockquote><p>Spacer：留白占位控件</p><p>WrapBox：流布局控件，其子控件可以根据WrapBox的大小自动换行s</p></blockquote><ol><li>创建控件W_Window，用作背包窗口；<img src='https://img-blog.csdnimg.cn/20201114171504794.png'></li><li>将变量Name绑定至NameForWindow文本控件;</li><li>为CloseButton添加OnClicked绑定事件，添加节点RemoveFromParent；<blockquote><p>当前鼠标的本地位置（LocalPosition）由当前鼠标的绝对位置（AbsolutePosition）经过窗体几何变换得到。</p><p>Canvas Panel Slot插槽位置 = 拖拽终点鼠标的本地位置 - 拖拽起点鼠标的本地位置</p></blockquote></li><li>为DraggableBorder控件添加OnMouseButtonDown事件绑定<strong>（DraggableBorder的所有父控件可视性必须设置为Self Hit Test Invisible,否则无法响应事件）</strong>，判断鼠标是否按在DraggableBorder上，并获取鼠标拖拽后的位置，最后返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172104549.png'></li><li>创建重载函数OnMouseMove，更新拖拽后OutterVerticalBox的位置；<img src='https://img-blog.csdnimg.cn/20201114172158989.png'></li><li>创建重载函数OnMouseButtonUP，当鼠标抬起时结束DraggingWindow可拖拽判定，并返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172238741.png'></li><li>打开RPG_PlayerController，在EventBeginPlay中设置InputGameModeAndUI;<img src='https://img-blog.csdnimg.cn/20201114172545263.png'></li><li>创建Key I键盘输入事件，控制背包的显示和隐藏；<img src='https://img-blog.csdnimg.cn/20201114172647259.png'></li><li>创建控件W_Inventory，用作背包物品的图表和数量显示；<img src='https://img-blog.csdnimg.cn/20201114173149429.png'></li><li>打开事件图表，创建函数GenerateInventorySlot，用于测试背包物品的生成，在事件开始构造时调用;<img src='https://img-blog.csdnimg.cn/20201114173457586.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="接取NPC任务"><a href="#接取NPC任务" class="headerlink" title="接取NPC任务"></a>接取NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165442401.png'><img src='https://img-blog.csdnimg.cn/20201114170429745.png'></p><h2 id="提交NPC任务"><a href="#提交NPC任务" class="headerlink" title="提交NPC任务"></a>提交NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165550957.png'><img src='https://img-blog.csdnimg.cn/20201114170513599.png'></p><h2 id="完成NPC任务"><a href="#完成NPC任务" class="headerlink" title="完成NPC任务"></a>完成NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165629575.png'></p><h2 id="背包效果"><a href="#背包效果" class="headerlink" title="背包效果"></a>背包效果</h2><p><img src='https://img-blog.csdnimg.cn/20201114155859633.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：Npc对话系统续，创建背包。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十六)</title>
    <link href="http://example.com/2020/11/10/RPG-Dev-Log-16/"/>
    <id>http://example.com/2020/11/10/RPG-Dev-Log-16/</id>
    <published>2020-11-10T11:39:49.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建Npc对话系统（开篇），编辑剧本。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>创建枚举E_TalkType，代表当前对话选项对应的查看内容；<img src='https://img-blog.csdnimg.cn/20201110195932647.png'></li><li>创建枚举E_SelectSubGoalType，代表对话时分支选项的类型；<img src='https://img-blog.csdnimg.cn/2020111020024350.png'></li><li>创建结构体S_SelectSubGoalInfo，包含对话分支选项文本内容以及类型；<img src='https://img-blog.csdnimg.cn/2020111020054178.png'></li><li>创建结构体S_SpeechContent，包含Player与NPC对话的名字、内容、延迟(默认为4s)、是否有分支选项、分支选项内容；<img src='https://img-blog.csdnimg.cn/20201110200855293.png'></li><li>创建结构体S_Conversation，包含对话内容、对话信息、任务类、对话类型、指定任务是否已完成、推荐等级信息；<img src='https://img-blog.csdnimg.cn/20201110201213956.png'></li></ol><h2 id="创建BP-FindGrain"><a href="#创建BP-FindGrain" class="headerlink" title="创建BP_FindGrain"></a>创建BP_FindGrain</h2><p><img src='https://img-blog.csdnimg.cn/20201110220053550.png'></p><h2 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h2><h3 id="创建对话选项条W-TalkInfo"><a href="#创建对话选项条W-TalkInfo" class="headerlink" title="创建对话选项条W_TalkInfo"></a>创建对话选项条W_TalkInfo</h3><ol><li>层级面板和预览效果;<img src='https://img-blog.csdnimg.cn/20201110210022230.png'></li><li>打开事件图表，创建函数Update，用于根据TalkType更新TalkInfoImage、HotKeyText（选项数字）、SelectTalkInfo(按钮文本)，并在事件构造时调用;<img src='https://img-blog.csdnimg.cn/20201110210336891.png'></li><li>为SelectButton添加点击事件，根据SubGoalType判断相应的是OnClickedTalkTypeInfo事件（直接对话选项条）还是ContinueSelect事件（分支对话选项条）；<img src='https://img-blog.csdnimg.cn/2020111021555746.png'></li></ol><h3 id="创建对话信息盒W-TalKBorder"><a href="#创建对话信息盒W-TalKBorder" class="headerlink" title="创建对话信息盒W_TalKBorder"></a>创建对话信息盒W_TalKBorder</h3><ol><li>层级面板和预览效果(<strong>注意：将WrapperPolicy由默认模式更改为AllowPerCharacterWrapping，否则无法启用按长度换行功能</strong>)；<img src='https://img-blog.csdnimg.cn/20201110210623158.png'></li><li>打开事件图表，创建自定义事件ShowTalkInfo(Name,TalkInfo)和Hide()，用于显示和隐藏对话信息（实现一问一答的效果）；<img src='https://img-blog.csdnimg.cn/20201110211146795.png'></li></ol><h3 id="在W-PC-Main中添加对话选项盒和对话信息盒"><a href="#在W-PC-Main中添加对话选项盒和对话信息盒" class="headerlink" title="在W_PC_Main中添加对话选项盒和对话信息盒"></a>在W_PC_Main中添加对话选项盒和对话信息盒</h3><ol><li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211446980.png'></li></ol><h3 id="在W-Interaction中添加TalkInfoText"><a href="#在W-Interaction中添加TalkInfoText" class="headerlink" title="在W_Interaction中添加TalkInfoText"></a>在W_Interaction中添加TalkInfoText</h3><ol><li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211642270.png'></li><li>打开事件图表，创建自定义事件ShowTalkInfo(Text)，用于Player靠近NPC时，显示和隐藏NPC头上的信息；<img src='https://img-blog.csdnimg.cn/20201110211814747.png'></li></ol><h2 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h2><h3 id="将NPC互动更改为蓝图接口模式"><a href="#将NPC互动更改为蓝图接口模式" class="headerlink" title="将NPC互动更改为蓝图接口模式"></a>将NPC互动更改为蓝图接口模式</h3><ol><li>删除绑定事件OnInteract;</li><li>在ClassSettings中添加蓝图接口I_Interaction;</li><li>打开BP_RPG_NPC，在事件开始时将ConversationData(DataTable)添加至TalkInfo(S_Conversation);<img src='https://img-blog.csdnimg.cn/20201110204835322.png'></li><li>将Overlap事件更改为调用蓝图接口函数EventBeginOverlapTargetObject和EventEndOverlapTargetObject;<img src='https://img-blog.csdnimg.cn/20201110205210283.png'></li><li>删除OnInteract事件，更改为蓝图接口函数EventOnInteractWith，主要功能为：NPC头顶信息的显示与隐藏，对话选项盒的UI构建;<img src='https://img-blog.csdnimg.cn/20201110212312661.png'><img src='https://img-blog.csdnimg.cn/20201110212357282.png'><img src='https://img-blog.csdnimg.cn/20201110212443312.png'></li></ol><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ol><li><p>修改UpdateQuest，改为仅设置PlayLevel;<img src='https://img-blog.csdnimg.cn/20201110205805908.png'></p></li><li><p>创建事件OnClickedTalkTypeInfo，根据直接对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110213025561.png'></p></li><li><p>创建事件ContinueSelect，根据分支对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110215727110.png'></p></li><li><p>[E_TalkType]枚举事件：</p><ul><li><p>创建事件OnClickedQuestInfo，当点击类型为QuestInfo的对话选项条时，播放对话剧本，并展示对话分支选项，并根据分支选项判断是否接取Quest；</p></li><li><p>创建事件OnClickedEndTalk，结束对话并清空UI;</p></li><li>创建事件OnClickedElseInfo(尚未实装)</li><li>创建事件OnClickedGoodsStore(尚未实装)</li><li>创建事件OnClickedWeaponStore(尚未实装)</li><li>创建事件OnClickedEquipStore(尚未实装)</li><li>创建事件OnClickedDrugStore(尚未实装)</li><li>创建事件OnClickedFoodStore(尚未实装)</li></ul><p><img src='https://img-blog.csdnimg.cn/20201110213742981.png'><img src='https://img-blog.csdnimg.cn/20201110213844323.png'></p></li><li><p>[E_SelectSubGoalType]枚举事件：</p><ul><li>创建事件OnClickedContinue</li><li>创建事件OnClickedBack</li><li>创建事件OnClickedAddQuest</li><li>创建事件OnClickedQuit</li></ul></li></ol><h3 id="实例设置-NPC皮特"><a href="#实例设置-NPC皮特" class="headerlink" title="实例设置(NPC皮特)"></a>实例设置(NPC皮特)</h3><p><img src='https://img-blog.csdnimg.cn/20201110220234754.png'></p><h2 id="剧本编辑"><a href="#剧本编辑" class="headerlink" title="剧本编辑"></a>剧本编辑</h2><h3 id="创建Data-Table"><a href="#创建Data-Table" class="headerlink" title="创建Data Table"></a>创建Data Table</h3><ol><li>创建D_NPC_Conversation；<img src='https://img-blog.csdnimg.cn/20201110202006809.png'></li></ol><h3 id="编辑对话选项内容（含分支选项）"><a href="#编辑对话选项内容（含分支选项）" class="headerlink" title="编辑对话选项内容（含分支选项）"></a>编辑对话选项内容（含分支选项）</h3><ol><li><p>[QuestInfo]任务接取向——接取FindGrain任务：</p><p><img src='https://img-blog.csdnimg.cn/20201110203722362.png'></p></li><li><p>[ElseInfo]剧情介绍向——与NPC闲聊；<img src='https://img-blog.csdnimg.cn/20201110202040377.png'></p></li><li><p>[GoodsStore]市场交易向——杂货店：<img src='https://img-blog.csdnimg.cn/20201110202215835.png'></p></li><li><p>[WeaponStore]市场交易向——武器商店：<img src='https://img-blog.csdnimg.cn/20201110202303511.png'></p></li><li><p>[DrugStore]市场交易向——药品商店：<img src='https://img-blog.csdnimg.cn/20201110202358802.png'></p></li><li><p>[FoodStore]市场交易向——食物商店：<img src='https://img-blog.csdnimg.cn/20201110202638264.png'></p></li><li><p>[EquipStore]市场交易向——防具商店：<img src='https://img-blog.csdnimg.cn/20201110202659579.png'></p></li><li><p>[End]结束对话：<img src='https://img-blog.csdnimg.cn/2020111020280739.png'></p></li></ol><h3 id="编辑对话剧本"><a href="#编辑对话剧本" class="headerlink" title="编辑对话剧本"></a>编辑对话剧本</h3><div class="table-container"><table><thead><tr><th style="text-align:center">TalkerName</th><th style="text-align:center">SpeechInfo</th></tr></thead><tbody><tr><td style="text-align:center">Shinbi</td><td style="text-align:center">嗨，大叔，你知道如何才能进入峡谷吗？</td></tr><tr><td style="text-align:center">皮特</td><td style="text-align:center">大叔？小哥年方十八！</td></tr><tr><td style="text-align:center">Shibi</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">皮特</td><td style="text-align:center">咳咳。。。峡谷常年迷雾，又有猛兽出没，凶险万分，姑娘切莫深入。</td></tr><tr><td style="text-align:center">Shinbi</td><td style="text-align:center">大叔放心，小女子十八般武艺样样精通，拳打南山猛虎，脚踢北海蛟龙，正好顺道为名除害！</td></tr><tr><td style="text-align:center">皮特</td><td style="text-align:center">。。。大叔。。的确，看姑娘的着装并非普通女子，非富即贵，只是。。。</td></tr><tr><td style="text-align:center">Shinbi</td><td style="text-align:center">哈哈…就是，小女子才貌双全，大叔有何难处尽管直言！</td></tr><tr><td style="text-align:center">皮特</td><td style="text-align:center">呃。。这个，最近天降大雪，家中缺粮，我这不出来寻粮了吗，如果姑娘能带来一袋小麦，我将带你进入峡谷的入口。。。</td></tr><tr><td style="text-align:center">Shinbi(分支1-1)</td><td style="text-align:center">哈哈，小事情，交给我吧！不过这荒天雪地的能不能折现？？</td></tr><tr><td style="text-align:center">Shinbi(分支1-2)</td><td style="text-align:center">这荒天雪地的上哪去找一袋小麦。。</td></tr><tr><td style="text-align:center">皮特</td><td style="text-align:center">这个、、、多谢女侠，折合成市价30硬币。</td></tr><tr><td style="text-align:center">Shinbi(分支2-1)</td><td style="text-align:center">给与30硬币。</td></tr><tr><td style="text-align:center">Shinbi(分支2-2)</td><td style="text-align:center">给与一袋小麦。</td></tr><tr><td style="text-align:center">Shinbi(分支2-3)</td><td style="text-align:center">我再想想。。</td></tr></tbody></table></div><p><img src='https://img-blog.csdnimg.cn/20201110203809964.png'></p><p><img src='https://img-blog.csdnimg.cn/20201110203838787.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201110194837692.png'></p><p><img src='https://img-blog.csdnimg.cn/20201110194928442.png'></p><p><img src='https://img-blog.csdnimg.cn/20201110195002450.png'></p><p><img src='https://img-blog.csdnimg.cn/2020111019504116.png'></p><p><img src='https://img-blog.csdnimg.cn/20201110195118759.png'></p><p><img src='https://img-blog.csdnimg.cn/20201110195145659.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建Npc对话系统（开篇），编辑剧本。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十五)</title>
    <link href="http://example.com/2020/11/07/RPG-Dev-Log-15/"/>
    <id>http://example.com/2020/11/07/RPG-Dev-Log-15/</id>
    <published>2020-11-07T16:13:02.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统续，任务分支完成互动。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="W-PC-Main相关"><a href="#W-PC-Main相关" class="headerlink" title="W_PC_Main相关"></a>W_PC_Main相关</h2><ol><li><p>创建动画HideAll，用于隐藏主界面的所有用户自定义控件；<img src='https://img-blog.csdnimg.cn/20201108003424947.png'></p></li><li><p>创建函数[Float] PlayHideAll(Boolean)，用于控制HideAll动画的播放；<img src='https://img-blog.csdnimg.cn/20201108004704213.png'></p></li></ol><h2 id="W-Mission相关"><a href="#W-Mission相关" class="headerlink" title="W_Mission相关"></a>W_Mission相关</h2><ol><li>界面优化：打开W_Mission，为任务列表栏和任务详情栏添加边框(Image/Border);<img src='https://img-blog.csdnimg.cn/20201108002312944.png'></li><li>控件添加：添加返回按钮，取消勾选Interaction&gt;IsFocusable，并创建OnClick事件：点击按钮时隐藏任务系统界面并显示主界面；<img src='https://img-blog.csdnimg.cn/20201108004137729.png'><img src='https://img-blog.csdnimg.cn/20201108012623353.png'></li><li>动画添加：为SelectedBorder和CancelBorder添加ButtonPlay和ButtonCancel动画（两个动画除绑定对象不同外，其余都相同），并分别创建OnClick事件：点击SelectButton时播放ButtonPlay动画，调用SelectNewQuest事件，并隐藏SelectButton所在的HorizantalBox（使其无法再次被选择）。点击ButtonCancel时播放ButtonCancel动画。最后修改函数UpdateDetailWindow，比较SelectedQuest是否为CurrentQuest，若为真则隐藏SelectedHorizantalBox，否则显示SelectedHorizantalBox；<img src='https://img-blog.csdnimg.cn/20201108012156563.png'><img src='https://img-blog.csdnimg.cn/20201108014256728.png'><img src='https://img-blog.csdnimg.cn/2020110801435634.png'></li><li>函数修改：修改函数GenertateSubGoals，将参数HuntIndex传入W_MissionSubGoal；<img src='https://img-blog.csdnimg.cn/20201108231031870.png'></li></ol><h2 id="W-MissionSubGoal相关"><a href="#W-MissionSubGoal相关" class="headerlink" title="W_MissionSubGoal相关"></a>W_MissionSubGoal相关</h2><ol><li>修改函数Update，更新Hunt类型分支任务的信息；<img src='https://img-blog.csdnimg.cn/20201108024335447.png'></li></ol><h2 id="W-Quest相关"><a href="#W-Quest相关" class="headerlink" title="W_Quest相关"></a>W_Quest相关</h2><ol><li>修改函数[void]SelectSubGoal(W_SubGoal)，当SelectedSubGoal与传入的SubGoal不同时，更新SelectedSubGoal;<img src='https://img-blog.csdnimg.cn/20201108021956595.png'></li></ol><h2 id="W-SubGoal相关"><a href="#W-SubGoal相关" class="headerlink" title="W_SubGoal相关"></a>W_SubGoal相关</h2><ol><li>控件添加：添加FailedImage，对应SuccessImage;<img src='https://img-blog.csdnimg.cn/20201108020420640.png'></li><li>函数功能扩展：修改函数[void]DisableButton()为[void]DisableButton(Success?)，当任务完成时显示SuccessImage，任务失败时显示FailedImage;<img src='https://img-blog.csdnimg.cn/2020110916482665.png'></li><li>函数功能扩展：修改函数Update，添加CurrentSubGoal索引查询，并设置为HuntedIndex。添加SubGoalState，并对其作一个Select，以更新SubGoal信息（注意，如果此处不作select，SubGoal当前击杀/寻找数会循环0,1,2）;<img src='https://img-blog.csdnimg.cn/20201108023744297.png'><img src='https://img-blog.csdnimg.cn/20201109164737918.png'></li></ol><h2 id="BP-MasterQuest相关"><a href="#BP-MasterQuest相关" class="headerlink" title="BP_MasterQuest相关"></a>BP_MasterQuest相关</h2><ol><li>创建函数[Boolean]SelectInMission()，用于判断SelectedQuest是否为CurrentQuest；<img src='https://img-blog.csdnimg.cn/20201108014943318.png'></li><li>修改函数SetupStartingSubGoals，根据StartSubGoalIndices的数组长度对CurrentHuntedAmount数组进行Resize;<img src='https://img-blog.csdnimg.cn/20201108015344389.png'></li><li>修改函数[void]CompleteSubGoal(SubGoalIndex，Success?)，将传入参数Success提升为本地变量，并传入函数DisableButton(Success?)；<img src='https://img-blog.csdnimg.cn/20201109165028882.png'><img src='https://img-blog.csdnimg.cn/20201109165053562.png'><img src='https://img-blog.csdnimg.cn/20201109165133515.png'><img src='https://img-blog.csdnimg.cn/20201109165224466.png'></li><li>修改自定义事件UpdateCompletedSubGoal，初始化CurrentHuntedAmout数组为0，修改SubGoal的延迟更新条件;<img src='https://img-blog.csdnimg.cn/2020110802323032.png'><img src='https://img-blog.csdnimg.cn/20201108023250768.png'></li></ol><h2 id="BP-Enemy相关"><a href="#BP-Enemy相关" class="headerlink" title="BP_Enemy相关"></a>BP_Enemy相关</h2><ol><li>打开事件图表，修改自定义事件OnDeath，调用QuestManager自定义事件OnEnemyKilled；<img src='https://img-blog.csdnimg.cn/20201108031744839.png'></li></ol><h2 id="BP-QuestTest相关"><a href="#BP-QuestTest相关" class="headerlink" title="BP_QuestTest相关"></a>BP_QuestTest相关</h2><ol><li>打开测试专用Quest，创建Hunt型分支任务，猎杀目标为Enemy_Grunting;<img src='https://img-blog.csdnimg.cn/20201108031950863.png'></li></ol><h2 id="BP-TargetObject及其相关子类"><a href="#BP-TargetObject及其相关子类" class="headerlink" title="BP_TargetObject及其相关子类"></a>BP_TargetObject及其相关子类</h2><ol><li><p>BP_TargetObject组件面板修改如下（StaticMesh已被删除）；</p><p><img src='https://img-blog.csdnimg.cn/20201108033013777.png'></p></li><li><p>为Object_Treasure单独添加StaticMesh组件；</p></li><li><p>创建新的子类Object_Grain，并添加StaticMesh组件，将谷物袋子模型导入，设置Name和Interact文本初始值。添加接口EventOnInteractWith（Character)，调用OnObjectFound事件；<img src='https://img-blog.csdnimg.cn/20201108033817418.png'></p></li></ol><h2 id="QuestManager相关"><a href="#QuestManager相关" class="headerlink" title="QuestManager相关"></a>QuestManager相关</h2><ol><li>函数模块化：打开函数[void] AddQuest(QuestClass,DirectlyStart)，将Branch之后有关Quest和SubGoal动画播放的蓝图迁移至自定义事件SelectNewQuest(NewQuest)，当CurrentQuest为NULL时更新Quest并播放动画，不为NULL时检测SubGoal首项是否有效（若无效则更新Quest，否则延迟更新直至SubGoal首项无效）。在AddQuest中被调用;<img src='https://img-blog.csdnimg.cn/20201108011601891.png'></li><li>创建自定义事件OnEnemyKilled(Class)，锁定类型为Hunt的分支任务的Index，并根据击杀的敌人类型判断是否为有效击杀，若为有效击杀则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若击杀数大于需求数，则调用CompleteSubGoal。<img src='https://img-blog.csdnimg.cn/20201108030332689.png'><img src='https://img-blog.csdnimg.cn/20201108031407189.png'></li><li>创建自定义事件OnObjectFound(Class)，锁定类型为Search的分支任务的Index，并根据找到的物品类型判断是否为有效寻找，若为有效寻找则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若找到的数量大于需求数，则调用CompleteSubGoal。（相关蓝图与OnEnemyKilled(Class)类似）</li></ol><h2 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h2><ol><li>打开事件图表，修改Tab事件，打开任务系统界面时暂停游戏；<img src='https://img-blog.csdnimg.cn/2020110800393081.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="【子任务】狩猎小鬼完成效果"><a href="#【子任务】狩猎小鬼完成效果" class="headerlink" title="【子任务】狩猎小鬼完成效果"></a>【子任务】狩猎小鬼完成效果</h2><p><img src='https://img-blog.csdnimg.cn/20201109160208908.png'><img src='https://img-blog.csdnimg.cn/202011091641213.png'></p><h2 id="【子任务】寻找小麦完成效果"><a href="#【子任务】寻找小麦完成效果" class="headerlink" title="【子任务】寻找小麦完成效果"></a>【子任务】寻找小麦完成效果</h2><p><img src='https://img-blog.csdnimg.cn/20201108230246514.png'></p><p><img src='https://img-blog.csdnimg.cn/20201108230310157.png'></p><h2 id="【子任务】完成前后对比"><a href="#【子任务】完成前后对比" class="headerlink" title="【子任务】完成前后对比"></a>【子任务】完成前后对比</h2><p><img src='https://img-blog.csdnimg.cn/20201108230013575.png'></p><p><img src='https://img-blog.csdnimg.cn/20201108230045246.png'></p><p><img src='https://img-blog.csdnimg.cn/2020110916421358.png'></p><p><img src='https://img-blog.csdnimg.cn/20201109164242272.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统续，任务分支完成互动。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十四)</title>
    <link href="http://example.com/2020/11/04/RPG-Dev-Log-14/"/>
    <id>http://example.com/2020/11/04/RPG-Dev-Log-14/</id>
    <published>2020-11-04T15:01:43.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统创建(续篇),蓝图UI任务数据绑定。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="创建W-MissionSubGoal"><a href="#创建W-MissionSubGoal" class="headerlink" title="创建W_MissionSubGoal"></a>创建W_MissionSubGoal</h2><ol><li>创建控件W_MissionSubGoal，作为W_Mission中任务分支信息SubGoalInfoVerticalBox的子控件；<br><img src='https://img-blog.csdnimg.cn/20201105072242910.png'><img src='https://img-blog.csdnimg.cn/20201105072311908.png'></li><li>创建函数Update，用于更新SubGoalText的文本内容(这部分蓝图可从W_SubGoal中的Update函数迁移过来)，并根据任务状态设置CurrentImage、SuccessImage、FailedImage的可视性，并在事件开始构造时调用；<img src='https://img-blog.csdnimg.cn/20201105072948473.png'></li></ol><h2 id="任务列表项W-QuestBorder"><a href="#任务列表项W-QuestBorder" class="headerlink" title="任务列表项W_QuestBorder"></a>任务列表项W_QuestBorder</h2><ol><li>打开S_QuestInfo，添加属性SuggestedLevel(Integer)；</li><li>打开W_QuestBorder，创建函数[void] Update()，用于绑定W_QuestBorder相关任务数据，包括QuestName、Frame、RegionText、LevelText、QuestTypeIcon等控件的文本、颜色、图标等，并且对QuestName控件的文本进行长度检测（任务名过长时缩略显示）；<img src='https://img-blog.csdnimg.cn/20201104232620180.png'></li><li>创建自定义事件UpdateSuggestedLevelColor(PlayerLevel)并绑定至事件调度UpdateLevelQuest。每当角色升级时，调用此事件，更新任务推荐等级的文本颜色，为游戏玩家提供更好的视觉效果（具体方法与Enemy的头衔颜色更新类似，通过PlayerLevel/Suggested的值设置Alpha的值，从而设置颜色过渡）。最后调用Update函数，完成任务列表所有数据项的显示更新;<img src='https://img-blog.csdnimg.cn/20201104233806488.png'></li></ol><h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><ol><li>打开W_QuestBorder，为AnimBorder创建划入(AddQuestBorder)和划出(RemoveQuestBorder)动画；<img src='https://img-blog.csdnimg.cn/20201104234440454.png'><img src='https://img-blog.csdnimg.cn/20201104234537409.png'></li><li>创建宏ShowQuestBorder(Visible)，用于根据当前控件的可视性播放划入或划出动画；<img src='https://img-blog.csdnimg.cn/20201104234832171.png'></li><li>为CurrentQuestButton、CompletedQuestButton、FailedQuestButton、HasQuestButton添加绑定事件：以CurrentQuestButton为例，当点击按钮时，隐藏CompletedScrollBox、FailedScrollBox、HasQuestScrollBox三个滚动框，并显示CurrentScrollBox（其余三个按钮同理）；<img src='https://img-blog.csdnimg.cn/2020110423525363.png'></li><li>创建自定义事件UpdateSuggestedLevel(PlayerLevel)，用于设置任务详情中推荐等级的文本颜色（设置方法同上）,并将此自定义事件绑定至事件调度UpdateLevelForQuest；<img src='https://img-blog.csdnimg.cn/2020110500005662.png'><img src='https://img-blog.csdnimg.cn/20201105000436852.png'></li><li>创建函数UpdateDescription，用于更新任务的具体描述，相关控件为DescriptionText，这里需要注意文本换行符的转义方式;<img src='https://img-blog.csdnimg.cn/2020110500113572.png'></li><li>创建函数UpdateDetailWindow，用于绑定W_Mission任务详情的相关任务数据，包括QuestName、TypeText、QuestTypeImage、RegionText、SuggestedLevel、MoneyText、ExpText、PrestigeText等控件的文本、颜色和图标等，数据源为SelectedQuest(BP_MasterQuest，所有Quest的父类)中的QuestInfo，并调用函数UpdateSuggestedLevel(PlayerLevel)，UpdateDescription，GenerateSubGoals；<img src='https://img-blog.csdnimg.cn/20201105064907715.png'><img src='https://img-blog.csdnimg.cn/20201105065000665.png'><img src='https://img-blog.csdnimg.cn/20201105065053167.png'><img src='https://img-blog.csdnimg.cn/2020110506512638.png'></li><li>创建函数GenerateSubGoals，用于更新SubGoalVerticalBox控件，绑定任务分支信息的相关数据，数据源为SelectedQuest(BP_MasterQuest)中的CompleteSubGoalInfo和CurrentSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201105071813592.png'></li><li>创建枚举E_QuestState；<img src='https://img-blog.csdnimg.cn/20201105073933672.png'></li><li>创建函数AddQuestBorder(Quest)，用于任务列表项W_QuestBorder(CurrentScrollBox等滚动框的子控件)的添加；<img src='https://img-blog.csdnimg.cn/20201105073719617.png'></li><li>创建自定义事件OnQuestBorderClicked(QuestBorder)，绑定至W_QuestBorder中的按钮QuestBorderButton。当任务列表项被点击时，禁用该列表项按钮，并调用函数UpdateDetailWindow，完成任务详情的更新；<img src='https://img-blog.csdnimg.cn/20201105074414237.png'><img src='https://img-blog.csdnimg.cn/20201105074646874.png'></li></ol><h2 id="任务组件QuestManager"><a href="#任务组件QuestManager" class="headerlink" title="任务组件QuestManager"></a>任务组件QuestManager</h2><ol><li>创建结构体S_CompletedSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201105065535758.png'></li><li>创建枚举E_SubGoalState；<img src='https://img-blog.csdnimg.cn/20201105065701141.png'></li></ol><h2 id="任务父类BP-MasterQuest"><a href="#任务父类BP-MasterQuest" class="headerlink" title="任务父类BP_MasterQuest"></a>任务父类BP_MasterQuest</h2><ol><li>打开BP_MasterQuest，重新设置CompletedSubGoalsInfo变量类型为S_CompletedSubGoalInfo（原来为S_SubGoalInfo，即扩展SubGoalIndex、Succesful两个引脚);</li><li>函数功能扩展：函数CompleteSubGoal(SubGoalIndex)变更为CompleteSubGoal(SubGoalIndex,Success?)，传入任务是否成功完成的参数，以便于CompletedSubGoalsInfo变量的更新;</li><li>函数功能扩展：函数SetupStartingSubGoals新增Description的数据更新，数据源为QuestInfo;</li><li>函数功能扩展：函数AddQuest(QuestClass)变更为AddQuest(QuestClass,DirectlyStart)，根据当前任务数量和DirectlyStart的布尔值判断是否自动接取任务。若自动接取任务，则播放动画PlayQuest和PlaySubGoal(来着W_Quest)；</li><li>关联事件修改：打开事件图表，修改自定义事件UpdateCompletedSubGoal；</li></ol><h2 id="任务实例设置"><a href="#任务实例设置" class="headerlink" title="任务实例设置"></a>任务实例设置</h2><h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080724734.png'></p><h3 id="支线任务"><a href="#支线任务" class="headerlink" title="支线任务"></a>支线任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080758220.png'></p><h3 id="副本任务"><a href="#副本任务" class="headerlink" title="副本任务"></a>副本任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080823342.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201105082833827.png'><img src='https://img-blog.csdnimg.cn/20201105082916789.png'><img src='https://img-blog.csdnimg.cn/20201105083011449.png'><img src='https://img-blog.csdnimg.cn/20201105082938769.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统创建(续篇),蓝图UI任务数据绑定。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十三)</title>
    <link href="http://example.com/2020/11/03/RPG-Dev-Log-13/"/>
    <id>http://example.com/2020/11/03/RPG-Dev-Log-13/</id>
    <published>2020-11-03T03:31:15.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统创建（进阶），UI设计应用细讲。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><h3 id="任务类型侧边栏"><a href="#任务类型侧边栏" class="headerlink" title="任务类型侧边栏"></a>任务类型侧边栏</h3><p>涉及组件：</p><ul><li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]</li><li>Common: [Border]、[Button]、[Text]</li></ul><h4 id="层级面板"><a href="#层级面板" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103114016404.png'></p><h4 id="实装效果"><a href="#实装效果" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/20201103114544272.png'></p><h4 id="组件动画"><a href="#组件动画" class="headerlink" title="组件动画"></a>组件动画</h4><p>Widget可视性：</p><blockquote><p><strong>Visible(可视)</strong>： 可见、可点击<br><strong>Collapsed(已折叠)</strong>： 不可见、不占用布局空间（性能优于 Hidden）<br><strong>Hidden(隐藏)</strong>： 不可见、占用布局空间<br><strong>HitTestInvisible(非可命中测试（自身和所有子项）)</strong>： 可见、当前 Widget 不可点击、所有 Child Widget 不可点击<br><strong>SelfHitTestInvisible(非可命中测试（仅自身）)</strong>： 可见、当前 Widget 不可点击、不影响 Child Widget</p></blockquote><ol><li>打开W_Mission,添加组件动画OpenMission;<br><img src='https://img-blog.csdnimg.cn/20201103120349278.png'></li><li>创建宏ShowMission(Visible);<br><img src='https://img-blog.csdnimg.cn/20201103121441665.png'></li><li>创建自定义事件PlayMission(Visible)，调用宏ShowMission(Visible)；</li></ol><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>设计组件：</p><ul><li>Panel: [Size Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li><li>Common: [Border]、[Text]</li></ul><h4 id="层级面板-1"><a href="#层级面板-1" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103114907317.png'></p><h4 id="实装效果-1"><a href="#实装效果-1" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/20201103114943124.png'></p><h3 id="任务详情"><a href="#任务详情" class="headerlink" title="任务详情"></a>任务详情</h3><p>涉及组件：</p><ul><li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li><li>Common: [Border]、[Button]、[Text]、[Image]</li></ul><h4 id="层级面板-2"><a href="#层级面板-2" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103115323410.png'></p><h4 id="实装效果-2"><a href="#实装效果-2" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/2020110311543341.png'></p><h2 id="任务提示界面W-QuestBorder"><a href="#任务提示界面W-QuestBorder" class="headerlink" title="任务提示界面W_QuestBorder"></a>任务提示界面W_QuestBorder</h2><h3 id="层级面板-3"><a href="#层级面板-3" class="headerlink" title="层级面板"></a>层级面板</h3><p><img src='https://img-blog.csdnimg.cn/20201103120105457.png'></p><h3 id="实装效果-3"><a href="#实装效果-3" class="headerlink" title="实装效果"></a>实装效果</h3><p><img src='https://img-blog.csdnimg.cn/20201103120130439.png'></p><h2 id="热键测试"><a href="#热键测试" class="headerlink" title="热键测试"></a>热键测试</h2><p>打开RPG_PlayerController，添加热键Tab响应事件，切入和切出任务系统主界面；<br><img src='https://img-blog.csdnimg.cn/20201103121909957.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020110311322945.png'><img src='https://img-blog.csdnimg.cn/20201103113402801.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统创建（进阶），UI设计应用细讲。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>游戏人工智能:从FSM到Behavior Tree</title>
    <link href="http://example.com/2020/11/01/AI-BehaviorTree/"/>
    <id>http://example.com/2020/11/01/AI-BehaviorTree/</id>
    <published>2020-11-01T13:34:44.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A behavior tree is to express the behavior of artificial intelligence. The behavior tree has a characteristic that is easy to change state transitions than FSM(Finite State Machine).</p></blockquote><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以RPG游戏为例，无论是PVE模式还是PVP模式，都会涉及人工智能这个概念。其中包括引导新手的NPC，玩家对战的NPC等。</p><h2 id="FSM-Finite-State-Machine"><a href="#FSM-Finite-State-Machine" class="headerlink" title="FSM(Finite State Machine)"></a>FSM(Finite State Machine)</h2><p>双FSM是目前最常用的一样方法，它定义了有限多个状态（行为），用图表来表达状态之间的因果关系。虽然理解状态的组成和转移很容易，但有个问题：状态和转移越多，维护就越困难。</p><p><img src='https://img-blog.csdnimg.cn/20201101214601997.png' alt='[Fig.1] FSM'></p><h3 id="Fig-1-FSM"><a href="#Fig-1-FSM" class="headerlink" title="[Fig.1] FSM"></a>[Fig.1] FSM</h3><p>图示给出了FSM的一个例子。它由Search、Chase和Attack状态组成，状态转换条件显示在箭头之上。为了改进FSM，实现更加精密的人工智能开发，提出了行为树的概念。它仍然具有类似于FSM的形式，但是即便状态和状态之间的关系再多，管理难度也远小于FSM。它更适合具有复杂行为和功能的智能体。</p><h2 id="Behavior-Tree"><a href="#Behavior-Tree" class="headerlink" title="Behavior Tree"></a>Behavior Tree</h2><p><img src='https://img-blog.csdnimg.cn/20201101220407953.png' alt='[Fig.2] Behavior Tree'></p><h3 id="Fig-2-Behavior-Tree"><a href="#Fig-2-Behavior-Tree" class="headerlink" title="[Fig.2] Behavior Tree"></a>[Fig.2] Behavior Tree</h3><p>图示给出了一个行为树的例子。这些行为树在PRG/RTS/FPS等类型的游戏中都具备可用性。对于单个对象的行为或控制逻辑，我们认为没有必要使用行为树。</p><h3 id="原理和方法"><a href="#原理和方法" class="headerlink" title="原理和方法"></a>原理和方法</h3><p>行为树是通过将AI的角色行为定义为树的方法，通过连接角色行为的条件和因果关系，优先级等对应的节点来完成。 </p><h3 id="Unreal-Engine中的BT"><a href="#Unreal-Engine中的BT" class="headerlink" title="Unreal Engine中的BT"></a>Unreal Engine中的BT</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li>Task：基础节点。</li><li>Decorator：定义当前分支返回结果是否为真。</li><li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li><li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li><li>Service：在固定更新频率的黑板上运行。</li></ul><p><img src='https://img-blog.csdnimg.cn/20201101222235173.png' alt='[Table 2] Unreal Engine'></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src='https://img-blog.csdnimg.cn/20201101225753418.png' alt='[Fig.5] Unreal Engine Behavior Tree'></p><h3 id="Unity-Engine中的BT"><a href="#Unity-Engine中的BT" class="headerlink" title="Unity Engine中的BT"></a>Unity Engine中的BT</h3><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><ul><li>Action：基础节点。</li><li>Decorator：定义当前分支返回结果是否为真。</li><li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li><li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li><li>Priority selector：决定最高优先级的节点。</li><li>Parallel: 平行子节点将被同时执行。</li></ul><p><img src='https://img-blog.csdnimg.cn/20201101222050462.png' alt='[Table 1] Unity Engine'></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src='https://img-blog.csdnimg.cn/20201101230244379.png' alt='[Fig.6] Unity Engine Behavior Tree'></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == FAILURE:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selector_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == SUCCESS:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FAILURE</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parallel</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index_list = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">if</span> len(run_index_list) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> run_index_list:</span><br><span class="line">            state_dic[index] = child_list[index](owner)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        run_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">            state_dic[run_index] = child_list[run_index](owner)</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> state_dic.count(SUCCESS) &gt;= MIN_SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> SUCCESS</span><br><span class="line">    <span class="keyword">elif</span> state_dic.count(FAILURE) &gt;= MIN_FAILURE:</span><br><span class="line">        <span class="keyword">return</span> FAILURE</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> RUNNING</span><br></pre></td></tr></table></figure><h3 id="两大引擎中的BT对比-参照UE4"><a href="#两大引擎中的BT对比-参照UE4" class="headerlink" title="两大引擎中的BT对比(参照UE4)"></a>两大引擎中的BT对比(参照UE4)</h3><p>​        两个引擎的行为树具有很多共同点，就是可以很容易地了解一个行为实现的条件和下一个行为是什么。</p><p>我们定义一组AI行为：</p><ol><li><p>[EnemyNotInRange]以AI当前位置为中心，在一定范围内没有基地的情况下，为了寻找基地，AI将自主移动前进。</p></li><li><p>[EnemyInRange]若在前进途中遇到敌人，则攻击它，受到伤害降低生命值。</p></li><li><p>[NotHealth]若生命值为0，则死亡，否则继续执行1。</p></li><li><p>[EnemyBaseInRange]若发现基地，则攻击基地。</p></li></ol><p><img src='https://img-blog.csdnimg.cn/20201101225148412.png'  alt='[Fig.3] Unreal Engine Behavior Tree'></p><p><img src='https://img-blog.csdnimg.cn/20201101230351316.png' alt='[Fig.4] Unity Engine Behavior Tree'></p><h4 id="行为树为事件驱动型"><a href="#行为树为事件驱动型" class="headerlink" title="行为树为事件驱动型"></a>行为树为事件驱动型</h4><blockquote><p>行为树可避免在每帧中执行大量工作。行为树并不会经常检查相关变化是否已经发生，它只会被动地等待在树中引起变化的“事件”。</p><p>事件驱动型结构对运行性能和除错大有帮助。如果希望获得这些帮助，必须理解虚幻引擎树的其他不同点，并正确搭建行为树结构。</p><p>代码在整个树的每个标记中无需迭代，因此运行性能将大大提升！从概念上而言，我们不需要不停地问“我们到了吗”，只需要轻松休息，会有人来告诉我们“到啦！”</p><p>在行为树执行日志中反复查看对行为进行纠错时，最佳的方法是让日志显示相关的变更，不显示无关的变更。在事件驱动型应用中，无需过滤出在树上迭代并选择之前相同行为的无关步骤，因为额外的迭代从开始便并未发生！只有树中执行位置或黑板数值发生的变化会产生影响，不同之处显而易见。</p></blockquote><h4 id="条件语句并非叶节点"><a href="#条件语句并非叶节点" class="headerlink" title="条件语句并非叶节点"></a>条件语句并非叶节点</h4><blockquote><p>在行为树标准模型中，条件语句为 Task 叶节点，除成功和失败外不执行任何操作。虽然也可以使用传统的条件 tasks，但还是强烈推荐您使用 Decorator 系统作为条件语句。</p><p>使用 decorators 而非 tasks 作为条件语句有多个明显优点。</p><p>首先，条件 decorators 使行为树 UI 显得更加直观易读。条件语句位于其所控制分支树的根部，因此一旦条件语句未被满足，便可直接看到树的哪个部分被“关闭”。此外，所有叶节点均为行动 tasks，因此更容易分辨树在对哪些实际行动下达命令。 在传统模型中，条件语句混于叶节点中，因此需要花更多时间分辨哪些叶节点是条件语句，哪些叶节点是行动。</p></blockquote><h4 id="并发行为的特殊处理"><a href="#并发行为的特殊处理" class="headerlink" title="并发行为的特殊处理"></a>并发行为的特殊处理</h4><blockquote><p>标准行为树通常使用 <strong>Parallel composite</strong> 节点来处理并发行为。Parallel 节点同时执行其所有子项。在一个或多个子项树完成时，特殊规则将决定如何执行（取决于所需行为）。</p><p>Parallel 节点不是绝对的多线程（完全同步执行任务）。它们只是概念上一次执行多个任务的方式。它们经常在同一线程上运行，并在一些序列中开始。该序列应为不相关，因为它们全部在同一框架中发生。但有时它也很重要。</p><p>UE4 行为树抛弃了复杂 Parallel 节点，使用 <strong>Simple Parallel</strong> 节点和称为 <strong>Services</strong> 的特殊节点，以实现同类行为。</p><h4 id="Simple-Parallel-节点"><a href="#Simple-Parallel-节点" class="headerlink" title="Simple Parallel 节点"></a>Simple Parallel 节点</h4><p>Simple Parallel 节点只允许两个子项的存在：一个必为单独任务节点（含可选 decorators）、另一个为一个完整的分支树。</p><p>可以将 Simple Parallel 节点理解为：“执行 A 的同时也执行 B。”举例而言：“在攻击敌人时向敌人移动。”基本上来说，A 是主要任务，而 B 是等待 A 完成时执行的次要或补充任务。</p><p>有一些选项可以处理同时进行的次要任务（任务 B）。较之于传统 Parallel 节点，该节点在概念上还是相对简单。然而，它支持 Parallel 节点的多数常规用法。</p><p>可利用 Simple Parallel 节点简便地进行一些事件驱动型优化。而 Full Parallel 节点的优化则要复杂许多。</p><h4 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h4><p><strong>Services</strong> 是与 composite 节点（Selector、Sequence、或 Simple Parallel）相关的特殊节点。它能在每 X 秒注册回呼并执行多个定期发生类型的更新。</p><p>举例而言，service 能用于确定哪名敌人是 AI pawn 的最佳追逐目标；与此同时，pawn 在其行为树中继续正常追踪当前敌人。</p><p>只有执行仍然处于以 composite 节点（与 service 相关）为根的分支树中时，Services 方为有效。</p><h4 id="Decorator-“Observer-Aborts”-属性"><a href="#Decorator-“Observer-Aborts”-属性" class="headerlink" title="Decorator “Observer Aborts” 属性"></a>Decorator “Observer Aborts” 属性</h4><p>标准 Parallel 节点的一个常见用途是不断对条件进行检查，以便在条件无法达成时中止任务。举例而言，有一只猫执行序列，如“摇屁股”或“猛扑”，在老鼠已经逃进洞后，直接放弃任务。如使用 Parallel 节点，有一个子项将检查猫是否可以扑到老鼠，另一子项就是要执行的序列。因为 UE4 行为树是事件驱动型，条件 decorators 将观察数值，并在需要时中止任务。（在该例中，只需要在序列上添加“老鼠是否能被扑到” decorator，然后将 “Observer Aborts” 设为 “Self”。）</p></blockquote><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p>[1].Myoun-Jae Lee.A Proposal on Game Engine Behavior Tree[J].Journal of Digital Convergence,2016,14(8),415-421.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A behavior tree is to express the behavior of artificial intelligence. The behavior tree has a characteristic that is easy to change state transitions than FSM(Finite State Machine).&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Theories" scheme="http://example.com/categories/Theories/"/>
    
    
    <category term="Artificial Intelligence" scheme="http://example.com/tags/Artificial-Intelligence/"/>
    
    <category term="Behavior Tree" scheme="http://example.com/tags/Behavior-Tree/"/>
    
    <category term="Finite State Machine" scheme="http://example.com/tags/Finite-State-Machine/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十二)</title>
    <link href="http://example.com/2020/11/01/RPG-Dev-Log-12/"/>
    <id>http://example.com/2020/11/01/RPG-Dev-Log-12/</id>
    <published>2020-11-01T08:01:47.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：制作简单的粒子特效，获得经验金币，重生Enemy。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="敌人死后消亡特效"><a href="#敌人死后消亡特效" class="headerlink" title="敌人死后消亡特效"></a>敌人死后消亡特效</h2><ol><li>创建MaterialFunction[MF_DissolveEffect]，添加Input[Visibility]，Type=Function Input Scalar；<img src='https://img-blog.csdnimg.cn/2020110116235018.png'></li><li>打开Enemy材质球，调用MF_DissolveEffect，添加OnHit和Visibility参数，设置EmissiveColor和OpacityMask；<img src='https://img-blog.csdnimg.cn/20201101162845368.png'></li><li>创建Enemy材质球实例，选择PreviewMesh，设置EffectColor，调整OnHit和Visibility的值可预览Enemy被攻击时、消亡时的材质效果；<img src='https://img-blog.csdnimg.cn/20201101164744129.png'></li><li>创建AnimationNotify[ANS_DissolveEffect]，添加重载函数Received_NotifyTick，根据动画曲线[Dissolve_Spawn]渐变Visibility的值；<img src='https://img-blog.csdnimg.cn/20201101165355339.png'></li><li>为Enemy的七种随机死亡动画添加Notify[ANS_DissolveEffect]和Curve[Dissolve_Spawn];<img src='https://img-blog.csdnimg.cn/20201101165816602.png'></li></ol><h2 id="击杀敌人获得战利品"><a href="#击杀敌人获得战利品" class="headerlink" title="击杀敌人获得战利品"></a>击杀敌人获得战利品</h2><h3 id="获取经验值"><a href="#获取经验值" class="headerlink" title="获取经验值"></a>获取经验值</h3><h4 id="创建粒子特效"><a href="#创建粒子特效" class="headerlink" title="创建粒子特效"></a>创建粒子特效</h4><ol><li><p>创建材质球[P_Base]，添加Input[ParticleColor]，设置EmissiveColor和Opacity;<img src='https://img-blog.csdnimg.cn/20201101170341930.png'></p></li><li><p>创建材质球实例[P_Base_Inst];</p></li><li><p>打开初学者内容包里的P_Teleport_Tell_Source粒子特效，重命名为P_SoulXP，并打开;</p></li><li><p>对于第一个ParticleEmitter，将Emitter Duration设置为0，添加DirectLocation;</p></li><li><p>对于第二个ParticleEmitter，直接关闭;</p></li><li><p>对于第三个ParticleEmitter，将Emitter Duration设置为0，略微调大InitialSize，调整Sphere StartLocation的Z轴；</p></li><li><p>新建一个ParticleEmitter，将Material设置为P_Base_Inst，Spawn Rate设置为0，Burst Count设置为1，删除InitVelocity，调整ColorOverLife，添加Direct Location；</p></li><li><p>新建一个ParticleEmitter,TypeData设置为GPU Sprites,设置Spawn Distribution为Distribution Float Constant,添加Sphere并设置颜色;<img src='https://img-blog.csdnimg.cn/20201101172623580.png'></p></li></ol><h4 id="创建BP-XP"><a href="#创建BP-XP" class="headerlink" title="创建BP_XP"></a>创建BP_XP</h4><ol><li><p>创建Actor[BP_XP]，添加组件Sphere Collision，设置半径，应用物理属性，设置重量为3kg，更改碰撞预设为Custom;<img src='https://img-blog.csdnimg.cn/20201101173214860.png'></p></li><li><p>添加组件ParticleSystem，将Particle Template设置为P_SoulXP;</p></li><li><p>打开BP_Player事件图表，创建自定义事件AddXP(XP);<img src='https://img-blog.csdnimg.cn/20201101174006324.png'></p></li><li><p>打开事件图表，设置物理模拟，添加TimeLine[MoveToPlayer],实现玩家击杀敌人后吸收经验的效果。创建自定义事件FinishCollect，调用自定义事件AddXP；<img src='https://img-blog.csdnimg.cn/20201101174735841.png'><img src='https://img-blog.csdnimg.cn/20201101174658471.png'></p></li></ol><h4 id="设置EnemyXP"><a href="#设置EnemyXP" class="headerlink" title="设置EnemyXP"></a>设置EnemyXP</h4><ol><li><p>打开BP_Enemy,打开函数SetNameAndLevel，创建变量XP_Points，扩展函数功能，可通过敌人和玩家的等级差设置XP_Points(默认为10)，具体为：</p><p>XP_Points = 10 + 2*(EnemyLevel-1) + MAX(0,EnemyLevel-PlayerLevel);<img src='https://img-blog.csdnimg.cn/20201101175450907.png'></p></li><li><p>接上，函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101175712965.png'></p></li><li><p>创建函数[Void]SpawnXPAndMoney(FirstIndex),用于经验球和金币的生成,并在自定义事件OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101180333637.png'><img src='https://img-blog.csdnimg.cn/2020110118043023.png'></p></li></ol><h3 id="获取金币"><a href="#获取金币" class="headerlink" title="获取金币"></a>获取金币</h3><h4 id="创建BP-SpawnMoney"><a href="#创建BP-SpawnMoney" class="headerlink" title="创建BP_SpawnMoney"></a>创建BP_SpawnMoney</h4><ol><li>复制BP_XP,重命名为BP_SpawnMoney，删除ParticleSystem，添加StaticMesh和RotatingMovement；</li><li>设置StaticMesh为SM_Coin_Small，编辑材质球，调整EmissiveColor,提高亮度;</li><li>修改自定义事件FinishCollect，调用玩家蓝图中的自定义事件GetMoney;<img src='https://img-blog.csdnimg.cn/20201101181026191.png'></li></ol><h4 id="设置EnemyMoney"><a href="#设置EnemyMoney" class="headerlink" title="设置EnemyMoney"></a>设置EnemyMoney</h4><ol><li><p>函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101181416558.png'></p></li><li><p>函数SpawnXPAndMoney中关于金币生成的部分，在OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101181603620.png'></p></li></ol><h2 id="重生Enemy"><a href="#重生Enemy" class="headerlink" title="重生Enemy"></a>重生Enemy</h2><ol><li>创建结构体S_RespawnEnemy;<img src='https://img-blog.csdnimg.cn/20201101182318659.png'></li><li>创建Actor[BP_SpawnEnemy]，添加组件SpehreCollison，碰撞预设为NoCollison;</li><li>打开事件图表，创建变量EnemyList(S_RespawnEnemy),SpawnTimer(TimerHandle),IndicesToSpawn(Integer[]);</li><li>创建自定义事件RespawnEnemy(S_RespawnEnemy)，将死亡的敌人记录到EnemtList中，并用SpawnTimer控制自定义事件RespawnTick的调用，IndicesToSpawn数组用于记录敌人重生的索引顺序；<img src='https://img-blog.csdnimg.cn/20201101184746163.png'><img src='https://img-blog.csdnimg.cn/20201101184831482.png'><img src='https://img-blog.csdnimg.cn/20201101184908545.png'></li><li>打开BP_Enemy，在OnDeath中调用RespawnEnemy;<img src='https://img-blog.csdnimg.cn/2020110118502269.png'></li><li>打开BehaviorComponent，修改函数SetBehavior，对传入的AI行为进行判断,若与当前的AI行为不同，则将传入的AI行为设置为当前行为；<img src='https://img-blog.csdnimg.cn/2020110118562015.png'></li><li>打开BTS_UpdateBehaviorTree，添加重载事件Recieve Tick AI；<img src='https://img-blog.csdnimg.cn/20201101185829997.png'></li><li>设置BP_Enemy,Auto Prossess AI = Placed in World or Spawned；</li><li>设置Enemy_Grunting，Auto Prossess AI = Placed in World or Spawned，并设置默认属性值，敌人等级的随机生成；<img src='https://img-blog.csdnimg.cn/20201101190150116.png'></li><li>将BP_SpawnSphere添加到场景，并指定场景中的Enemy的RespawnActor为BP_SpawnSphere;</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020110116105649.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：制作简单的粒子特效，获得经验金币，重生Enemy。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十一)</title>
    <link href="http://example.com/2020/10/27/RPG-Dev-Log-11/"/>
    <id>http://example.com/2020/10/27/RPG-Dev-Log-11/</id>
    <published>2020-10-27T10:21:00.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：战斗系统（续篇），AI设置，蒙太奇动画。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="蒙太奇动画"><a href="#蒙太奇动画" class="headerlink" title="蒙太奇动画"></a>蒙太奇动画</h2><h3 id="玩家被击蒙太奇"><a href="#玩家被击蒙太奇" class="headerlink" title="玩家被击蒙太奇"></a>玩家被击蒙太奇</h3><ol><li>添加ShinBi被攻击时的骨骼动画，创建Montage，将HitRect_Back、HitRect_Font、HitReact_Left、HitRect_Right分成4个section添加进来;<img src='https://img-blog.csdnimg.cn/20201027183226400.png'></li><li>打开BP_Shibi事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次角色被攻击时，随机播放4个section中的一个；<img src='https://img-blog.csdnimg.cn/20201027183642919.png'></li></ol><h3 id="敌人被击蒙太奇"><a href="#敌人被击蒙太奇" class="headerlink" title="敌人被击蒙太奇"></a>敌人被击蒙太奇</h3><ol><li>创建[AM_React_LightHit]蒙太奇，添加轻击时的骨骼动画，共2种,分成2个Section;<img src='https://img-blog.csdnimg.cn/20201027190551416.png'></li><li>创建[AM_React_HeavyHit]蒙太奇，添加两种重击时的骨骼动画，共2种Section,分成2个Section；<img src='https://img-blog.csdnimg.cn/20201027190633867.png'></li><li>打开BP_Enemy事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次敌人被攻击时，随机播放2个section中的一个，根据伤害是否暴击播放不同的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201027191532830.png'></li></ol><h3 id="敌人死亡蒙太奇"><a href="#敌人死亡蒙太奇" class="headerlink" title="敌人死亡蒙太奇"></a>敌人死亡蒙太奇</h3><ol><li>创建[AM_Death]蒙太奇，添加敌人死亡时的骨骼动画，共7种，分成7个Section；<img src='https://img-blog.csdnimg.cn/20201027191035160.png'></li><li>打开BP_Enemy事件图表，在OnDeath事件添加敌人死亡的随机蒙太奇动画播放，随机个数为7；<img src='https://img-blog.csdnimg.cn/20201027194633761.png'></li></ol><h2 id="战斗系统（续篇）"><a href="#战斗系统（续篇）" class="headerlink" title="战斗系统（续篇）"></a>战斗系统（续篇）</h2><h3 id="玩家相关"><a href="#玩家相关" class="headerlink" title="玩家相关"></a>玩家相关</h3><ol><li>打开BP_Shibi，添加自定义事件LineAttack，调用OnRecieveDamage事件，用于判定玩家是否成功命中敌人；<img src='https://img-blog.csdnimg.cn/20201027184947351.png'></li><li>打开三连攻击和空中攻击Montage动画，在PlaySound后添加AttackHit动画通知；在动画图表中调用BP_Shibi中的自定义事件LineAttack;<img src='https://img-blog.csdnimg.cn/20201027184701875.png'></li><li>修改函数[void]ModifyAttribute(Attribute,ModifyValue,Critical);</li><li>创建函数[void]UpdateLevel()，用于玩家升级后自身属性和技能点的更新；<img src='https://img-blog.csdnimg.cn/20201027213303392.png'></li><li>打开事件图表，修改自定义事件UpLevel，调用UpdateLevel()完成所有属性的更新；<img src='https://img-blog.csdnimg.cn/2020102721360097.png'></li><li>修改MeleeAttack（普通三连攻击）和Space Bar（二段跳)事件，实装耐力值消耗；</li><li>创建自定义事件CoolDownFighting和CountTime，用于玩家当前是否脱战的判定;<img src='https://img-blog.csdnimg.cn/20201027215037170.png'></li><li>精简Regeneration分类下的所有Tick事件的功能；</li></ol><h3 id="敌人相关"><a href="#敌人相关" class="headerlink" title="敌人相关"></a>敌人相关</h3><ol><li>打开E_Behavior，添加新的AI行为Death；</li><li>打开BP_Enemy，添加自定义事件ModifyValue(Boolean:Critical,Float:Damage),用于敌人攻击玩家时的伤害显示，并根据自身当前血量，设置Death或HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201027193429331.png'></li><li>添加OnRecieveDamage事件,接收来自玩家的伤害数据，调用事件ModifyValue,计算伤害并应用伤害;<img src='https://img-blog.csdnimg.cn/20201027193207452.png'></li><li>添加自定义事件OnDeath,用于敌人死亡时的动画播放和自身销毁（如果有武器，武器也销毁）；<img src='https://img-blog.csdnimg.cn/20201027223511642.png'></li><li>创建函数[Boolean] IsPlayingMontage()，用于判断当前是否已添加蒙太奇；<img src='https://img-blog.csdnimg.cn/2020102719201244.png'></li><li>创建函数[void]UpdateAttribute,用于不同等级的敌人的属性更新（在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/20201027195155263.png'></li><li>创建函数[void]SetNameAndLevel(Integer),此函数除了设置NameAndHealthBar的文本外，还可根据玩家和敌人的等级差，设置不同的文本颜色渐变(在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/2020102720012115.png'><img src='https://img-blog.csdnimg.cn/20201027200251916.png'></li><li>添加胶囊碰撞体ShowEnemyWidget，并添加BeginOverlap和EndOverlap事件，当玩家与敌人的胶囊体发生碰撞时，显示NameAndHealthBar，离开胶囊体区域时隐藏；<img src='https://img-blog.csdnimg.cn/20201027200721727.png'></li></ol><h2 id="AI设置"><a href="#AI设置" class="headerlink" title="AI设置"></a>AI设置</h2><h3 id="敌人攻击流畅度优化"><a href="#敌人攻击流畅度优化" class="headerlink" title="敌人攻击流畅度优化"></a>敌人攻击流畅度优化</h3><ol><li>为BTTask_Attack添加Decorator[CoolDown]，冷却时间设置为1s；</li><li>打开BTTask_Attack，新增蒙太奇动画检测，若敌人正在攻击则延迟播放；<img src='https://img-blog.csdnimg.cn/20201027192842439.png'></li></ol><h3 id="敌人死亡Sequence"><a href="#敌人死亡Sequence" class="headerlink" title="敌人死亡Sequence"></a>敌人死亡Sequence</h3><ol><li>创建BTTask_Death，调用BP_Enemy中的OnDeath事件；<img src='https://img-blog.csdnimg.cn/20201027194039645.png'></li><li>创建Sequence并添加Blackboard Decorator[EventDeath],设置BlackboardKey=Behavior,KeyValue=Death，序列执行顺序为:BTTask_Death—&gt;Wait(5)（then Loop);<img src='https://img-blog.csdnimg.cn/20201027194357652.png'></li></ol><h3 id="离开敌人仇恨范围后脱战"><a href="#离开敌人仇恨范围后脱战" class="headerlink" title="离开敌人仇恨范围后脱战"></a>离开敌人仇恨范围后脱战</h3><ol><li>打开E_Behavior，添加新的AI行为RunBack；</li><li>创建服务BTS_CheckOriginalDistance，用于判断玩家是否已经离开了敌人AI的仇恨范围，并执行RunBack行为；<img src='https://img-blog.csdnimg.cn/20201027220346975.png'></li><li>打开BB_Base，添加新的键值IsRunningBack?(Boolean)和RandomRange(Float);</li><li>将服务BTS_CheckOriginalDistance添加至Selector(HasSeenPlayer)，并添加Blackboard Decorator[IsNotRunningBack]至子节点sequence，设置BlackboardKey=IsRunningBack?;</li><li>打开BTTask_RandomLocation，将浮点型变量RandomRadius修改为BlackBoardKey类型，并在BP_Enemy BeginPlay中添加传值；</li><li>创建任务BTTask_Reset，用于判断敌人AI是否已经脱仇，并执行来自BP_Enemy的Reset事件；<img src='https://img-blog.csdnimg.cn/2020102722221863.png'><img src='https://img-blog.csdnimg.cn/20201027222301945.png'></li><li>创建Sequence并添加Blackboard Decorator[RunBack],设置BlackboardKey=Behavior,KeyValue=RunBack，序列执行顺序为:MoveTo(Original)—&gt;BTTask_Reset（then Loop);<img src='https://img-blog.csdnimg.cn/20201027222635974.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102813041126.gif'></p><p><img src='https://img-blog.csdnimg.cn/20201028130602858.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：战斗系统（续篇），AI设置，蒙太奇动画。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十)</title>
    <link href="http://example.com/2020/10/25/RPG-Dev-Log-10/"/>
    <id>http://example.com/2020/10/25/RPG-Dev-Log-10/</id>
    <published>2020-10-25T11:58:21.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建Enemy；创建战斗系统（开篇）。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[InfinityBlade:Adversaries]</p><p>虚幻商城[Action RPG]</p><p>虚幻商城[User Interface Kit]</p><h2 id="创建Enemy"><a href="#创建Enemy" class="headerlink" title="创建Enemy"></a>创建Enemy</h2><h3 id="创建敌人动画蓝图"><a href="#创建敌人动画蓝图" class="headerlink" title="创建敌人动画蓝图"></a>创建敌人动画蓝图</h3><ol><li><p>以BP_RPG_Character为父类，创建BP_Enemy;</p></li><li><p>将InfinityBlade:Adversaries资源[Enemy_Grunting]导入，创建动画蓝图ABP_Grunting和一维混合空间BS_Grunting_Skeleton_BlendSpace1D;</p></li><li><p>打开项目Action RPG,将骨骼动画Idle_Grunting导出为fbx文件，随后添加至ContentBrowser；</p></li><li><p>打开BS_Grunting_Skeleton_BlendSpace1D，设置水平坐标为Speed，最大水平值为400。将骨骼动画Idle、Walk_Slow、Walk、Run添加至适当坐标，并勾选Walk_Slow、Walk、Run的ForceFontXAxis选项；</p></li><li><p>打开ABP_Grunting，添加蓝图获取PawnOwner的Speed;</p></li><li><p>进入动画图表，新建状态机，添加Start&lt;=&gt;Locomotion状态及过渡规则（此处省略状态动画的相关蓝图设置）；<img src='https://img-blog.csdnimg.cn/20201025201901720.png'><img src='https://img-blog.csdnimg.cn/20201025202013508.png'></p></li></ol><h3 id="创建敌人蓝图"><a href="#创建敌人蓝图" class="headerlink" title="创建敌人蓝图"></a>创建敌人蓝图</h3><ol><li><p>以BP_Enemy为父类，创建蓝图Enemy_Grunting，添加骨骼和骨骼动画，调整碰撞胶囊体大小；</p></li><li><p>打开BP_Enemy，修改PaperSprite样式，添加组件Widget,命名为NameAndHealthBar，并添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201025203024776.png'></p></li></ol><h3 id="创建武器蓝图"><a href="#创建武器蓝图" class="headerlink" title="创建武器蓝图"></a>创建武器蓝图</h3><ol><li><p>创建BP_Weapon，添加组件Sphere、StaticMesh、SkeletalMesh、Capsule，设置相关参数；</p></li><li><p>以BP_Weapon为父类，创建Weapon_Grunting,添加Grunting武器模型，调整胶囊体和武器朝向；</p></li><li>打开Enemy_Grunting骨骼，添加Sockect[Weapon]至b_MF_Weapon_R,添加preview assets，设置预览动画，调整Socket位置;</li><li>打开事件图表，添加蓝图，将Weapon添加至敌人身上；<img src='https://img-blog.csdnimg.cn/20201025C204213703.png'></li></ol><h3 id="创建敌人名称血量UI"><a href="#创建敌人名称血量UI" class="headerlink" title="创建敌人名称血量UI"></a>创建敌人名称血量UI</h3><ol><li>创建Widget[W_Enemy]，层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201025204659690.png'></li><li>打开BP_Enemy，将W_Enemy添加至NameAndHealthBar，并调整其位置;</li><li>创建结构体S_EnemyAttribute，添加敌人血量上限、物理攻击/法术攻击、物理防御/法术防御等属性；<img src='https://img-blog.csdnimg.cn/20201025205105844.png'></li><li>打开BP_Enemy，创建函数[void] SetHealthPercent()，用于控制敌人血量百分比显示,在EventBegin添加调用；<img src='https://img-blog.csdnimg.cn/2020102520543750.png'></li></ol><h3 id="创建敌人AI行为——Random"><a href="#创建敌人AI行为——Random" class="headerlink" title="创建敌人AI行为——Random"></a>创建敌人AI行为——Random</h3><ol><li><p>打开E_Behaviors，添加AI行为枚举[Random]；</p></li><li><p>创建Componet[Behavior创建Componet],创建事件调度OnBehaviorChanged(E_Behaviors);</p></li><li><p>创建函数[void] SetBehavior(E_Behaviors),用于Call事件调度；<img src='https://img-blog.csdnimg.cn/20201025210057184.png'></p></li><li><p>将BehaviorComponet添加至BP_RPG_Character；</p></li><li><p>打开行为树BT_NPC，打开服务BTS_UpdateBehaviorTree，删除重载函数ReceiveTickAI，添加重载函数ReveiveSearchStartAI,创建自定义事件OnBehaviorChanged(E_Behaviors),调用宏SetBehavior;<img src='https://img-blog.csdnimg.cn/20201025211113194.png'></p></li><li><p>打开之前创建的BP_RPG_NPC_Warriors巡逻NPC，通过Behavior组件调用宏SetBehavior，实现AI行为改变；</p></li><li><p>打开BB_Base，添加Key[Originl]、[Random]、[Target];</p></li><li><p>创建Task[BTTask_RandomLocation],重载ReceiveExecuteAI事件，控制AI随机半径巡逻;<img src='https://img-blog.csdnimg.cn/20201025211959614.png'></p></li><li><p>打开行为树BT_NPC，创建Sequence并添加Blackboard Decorator[RandomLocation],序列执行顺序为:Wait（5)—&gt;BTTask_RandomLocation(SelfActor,Random,2000)—&gt;MoveTo(Random)（then Loop);<img src='https://img-blog.csdnimg.cn/20201026163507753.png'></p></li><li><p>打开BP_Enemy，初始化Blackboard的Original值为ActorLocation,设置AI行为为Random;<img src='https://img-blog.csdnimg.cn/20201025214715454.png'></p></li><li><p>设置AI Controller Class为AIC_Controller。</p></li></ol><h2 id="创建战斗系统（开篇）"><a href="#创建战斗系统（开篇）" class="headerlink" title="创建战斗系统（开篇）"></a>创建战斗系统（开篇）</h2><h3 id="创建敌人AI行为——HasSeenPlayer"><a href="#创建敌人AI行为——HasSeenPlayer" class="headerlink" title="创建敌人AI行为——HasSeenPlayer"></a>创建敌人AI行为——HasSeenPlayer</h3><ol><li><p>打开BP_Enemy，添加组件PawnSensing，设置视野半径和周边视野角度；<img src='https://img-blog.csdnimg.cn/20201026162705473.png'></p></li><li><p>打开BB_Base，添加key[Target]，类型为Actor;添加IsInAttackRange，类型为Boolean。打开E_Behavior，添加枚举HasSeenPlayer；</p></li><li><p>打开BP_Enemy事件图表，添加OnSeePawn(PawnSensing)事件，当Enemy感知Player时，加速靠近Player并执行HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201026163212433.png'></p></li><li><p>创建任务BTTask_Check，重载事件ReceiveExcuteAI，用于检测Player是否在AI视野范围内；<img src='https://img-blog.csdnimg.cn/2020102616394518.png'></p></li><li><p>创建任务BTTask_Attack，重载事件ReceiveExecuteAI,调用BP_Enemy的Attack事件。创建自定义事件FinalAttack，成功执行返回success；<img src='https://img-blog.csdnimg.cn/20201026164404943.png'></p></li></ol><h3 id="创建敌人攻击动画"><a href="#创建敌人攻击动画" class="headerlink" title="创建敌人攻击动画"></a>创建敌人攻击动画</h3><ol><li>将InfinityBlade:Adversaries资源[Enemy_Anim_Sword_Combat_Swing_Montage]导入，创建动画Montage;</li><li>打开ABP_Grunting，状态Locomotion添加DefaultSlot，使动画Montage生效；</li><li>打开BP_Enemy事件图表，创建自定义事件Attack,执行Attack蒙太奇动画，并调用BTTask_Attack中的自定义事件FinalAttack;<img src='https://img-blog.csdnimg.cn/20201026165559988.png'></li><li>打开行为树BT_NPC,创建Selector并添加Blackboard Decorator[HasSeenPlayer],设置BlackboardKey=Behavior,KeyValue=HasSeenPlayer；创建Sequence，序列执行顺序为BTTask_Check(Target,IsInAttackRange,AttackRange)——&gt;MoveTo(Target)[CheckAttackRange(Target)]——&gt;BTTask_Attack(then loop);<img src='https://img-blog.csdnimg.cn/20201026165758704.png'></li><li>创建AnimNotifyState[ANS_Weapon]，创建重载函数Reveived_NotifyBegin，Received_NotifyEnd，当敌人攻击角色时，临时关闭胶囊体碰撞；<img src='https://img-blog.csdnimg.cn/20201026174431299.png'></li></ol><h3 id="创建敌人攻击伤害显示"><a href="#创建敌人攻击伤害显示" class="headerlink" title="创建敌人攻击伤害显示"></a>创建敌人攻击伤害显示</h3><ol><li><p>创建蓝图接口I_Damageable,创建接口函数[void] OnRecieveDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage);</p></li><li><p>打开BP_Enemy，添加蓝图接口I_Damageable；</p></li><li><p>打开BP_RPG_Character，创建函数[Boolean:IsCritical?，Float:Damage] CalculateDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage,Float:PhysicalDefence，Float:MagicDefence，Boolean:AbsoluteDefence);</p></li><li><p>函数CalculateDamage用于综合敌人攻击属性和玩家防御属性，计算最终伤害，计算公式为：</p><p>Damage=</p><p>[</p><p>PhysicalDamage×random(0.9,1.1)-PhysicalDefence</p><p>+</p><p>MagicDamage×random(0.7,1.3)-MagicDefence</p><p>]</p><p>×</p><p>(IsCritical ?  1 :  CriticalDamage)；<img src='https://img-blog.csdnimg.cn/20201026171644771.png'></p></li><li><p>打开Enemy_Grunting，整合BeginPlay事件至父类BP_Enemy中的自定义事件CreateWeapon，并修改为在BP_Enemy中的BeginPlay事件中调用；<img src='https://img-blog.csdnimg.cn/20201026173117268.png'></p></li><li><p>打开BP_Shibi，添加OnRecieveDamage函数实现，调用CalculateDamage和ModifyAttribute(新的参数Critical,用于暴击判定，最终传入SetDamageText)，实现敌人伤害计算并应用于玩家的血量变更；<img src='https://img-blog.csdnimg.cn/20201026173731535.png'></p></li><li><p>打开BP_Weapon，添加事件ActorBeginOverlap，当敌人追上玩家时，传入敌人属性，调用OnRecieveDamage事件；<img src='https://img-blog.csdnimg.cn/20201026174639179.png'></p></li><li><p>打开W_DamageText，扩展UpdateValue函数功能，添加新的传入参数[Critical]，用于暴击伤害时伤害数字的特殊显示；<img src='https://img-blog.csdnimg.cn/20201026175016824.png'></p></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201026011936218.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建Enemy；创建战斗系统（开篇）。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(九)</title>
    <link href="http://example.com/2020/10/23/RPG-Dev-Log-9/"/>
    <id>http://example.com/2020/10/23/RPG-Dev-Log-9/</id>
    <published>2020-10-23T10:13:57.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：任务完成的互动，混合骨骼动画，普通攻击三连制作等；</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Infinity Blade:Adversaries]</p><p>虚幻商城[Infinity Blade:Effects]</p><h2 id="优化开箱互动"><a href="#优化开箱互动" class="headerlink" title="优化开箱互动"></a>优化开箱互动</h2><ol><li>打开Object_Treasure事件图表，创建TimeLine [MoveToPlayer]，创建Float Track，作为金币移动至人物身上的Alpha通道（类指数曲线）;<img src='https://img-blog.csdnimg.cn/20201023182304187.png'></li><li>扩展自定义事件Event On Interact With功能，实现金币被角色吸引——产生马里奥金币音效的效果；<img src='https://img-blog.csdnimg.cn/20201023182357341.png'></li></ol><h2 id="创建移动平台"><a href="#创建移动平台" class="headerlink" title="创建移动平台"></a>创建移动平台</h2><ol><li>创建Acotr [BP_MovePlane]，添加一个StaticMesh,添加SM_Env_Ice_Cliffs；</li><li>打开事件图表，创建TimeLine[Move]，创建Float Track，作为平台移动的Alpha通道（类正弦曲线）,勾选Loop模式；<img src='https://img-blog.csdnimg.cn/20201023183342627.png'></li><li>在Event BeginPlay实现平台相对于自身的偏移移动；<img src='https://img-blog.csdnimg.cn/20201023183559104.png'></li></ol><h2 id="任务完成的互动"><a href="#任务完成的互动" class="headerlink" title="任务完成的互动"></a>任务完成的互动</h2><ol><li><p>打开S_SubGoalInfo，添加成员HasFollowingIndex?(Boolean);</p></li><li><p>打开W_SubGoal，创建函数DisableButton，用于SelectButton按钮的disable,Done图标和SubGoalText文本的高亮显示；<img src='https://img-blog.csdnimg.cn/20201023184922881.png'></p></li><li><p>打开W_Quest,创建宏AnimateSubGoalWidget(Exec，Boolean)，将宏PlayHideAll中有关SubGoal的显示动画（Show/Text）整合进来，并扩展功能，使其在Quest完成时播放隐藏动画；<img src='https://img-blog.csdnimg.cn/20201023190840946.png'><img src='https://img-blog.csdnimg.cn/20201023190652645.png'></p></li><li><p>打开EvenGraph，添加自定义事件PlaySubGoal(Boolean)，调用宏AnimateSubGoalWidget(Boolean)，修改自定义事件PlayQuest()为PlayQuest(Boolean)，调用宏PlayHideAll(Boolean);<img src='https://img-blog.csdnimg.cn/20201023191105631.png'></p></li><li><p>打开函数GenerateSubGoal，当SubGoal循环添加完成时,调用自定义事件PlaySubGoal，播放相关动画；</p></li><li><p>打开BP_MasterQuest，创建自定义事件UpdateCompleteSubGoal,创建变量CompletedSubGoalsInfo(S_SubGoalInfo)、CompletedSubGoalIndex(Integer),用于记录已完成的SubGoal信息和索引。当所有<strong>已显示</strong>的SubGoal都被标记为完成时，执行PlaySubGoal(false)动画，并判断是否仍有FollowingIndex。若有，则延迟1.5s后调用函数GenrateSubGoal和SelectSubGoal，再生SubGoal；<img src='https://img-blog.csdnimg.cn/20201023193814396.png'></p></li><li><p>创建函数CompletedSubGoal(Integer)，用于记录已完成的SubGoal信息和索引更新，并同步UI更新（调用函数DisableButton和自定义事件UpdateCompleteSubGoal)；<img src='https://img-blog.csdnimg.cn/20201023194332860.png'><img src='https://img-blog.csdnimg.cn/20201023194354363.png'></p></li><li><p>复制一份BP_FirstQuest，命名为BP_FirstQuestTest，修改index=3的SubGoal,勾选HasFollowingIndex?,添加FollowingSubGoalIndices;<img src='https://img-blog.csdnimg.cn/20201023195017556.png'></p></li><li><p>打开BP_Shibi事件图表，创建J键盘事件，测试任务完成时的互动效果；<img src='https://img-blog.csdnimg.cn/20201023194602440.png'></p></li></ol><h2 id="普通攻击三连制作"><a href="#普通攻击三连制作" class="headerlink" title="普通攻击三连制作"></a>普通攻击三连制作</h2><ol><li>导入Shibi角色MeleeAttack动画（Air/B/C/D)，创建Montage，命名为Air_Melee、Melee_B、Melee_C、Melee_D；</li><li>导入Shibi角色Attack音效（1/2/3/4）,创建Cue，命名为Shinbi_Effect_Attack，编辑蓝图实现4种攻击音效随机播放的效果；<img src='https://img-blog.csdnimg.cn/20201024173918860.png'></li><li>打开Montage[Air_Melee],添加Notify [Play Sound]、Skeleton Notify [Reset]；<img src='https://img-blog.csdnimg.cn/2020102417450352.png'></li><li>打开Montage[Melee_B],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174714903.png'></li><li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174753486.png'></li><li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174837728.png'></li><li>打开BP_Shibi，创建自定义事件MeleeAttack、SaveAttack、ResetComb;</li><li>打开ABP_Shibi事件图表，AnimNotify_Save调用SaveAttack事件，AnimNotify_Reset调用ResetComb事件；<img src='https://img-blog.csdnimg.cn/20201024175438930.png'></li><li>返回BP_Shibi，完成自定义事件MeleeAttack、SaveAttack、ResetComb，SavaAttack用于记录当前普通攻击归属第几段，当角色停止普通攻击时，ResetComb将初始化Attack信息;<img src='https://img-blog.csdnimg.cn/20201024175625435.png'></li><li>创建Q键盘事件，关联普通攻击，调用MeleeAttack事件，并根据角色是否滞空播放相应的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201024175856577.png'></li></ol><h2 id="混合骨骼动画"><a href="#混合骨骼动画" class="headerlink" title="混合骨骼动画"></a>混合骨骼动画</h2><ol><li><p>打开ABP_Shibi事件图表，完善动画更新事件，判断角色是否处于加速状态或FullBody状态；<img src='https://img-blog.csdnimg.cn/20201024180437185.png'></p></li><li><p>打开ABP_Shibi动画图表，添加按骨骼分层混合，以及按布尔值混合姿势。当角色处于加速状态并且Body Curve返回值为0时，输出按骨骼分层混合姿势，否则输出UpBody姿势；<img src='https://img-blog.csdnimg.cn/20201024181347328.png'></p><p><img src='https://img-blog.csdnimg.cn/20201024180639713.png'></p></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102417301295.gif'></p><p><img src='https://img-blog.csdnimg.cn/20201024173043229.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：任务完成的互动，混合骨骼动画，普通攻击三连制作等；&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(八)</title>
    <link href="http://example.com/2020/10/21/RPG-Dev-Log-8/"/>
    <id>http://example.com/2020/10/21/RPG-Dev-Log-8/</id>
    <published>2020-10-21T08:47:22.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：任务坐标，Money互动等;</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Content Examples]</p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：脚印、钱包]</p><h2 id="创建搜寻目标"><a href="#创建搜寻目标" class="headerlink" title="创建搜寻目标"></a>创建搜寻目标</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>创建Interface [I_Interaction],添加函数BeginOverlapTargetObject、EndOverlapTargetObject、OnInteractWith(Char_Shibi);</p></li><li><p>创建Actor [BP_TargetObject]，添加组件StaticMesh、Widget、PaperSprite，并在事件开始时隐藏PaperSprite;</p></li><li><p>将I_Interaction蓝图接口添加至BP_TargetObject;</p></li><li><p>打开S_SubGoalInfo，添加属性TargetClass(Actor)、TargetClassID(Integer);</p></li><li><p>打开Char_Shibi,添加Box碰撞体，并添加碰撞事件，调用I_Interaction接口函数；<img src='https://img-blog.csdnimg.cn/20201021171021322.png'></p></li><li><p>为E键盘事件扩展功能，使其借助蓝图接口实现互动；<img src='https://img-blog.csdnimg.cn/20201021171350706.png'></p></li><li><p>重命名W_NameForNPC为W_Interaction，并添加到BP_TargetObject的Widget上，在事件开始运行时设置W_Interaction的Name和Interact的文本；<img src='https://img-blog.csdnimg.cn/20201021171832273.png'></p></li><li><p>打开BP_TargetObject事件蓝图，实现蓝图接口中三个接口函数;<img src='https://img-blog.csdnimg.cn/20201021172214999.png'></p></li></ol><h3 id="创建目标实例-藏宝箱"><a href="#创建目标实例-藏宝箱" class="headerlink" title="创建目标实例(藏宝箱)"></a>创建目标实例(藏宝箱)</h3><ol><li>以BP_TargetObject为父类，创建子类Object_Treasure；</li><li>将[Content Examples]资源包中的StaticMesh [SM_Chest_Bottom、SM_Chest_Lid、SM_Coin_Small]添加进来，调整Transform;</li><li>实现蓝图接口I_Interaction中的接口函数OnInteractWith，使用TimeLine实现宝箱打开、金币弹出并旋转的交互动画;<img src='https://img-blog.csdnimg.cn/20201021173246323.png'><img src='https://img-blog.csdnimg.cn/20201021173324992.png'></li></ol><h3 id="创建目标小地图指示"><a href="#创建目标小地图指示" class="headerlink" title="创建目标小地图指示"></a>创建目标小地图指示</h3><ol><li><p>打开W_MiniMap，扩展Widget显示内容，注意<strong>TargetDirection</strong>属性<strong>Pivot</strong>的设置，需要根据Angle作调整,使其无论如何旋转，都能正确显示位置，层级面板作如下修改<img src='https://img-blog.csdnimg.cn/20201021173858989.png'>预览效果<img src='https://img-blog.csdnimg.cn/20201021174021728.png'></p></li><li><p>打开QuestManager，创建纯函数[void] DistanceToTarget(Integer),用于计算角色到目标的空间距离；<img src='https://img-blog.csdnimg.cn/20201021174336258.png'></p></li><li><p>创建函数[void] UpdateTargetDirection()，用于更新目标相对于角色的所在方位；<img src='https://img-blog.csdnimg.cn/2020102117461731.png'></p></li><li><p>打开函数AddQuest,在末尾设置CurrentQuest=LocalQuest;</p></li><li><p>创建自定义事件OnSwitchSubGoalInfo，用于点击子任务列表时，根据当前选择的子任务（是否为Search任务），显示和隐藏目标距离和方位；<img src='https://img-blog.csdnimg.cn/20201021175129176.png'><img src='https://img-blog.csdnimg.cn/20201021175154953.png'></p></li><li><p>创建自定义事件OnPlayerMove，用于角色移动时更新搜寻目标距离和方位信息；<img src='https://img-blog.csdnimg.cn/202010211755540.png'></p></li><li><p>打开RPG_PlayerController，在移动事件末尾添加OnPlayerMove事件的调用；</p></li></ol><h2 id="Money互动"><a href="#Money互动" class="headerlink" title="Money互动"></a>Money互动</h2><ol><li>打开W_CharacterBorder，添加一个Horizatal Box，添加Money图标和文本；</li><li>打开Char_Shibi，创建函数[void]CountMoney()，用于更新Money文本；<img src='https://img-blog.csdnimg.cn/20201021213916456.png'></li><li>创建自定义事件[void] GetMoney(Integer)，使用TimerHandle控制CountMoney函数的循环调用；<img src='https://img-blog.csdnimg.cn/20201021214258222.png'></li><li>打开Object_Treasure事件图表，在Event OnInteractWith末尾添加GetMoney事件的调用，可实现宝箱打开金币旋转动画结束后，自动增加Money的值；</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201021165022723.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：任务坐标，Money互动等;&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(七)</title>
    <link href="http://example.com/2020/10/20/RPG-Dev-Log-7/"/>
    <id>http://example.com/2020/10/20/RPG-Dev-Log-7/</id>
    <published>2020-10-20T13:19:37.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：AI初讲，BehaviorTree—Patrol等;</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="角色边界跳跃"><a href="#角色边界跳跃" class="headerlink" title="角色边界跳跃"></a>角色边界跳跃</h2><ol><li>在场景中添加NavLinkProxy，设置PointLink[0].Left和PointLinks[0].Right在场景中的位置；</li><li>打开细节面板，按照实际情况将Simple Link和Smart Link Direction都设置为Right to Left，将Area Class都设置为NavArea_Default;<img src='https://img-blog.csdnimg.cn/20201020213951911.png'></li></ol><h2 id="AI行为树初讲"><a href="#AI行为树初讲" class="headerlink" title="AI行为树初讲"></a>AI行为树初讲</h2><h3 id="PatrolPath"><a href="#PatrolPath" class="headerlink" title="PatrolPath"></a>PatrolPath</h3><ol><li>清除场景中的所有Block Volume;</li><li>创建Actor [BP_PatrolPath],添加组件Scene、Billboard、Spine;</li><li>进入事件图表，创建变量CloseLoop（Boolean),在构造函数中设置ClosedLoop;<img src='https://img-blog.csdnimg.cn/20201020215735408.png'></li><li>CloseLoop可用于设置AI巡逻路线是否闭环；<img src='https://img-blog.csdnimg.cn/20201020220053700.png'></li><li>在场景中添加BP_PatrolPath，并自定义路线；<img src='https://img-blog.csdnimg.cn/20201020220243597.png'></li></ol><h3 id="PatrolComponent"><a href="#PatrolComponent" class="headerlink" title="PatrolComponent"></a>PatrolComponent</h3><ol><li>创建Component [PatrolComponent],添加变量PatrolPath(BP_PatrolPath)、PatrolIndex(Integer)、RevereDirection(Boolean);</li><li>创建纯函数[Vector] GetSpinePointLocation(Integer)，用于获取巡逻路线各个节点在世界坐标系中的位置；<img src='https://img-blog.csdnimg.cn/20201020220912376.png'></li><li>创建函数[void] UpdatePatrolIndex()，用于实时更新PatrolIndex；当ColoseLoop=true时，实现闭环寻路；当CloseLoop=false时，实现来回寻路；<img src='https://img-blog.csdnimg.cn/20201020221021193.png'></li><li>为BP_RPG_Character添加组件PatrolComponent;</li><li>点击场景中的巡逻NPC，将场景中的PatrolPath指定给NPC;</li></ol><h3 id="BehaviorTree—Patrol"><a href="#BehaviorTree—Patrol" class="headerlink" title="BehaviorTree—Patrol"></a>BehaviorTree—Patrol</h3><ol><li><p>创建Enum [Behaviors] = {Idle,Patrol,Hit,Ability};</p></li><li><p>创建BehaviorTree [BT_NPC]；</p></li><li><p>创建BlackBoard [BB_Base],新建Keys [Behaviors],类型为Enum Behaviors;</p></li><li><p>新建Service [BTS_UpdateBehaviorTree],添加变量BehaviorKey(Blackboard Key),添加宏[Exec] SetBehavior(Behaviors,Exec),将BehaviorKey设置为枚举值；<img src='https://img-blog.csdnimg.cn/20201020222511510.png'></p></li><li><p>在Event Receive Tick AI中调用SetBehavior，选择枚举类型为Patrol;<img src='https://img-blog.csdnimg.cn/20201020222734181.png'></p></li><li><p>新建Task [BTTask_Patrol],添加事件Event Receive Execute AI和Event Receive Abort AI,用于AI行为的执行和中断；<img src='https://img-blog.csdnimg.cn/20201020223107766.png'></p></li><li><p>打开BT_NPC，建立Root——Selector(Service)——Sequence(Decorator)——Leaf(Task);</p><blockquote><p>行为树节点</p><p>一、Composite组合节点：</p><p>1、Selector</p><p>　　要求比较低：只要有一个子节点成功就可以了。</p><p>　　只要子节点有一个返回true，则停止执行其它子节点，并且Selector返回true。如果所有子节点都返回false，则Selector返回false。</p><p>2、Sequence</p><p>　　要求比较高：期望所有子节点都成功。</p><p>　　只要有一个子节点返回false，则停止执行其它子节点，并且Sequence返回false。如果所有子节点都返回true，则Sequence返回true。</p><p>二、Task叶子：</p><p>　　实际执行操作，不含输出链接。</p><p>三、Decorator装饰节点</p><p>　　依附于其它节点，条件节点：如果返回true则执行位于“Decorator”下面的节点，否则就不执行。</p><p>四、Services服务节点</p><p>　　只能附加在Composite组合节点上，只要其附加的节点被执行，Services节点就会被执行，通常用来检查和更新黑板。</p></blockquote><p><img src='https://img-blog.csdnimg.cn/20201020223938437.png'></p></li><li><p>选取父类AIController，创建蓝图AIC_NPCController,进入蓝图，在EventBeginPlay添加BlackBoard [BB_Base]和BehaviorTree [BT_NPC];<img src='https://img-blog.csdnimg.cn/20201020214613446.png'></p></li><li><p>选择场景中的NPC，设置</p><p>Animation Mode=Use Animaion Blueprint;</p><p>Pawn&gt;Auto Possess AI = Placed in World or Spawned,AI Controller Class = AIC_NPCController;</p></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102021303566.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：AI初讲，BehaviorTree—Patrol等;&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(六)</title>
    <link href="http://example.com/2020/10/20/RPG-Dev-Log-6/"/>
    <id>http://example.com/2020/10/20/RPG-Dev-Log-6/</id>
    <published>2020-10-20T05:33:47.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建NPC，骨骼重定向，任务互动发放等；</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Generic NPC Anim Pack]</p><p>虚幻商城[Infinity Blade:Warriors]</p><p>虚幻商城[Advanced Locomotion System]</p><p>内置Package[Mannequin]添加组件S</p><p>Adobe官网<a href="https://www.mixamo.com/">Mixamo</a></p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：圆、问号]</p><h2 id="创建NPC"><a href="#创建NPC" class="headerlink" title="创建NPC"></a>创建NPC</h2><ol><li>打开BP_RPG_Character，删除组件MapArm及其附属组件ChildActor;</li><li>以BP_RPG_Character为父类，创建蓝图BP_RPG_NPC;</li><li>下载地图指示图标，右键Apply Paper2D Texture Settings,并Create Sprite。将圆形图标添加到NPC的PaperSprite；</li><li>为BP_RPG_NPC添加组件SpringArm及其附属组件ChildActor,ChildActor Class选取MiniCapture;</li><li>打开PaperSprite，取消勾选Owner No See。并打开事件图表，添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201020140456848.png'></li><li>以BP_RPG_NPC为父类，创建蓝图BP_NPC_Warriors,将SK_CharM_Pit导入进来；</li></ol><h2 id="NPC骨骼重定向"><a href="#NPC骨骼重定向" class="headerlink" title="NPC骨骼重定向"></a>NPC骨骼重定向</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ol><li>打开SK_CharM_Pit的Retarget Manager,在SetupRig项目选择引擎默认的Humanoid人形骨骼；</li><li>点击AutoMap，自动匹配和建立骨骼映射，ShowBase/ShowAdvanced可用于查看基本骨骼和精细骨骼映射关系；</li><li>打开UE4_Mannequin_Skeleton，同样选取rig为Humanoid人形骨骼，自动建立骨骼映射，在ManageRetargetSource项目Add重定向源SK_Mannequin;</li><li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为SK_Mannequin_Skeleton，并确保base pose一致（Here is Apos)；<img src='https://img-blog.csdnimg.cn/20201020143635944.png'></li><li>将重定向后生成的动画添加至NPC蓝图即可；</li></ol><h3 id="进阶篇（Mixamo"><a href="#进阶篇（Mixamo" class="headerlink" title="进阶篇（Mixamo)"></a>进阶篇（Mixamo)</h3><ol><li>进入虚幻商城[Advanced Locomotion System]，可下载Tpos模型[ALS_Mannequin_T_Pose]；</li><li>打开ALS_Mannequin_T_Pose，选取CurrentPose创建PoseAssets[UE4_PoseAsset];</li><li>打开Apos的小白人骨骼模型，在Manage Retarget Base Pose项目，点击Modify,选择UE4_PoseAsset为当前pose,并import进来；</li><li>打开Mixamo官网下载的模型，手动建立骨骼映射；</li><li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为maria_j_j_ong_Skeleton，并确保base pose一致（Here is Tpos)；<img src='https://img-blog.csdnimg.cn/20201020150458513.png'></li></ol><h2 id="任务互动发放"><a href="#任务互动发放" class="headerlink" title="任务互动发放"></a>任务互动发放</h2><ol><li><p>创建Widget[W_NameForNPC]，</p><p>层级面板<img src='https://img-blog.csdnimg.cn/2020102015102250.png'>,</p><p>预览效果<img src='https://img-blog.csdnimg.cn/20201020151116574.png'></p></li><li><p>打开父类BP_RPG_Character，添加组件Widget，并在子类BP_RPG_NPC中添加Widget Class为W_NameForNPC，设置Space=Screen;</p></li><li><p>添加Sphere碰撞组件，设置碰撞预设;<img src='https://img-blog.csdnimg.cn/20201020151809375.png'></p></li><li><p>添加NPC互动效果蓝图 <img src='https://img-blog.csdnimg.cn/20201020152018538.png'></p></li><li>打开Char_Shibi,创建事件调度OnInteract，将与E键盘事件关联；</li><li>打开BP_RPG_NPC,创建自定义事件OnInteract，用于判断角色与NPC交互时，NPC身上是否有未分发的任务<img src='https://img-blog.csdnimg.cn/20201020152724167.png'></li><li>打开Char_Shibi，创建事件调度UpdateLevelForQuest(Integer),在UpLevel之后调用；</li><li>打开BP_RPG_NPC,创建变量QuestInLevel(Map)，将Level映射到Quest类。创建自定义事件UpdateQuest(Integer),用于在角色升级后，判断NPC身上是否产生新的任务；<img src='https://img-blog.csdnimg.cn/20201020153139435.png'></li><li>复制BP_MasterQuest两份，命名为BP_FirstEventQuest和BP_FirstSideQuest，并修改任务信息；</li></ol><h2 id="UI动画添加"><a href="#UI动画添加" class="headerlink" title="UI动画添加"></a>UI动画添加</h2><ol><li>打开W_Quest，为Border创建HideAll动画；<img src='https://img-blog.csdnimg.cn/20201020154300252.png'></li><li>为Text创建Text动画；<img src='https://img-blog.csdnimg.cn/20201020154331675.png'></li><li>打开W_SubGoal，为Border创建Show动画；<img src='https://img-blog.csdnimg.cn/20201020154514839.png'></li><li>打开W_Quest事件蓝图，添加宏[Exec] PlayHideAll(Exec,Boolean)，组织和关联HideAll、Text、Show动画执行时机<img src='https://img-blog.csdnimg.cn/20201020154615593.png'></li><li>创建自定义事件PlayQuest调用PlayHideAll，并在UpdateQuest末尾添加调用;</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201020134241578.gif'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建NPC，骨骼重定向，任务互动发放等；&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(五)</title>
    <link href="http://example.com/2020/10/18/RPG-Dev-Log-5/"/>
    <id>http://example.com/2020/10/18/RPG-Dev-Log-5/</id>
    <published>2020-10-18T04:23:00.000Z</published>
    <updated>2020-11-27T18:30:35.953Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：跳跃动作制作，创建任务系统（开篇）</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>虚幻商城[Advanced Mission And Notification System]</p><h2 id="跳跃动作制作"><a href="#跳跃动作制作" class="headerlink" title="跳跃动作制作"></a>跳跃动作制作</h2><ol><li>打开ABP_Shibi事件图表，将Is Falling返回值保存至变量IsInAir;</li><li>进入状态机，添加Idle_Move&lt;=&gt;Jump状态过渡，并将过渡规则与IsInAir关联；</li><li>进入Jump状态，新建状态机Jump，点击进入，设置Entry-&gt;JumpStart=&gt;Loop=&gt;JumpEnd状态过渡，并将过渡规则设置为自动；</li><li>为JumpStart、Loop、JumpEnd添加Jump_Start、Jump_Apex、Jump_Land,并调整播放速率；</li><li>打开Char_Shibi事件图表，添加Space Bar键盘事件，使得角色获得二段跳能力；<img src='https://img-blog.csdnimg.cn/20201018130500837.png'></li><li>打开CharacterMovement细节面板，设置Character Movement:Jump/Falling，Jump Z Velocity=620，Air Control=0.5;</li></ol><h2 id="创建任务系统（开篇）"><a href="#创建任务系统（开篇）" class="headerlink" title="创建任务系统（开篇）"></a>创建任务系统（开篇）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建枚举E_QuestCategories = {主线任务，支线任务，副本任务}；</li><li>创建枚举E_Regions = {冰岛，洞穴，香格里拉}；</li><li>创建枚举E_SubGoalType = {Custom,Hunt,Search,Talk};</li><li>创建结构体S_QuestReward = {Money(Integer),Experience(Integer),Prestige(Integer)};</li><li>创建结构体S_TargetLocation = {HasLocation?(Boolean),Location(Vector)};</li><li>创建结构体S_SubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018132339967.png'></li><li>创建结构体S_QuestInfo;<img src='https://img-blog.csdnimg.cn/20201018132440276.png'></li></ol><h3 id="创建任务实例的父类"><a href="#创建任务实例的父类" class="headerlink" title="创建任务实例的父类"></a>创建任务实例的父类</h3><h4 id="变量创建"><a href="#变量创建" class="headerlink" title="变量创建"></a>变量创建</h4><ol><li>创建Actor BP_MasterQuest,作为创建任务实例的父类；</li><li>创建变量QuestInfo(S_QuestInfo)，用于记录所有<strong>Quest</strong>信息；</li><li>创建变量StartSubGoalIndices(Integer [])，用于记录开始<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li><li>创建变量CurrentSubGoalIndices(Integer [])，用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li><li>创建变量CurrentHuntedAmount(Integer[])，用于记录当前猎杀数量；</li><li>创建变量CurrentSubGoalInfo(S_SubGoalInfo []),用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>信息；</li><li>创建变量SelectedSubGoalIndex(Integer)，用于记录当前选择的<strong>SubGoal</strong>索引；</li></ol><h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><ol><li>创建函数void UpdateSubGoalInfo(),用于根据CurrentSubGoalIndices，更新CurrentSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201018135432102.png'></li><li>创建函数void SetopStartingSubGoals()，用于设置CurrentSubGoalIndices,并调用UpdateSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018135750624.png'></li><li>创建函数Boolean GoToNextSubGoal()，用于判断当前Quest是否还有SubGoal，若有，则将NextIndex保存至CurrentSubGoalIndices，并返回true;<img src='https://img-blog.csdnimg.cn/20201018140354801.png'></li></ol><h3 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h3><h4 id="创建W-SubGoal"><a href="#创建W-SubGoal" class="headerlink" title="创建W_SubGoal"></a>创建W_SubGoal</h4><ol><li><p>创建Widget [W_SubGoal],</p><p>层级面板如下<img src='https://img-blog.csdnimg.cn/20201018141429316.png'>,</p><p>最终效果<img src='https://img-blog.csdnimg.cn/20201018141521486.png'>;</p></li><li><p>打开事件图表</p><p><strong>创建变量</strong></p><p>W_Quest_SubGoalInfo(S_SubGoalInfo)，</p><p>W_Quest_AssignedQuest(BP_MasterQuest),</p><p>W_Quest(W_Quest),</p><p>SubGoalIndex(Integer),</p><p>SubGoalInfo(Text);</p><p><strong>创建函数</strong></p><p>void Update(),用于根据W_Quest_SubGoalInfo从W_Quest_AssignedQuest中获取QuestInfo，并更新Text;<img src='https://img-blog.csdnimg.cn/20201018143047970.png'></p><p><strong>函数调用</strong></p><p>事件开始构造时调用Update()，点击SelectedButton时调用W_Quest中的SelectSubGoal()；</p></li></ol><h4 id="创建W-Quest"><a href="#创建W-Quest" class="headerlink" title="创建W_Quest"></a>创建W_Quest</h4><ol><li><p>创建Widget [W_Quest]，</p><p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201018144005433.png'></p><p>最终效果<img src='https://img-blog.csdnimg.cn/20201018144100772.png'>;</p></li><li><p>打开事件图表</p><p><strong>创建变量</strong></p><p>SubGoalWidgets(W_SubGoal),</p><p>AssignedQuest(BP_MasterQuest),</p><p>SelectedSubGoal(W_SubGoal);</p><p><strong>创建函数</strong></p><ol><li><p>void GenerateSubGoal(),用于清空SubGolaVerticalBox，并从AssignedQuest中获取CurrentSubGoalInfo,循环添加至SubGolaVerticalBox;<img src='https://img-blog.csdnimg.cn/20201018145035536.png'></p></li><li><p>void UpdateCurrentSubGoal(),用于更新SubGoalIcon、SubGoalType、SubGoalInfo等控件信息；<img src='https://img-blog.csdnimg.cn/20201018152129831.png'></p></li><li><p>void SelectSubGoal(W_SubGoal)，用于激活SelectedButton,并调用UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/202010181515354.png'></p></li><li><p>void UpdateQuest(Quest),用于从AssignedQuest中获取CurrentSubGoalInfo，根据任务Categories设置文本和任务图标样式，并调用GenerateSubGoal和UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/20201018151930868.png'></p></li></ol></li></ol><h3 id="创建QuestManager"><a href="#创建QuestManager" class="headerlink" title="创建QuestManager"></a>创建QuestManager</h3><ol><li><p>创建Actor Componet [QuestManager]，并添加至Char_Shibi;</p></li><li><p>创建变量</p><p>CurrentQuest(BP_MasterQuest),</p><p>AllQuests(BP_MasterQuest[] Object reference),</p><p>AllQuestClasses(BP_MasterQuest[] class reference),</p><p>Shibi(Char_Shibi);</p></li><li><p>创建函数void AddQuest(BP_MasterQuest),用于从所有Quest class中添加、生成Quest Actor实例,并调用BP_MasterQuest.SetupStartingSubGoals和W_Quest.UpdateQuest;<img src='https://img-blog.csdnimg.cn/20201018153733195.png'></p></li></ol><h3 id="绑定Q键盘事件"><a href="#绑定Q键盘事件" class="headerlink" title="绑定Q键盘事件"></a>绑定Q键盘事件</h3><p><img src='https://img-blog.csdnimg.cn/20201018154325823.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201018123029836.png'></p><p><img src='https://img-blog.csdnimg.cn/20201018123051461.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：跳跃动作制作，创建任务系统（开篇）&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
</feed>
