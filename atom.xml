<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>unreal-engine-channel</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-16T09:52:18.353Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jocoboy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RPG Game开发日志(十八)</title>
    <link href="http://example.com/2020/11/16/RPG-Dev-Log-18/"/>
    <id>http://example.com/2020/11/16/RPG-Dev-Log-18/</id>
    <published>2020-11-16T07:24:17.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：脚部IK制作。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="脚部IK制作"><a href="#脚部IK制作" class="headerlink" title="脚部IK制作"></a>脚部IK制作</h2><h3 id="事件图表"><a href="#事件图表" class="headerlink" title="事件图表"></a>事件图表</h3><h4 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h4><ol><li><p>创建宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Start(Vector),End(Vector)]TraceStart&#x2F;End(X(Float),Y(Float),Z(Float))</span><br></pre></td></tr></table></figure><p>用于计算射线检测的起点和终点位置;<img src='https://img-blog.csdnimg.cn/20201116155309202.png'></p></li><li><p>创建宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ClampedOffset(Vector)]ClampOffset(Roll(Float),Pitch(Float),Z(Float))</span><br></pre></td></tr></table></figure><p>用于限制X,Y,Z轴的偏移距离；<img src='https://img-blog.csdnimg.cn/20201116161451526.png'></p></li><li><p>创建宏</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Return(Vector)]InterpOffsets(Current(Vector),Target(Vector))</span><br></pre></td></tr></table></figure><p>用于从Current到Target插值计算X,Y,Z轴偏移量;<img src='https://img-blog.csdnimg.cn/20201116164750110.png'></p><blockquote><p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/Vector2DInterpTo/index.html">Vector2DInterpTo</a></strong></p><p>Interpolate vector2D from Current to Target.</p><p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/FInterpTo/index.html">FInterpTo</a></strong></p><p>Interpolate float from Current to Target.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CORE_API <span class="keyword">float</span> <span class="title">FMath::FInterpTo</span><span class="params">( <span class="keyword">float</span> Current, <span class="keyword">float</span> Target, <span class="keyword">float</span> DeltaTime, <span class="keyword">float</span> InterpSpeed )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If no interp speed, jump to target value</span></span><br><span class="line">    <span class="keyword">if</span>( InterpSpeed &lt;= <span class="number">0.f</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distance to reach</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> Dist = Target - Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If distance is too small, just set the desired location</span></span><br><span class="line">    <span class="keyword">if</span>( FMath::Square(Dist) &lt; SMALL_NUMBER )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delta Move, Clamp so we do not over shoot.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> DeltaMove = Dist * FMath::Clamp&lt;<span class="keyword">float</span>&gt;(DeltaTime * InterpSpeed, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Current + DeltaMove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ol><li><p>折叠函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OutHit_bBlockingHit(Boolean),ClampedOffset(Vector)]TraceFootIK(A_Z(Float),B_X(Float),B_Y(Float))</span><br></pre></td></tr></table></figure><blockquote><p><strong><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/Collision/LineTraceByChannel/index.html">LineTraceByChannel</a></strong></p><p>Does a collision trace along the given line and returns the first blocking hit encountered. This trace finds the objects that RESPONDS to the given TraceChannel</p></blockquote><p>调用宏TraceStart/End和函数LineTraceByChannel，计算脚部Roll,Pitch轴的Rotation偏移量和Z轴偏移量，并调用宏ClampOffset，限制偏移范围。具体计算方式为：</p><p>Roll = arctan(OutHitNormal.y/OutHitNormal.z)</p><p>Pitch = arctan(OutHitNormal.x/OutHitNormal.z)</p><p>z = WorldLoaction.z - OutHitLocation.z；<img src='https://img-blog.csdnimg.cn/20201116163019606.png'></p></li><li><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[void]FootIK()</span><br></pre></td></tr></table></figure><p>脚部IK数值计算汇总（此函数在EventBlueprintUpdateAnimation中调用）：当角色不在跳跃状态时，获取foot_l和foot_r的骨骼位置，调用函数TraceFootIK，根据Hit布尔值设置LeftFootOffsetsTarget的值(ClampedOffset or Zero)。循环调用宏InterpOffsets实现脚部偏移过渡效果，并设置Pelvis.z=Min(LeftFootOffset.z,RightFootOffset.z);</p><img src='https://img-blog.csdnimg.cn/2020111617001856.png'><img src='https://img-blog.csdnimg.cn/2020111616594744.png'><img src='https://img-blog.csdnimg.cn/20201116165832569.png'></li></ol><h3 id="动画图表"><a href="#动画图表" class="headerlink" title="动画图表"></a>动画图表</h3><ol><li>现有Pose：Base—&gt;UpBody—&gt;LocalPose;<img src='https://img-blog.csdnimg.cn/20201116170745543.png'></li><li>打开骨骼树，添加虚拟骨骼VB thigh_l_calf_l和VB thigh_r_calf_r；<img src='https://img-blog.csdnimg.cn/20201116171006740.png'></li><li>添加Pose：LocalPose—&gt;FootIKPose</li></ol><ul><li><p>pelvis</p><img src='https://img-blog.csdnimg.cn/20201116172111319.png'></li><li><p>ik_foot_l &amp; VB thigh_l_calf_l</p><p><img src='https://img-blog.csdnimg.cn/20201116172150724.png'><img src='https://img-blog.csdnimg.cn/20201116172216387.png'></p></li><li><p>ik_foot_r &amp; VB thigh_r_calf_r</p><p><img src='https://img-blog.csdnimg.cn/20201116172256840.png'><img src='https://img-blog.csdnimg.cn/2020111617232282.png'></p></li></ul><img src='https://img-blog.csdnimg.cn/20201116172648890.png'><ol start="4"><li>最后按布尔输出混合姿势<img src='https://img-blog.csdnimg.cn/20201116172617594.png'>  </li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="添加前Shinbi右脚悬空"><a href="#添加前Shinbi右脚悬空" class="headerlink" title="添加前Shinbi右脚悬空"></a>添加前Shinbi右脚悬空</h2><img src='https://img-blog.csdnimg.cn/20201116152721533.png'><h2 id="添加后Shinbi右脚落地"><a href="#添加后Shinbi右脚落地" class="headerlink" title="添加后Shinbi右脚落地"></a>添加后Shinbi右脚落地</h2><img src='https://img-blog.csdnimg.cn/20201116160346496.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：脚部IK制作。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十七)</title>
    <link href="http://example.com/2020/11/14/RPG-Dev-Log-17/"/>
    <id>http://example.com/2020/11/14/RPG-Dev-Log-17/</id>
    <published>2020-11-14T07:55:56.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：Npc对话系统续，创建背包。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="NPC对话系统（续篇）"><a href="#NPC对话系统（续篇）" class="headerlink" title="NPC对话系统（续篇）"></a>NPC对话系统（续篇）</h2><ol><li>打开枚举E_SelectSubGoalType，添加两个新的枚举BackToLastQuest和FinishQuest;</li><li>打开结构体S_Conversation，添加两个新的成员RecieveTalkTypeInfo(Text)和RecieveQuestTalkInfo(S_SpeechContent[]);</li><li>打开BP_RPG_NPC，完善自定义事件OnClickBack，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114161008148.png'></li><li>修改自定义事件EventOnInteractWith,对TalkInfo做一次Select。交互NPC时将根据玩家是否已经接取任务，显示不同的对话信息条；<img src='https://img-blog.csdnimg.cn/20201114161616981.png'></li><li>修改自定义事件OnClickedQuestInfo，分别对SpeechContent和TalkInfo做一次Select。点击类型为QuestInfo的对话信息条时，将根据玩家是否已经接取任务，显示不同的下级对话信息条和对话信息盒内容；<img src='https://img-blog.csdnimg.cn/20201114161932684.png'></li><li>创建自定义事件SkipTalkInfo，用于跳过对话信息；<img src='https://img-blog.csdnimg.cn/20201114162118327.png'></li><li>打开W_TalkBorder，为HorizatontalBox添加一个SkipButton，并添加绑定事件SkipTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114162351432.png'><img src='https://img-blog.csdnimg.cn/20201114162420284.png'></li><li>创建函数UpdateQuestInfo(HasRecievedQuest?)，用于接取任务时更新对应的对话信息条，在OnClickAddQuest自定义事件中调用；<img src='https://img-blog.csdnimg.cn/20201114164749817.png'></li><li>创建自定义事件OnBackToLastSelect，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114164037125.png'></li><li>创建自定义事件OnFinishQuest，完成任务时根据当前索引移除对应的对话信息条,并返回上一级对话；<img src='https://img-blog.csdnimg.cn/20201114164220856.png'></li><li>更新自定义事件ContinueSelect，添加事件OnBackToLastSelect和OnFinishQuest的调用；<img src='https://img-blog.csdnimg.cn/20201114165003579.png'></li><li>打开D_NPC_Conversation，将TalkInfo[7].SelectSubGoalInfo[1].SelectSubGoalType改为Back，将TalkInfo[8].SelectSubGoalInfo[2].SelectSubGoalType改为BackToLastSelect;<img src='https://img-blog.csdnimg.cn/20201114163211314.png'></li><li>设置新增成员RecieveTalkTypeInfo和RecieveQuestTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114163638476.png'></li></ol><h2 id="创建背包"><a href="#创建背包" class="headerlink" title="创建背包"></a>创建背包</h2><blockquote><p>Spacer：留白占位控件</p><p>WrapBox：流布局控件，其子控件可以根据WrapBox的大小自动换行s</p></blockquote><ol><li>创建控件W_Window，用作背包窗口；<img src='https://img-blog.csdnimg.cn/20201114171504794.png'></li><li>将变量Name绑定至NameForWindow文本控件;</li><li>为CloseButton添加OnClicked绑定事件，添加节点RemoveFromParent；<blockquote><p>当前鼠标的本地位置（LocalPosition）由当前鼠标的绝对位置（AbsolutePosition）经过窗体几何变换得到。</p><p>Canvas Panel Slot插槽位置 = 拖拽终点鼠标的本地位置 - 拖拽起点鼠标的本地位置</p></blockquote></li><li>为DraggableBorder控件添加OnMouseButtonDown事件绑定<strong>（DraggableBorder的所有父控件可视性必须设置为Self Hit Test Invisible,否则无法响应事件）</strong>，判断鼠标是否按在DraggableBorder上，并获取鼠标拖拽后的位置，最后返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172104549.png'></li><li>创建重载函数OnMouseMove，更新拖拽后OutterVerticalBox的位置；<img src='https://img-blog.csdnimg.cn/20201114172158989.png'></li><li>创建重载函数OnMouseButtonUP，当鼠标抬起时结束DraggingWindow可拖拽判定，并返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172238741.png'></li><li>打开RPG_PlayerController，在EventBeginPlay中设置InputGameModeAndUI;<img src='https://img-blog.csdnimg.cn/20201114172545263.png'></li><li>创建Key I键盘输入事件，控制背包的显示和隐藏；<img src='https://img-blog.csdnimg.cn/20201114172647259.png'></li><li>创建控件W_Inventory，用作背包物品的图表和数量显示；<img src='https://img-blog.csdnimg.cn/20201114173149429.png'></li><li>打开事件图表，创建函数GenerateInventorySlot，用于测试背包物品的生成，在事件开始构造时调用;<img src='https://img-blog.csdnimg.cn/20201114173457586.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="接取NPC任务"><a href="#接取NPC任务" class="headerlink" title="接取NPC任务"></a>接取NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165442401.png'><img src='https://img-blog.csdnimg.cn/20201114170429745.png'></p><h2 id="提交NPC任务"><a href="#提交NPC任务" class="headerlink" title="提交NPC任务"></a>提交NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165550957.png'><img src='https://img-blog.csdnimg.cn/20201114170513599.png'></p><h2 id="完成NPC任务"><a href="#完成NPC任务" class="headerlink" title="完成NPC任务"></a>完成NPC任务</h2><img src='https://img-blog.csdnimg.cn/20201114165629575.png'><h2 id="背包效果"><a href="#背包效果" class="headerlink" title="背包效果"></a>背包效果</h2><img src='https://img-blog.csdnimg.cn/20201114155859633.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：Npc对话系统续，创建背包。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十六)</title>
    <link href="http://example.com/2020/11/10/RPG-Dev-Log-16/"/>
    <id>http://example.com/2020/11/10/RPG-Dev-Log-16/</id>
    <published>2020-11-10T11:39:49.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建Npc对话系统（开篇），编辑剧本。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>创建枚举E_TalkType，代表当前对话选项对应的查看内容；<img src='https://img-blog.csdnimg.cn/20201110195932647.png'></li><li>创建枚举E_SelectSubGoalType，代表对话时分支选项的类型；<img src='https://img-blog.csdnimg.cn/2020111020024350.png'></li><li>创建结构体S_SelectSubGoalInfo，包含对话分支选项文本内容以及类型；<img src='https://img-blog.csdnimg.cn/2020111020054178.png'></li><li>创建结构体S_SpeechContent，包含Player与NPC对话的名字、内容、延迟(默认为4s)、是否有分支选项、分支选项内容；<img src='https://img-blog.csdnimg.cn/20201110200855293.png'></li><li>创建结构体S_Conversation，包含对话内容、对话信息、任务类、对话类型、指定任务是否已完成、推荐等级信息；<img src='https://img-blog.csdnimg.cn/20201110201213956.png'></li></ol><h2 id="创建BP-FindGrain"><a href="#创建BP-FindGrain" class="headerlink" title="创建BP_FindGrain"></a>创建BP_FindGrain</h2><img src='https://img-blog.csdnimg.cn/20201110220053550.png'><h2 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h2><h3 id="创建对话选项条W-TalkInfo"><a href="#创建对话选项条W-TalkInfo" class="headerlink" title="创建对话选项条W_TalkInfo"></a>创建对话选项条W_TalkInfo</h3><ol><li>层级面板和预览效果;<img src='https://img-blog.csdnimg.cn/20201110210022230.png'></li><li>打开事件图表，创建函数Update，用于根据TalkType更新TalkInfoImage、HotKeyText（选项数字）、SelectTalkInfo(按钮文本)，并在事件构造时调用;<img src='https://img-blog.csdnimg.cn/20201110210336891.png'></li><li>为SelectButton添加点击事件，根据SubGoalType判断相应的是OnClickedTalkTypeInfo事件（直接对话选项条）还是ContinueSelect事件（分支对话选项条）；<img src='https://img-blog.csdnimg.cn/2020111021555746.png'></li></ol><h3 id="创建对话信息盒W-TalKBorder"><a href="#创建对话信息盒W-TalKBorder" class="headerlink" title="创建对话信息盒W_TalKBorder"></a>创建对话信息盒W_TalKBorder</h3><ol><li>层级面板和预览效果(<strong>注意：将WrapperPolicy由默认模式更改为AllowPerCharacterWrapping，否则无法启用按长度换行功能</strong>)；<img src='https://img-blog.csdnimg.cn/20201110210623158.png'></li><li>打开事件图表，创建自定义事件ShowTalkInfo(Name,TalkInfo)和Hide()，用于显示和隐藏对话信息（实现一问一答的效果）；<img src='https://img-blog.csdnimg.cn/20201110211146795.png'></li></ol><h3 id="在W-PC-Main中添加对话选项盒和对话信息盒"><a href="#在W-PC-Main中添加对话选项盒和对话信息盒" class="headerlink" title="在W_PC_Main中添加对话选项盒和对话信息盒"></a>在W_PC_Main中添加对话选项盒和对话信息盒</h3><ol><li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211446980.png'></li></ol><h3 id="在W-Interaction中添加TalkInfoText"><a href="#在W-Interaction中添加TalkInfoText" class="headerlink" title="在W_Interaction中添加TalkInfoText"></a>在W_Interaction中添加TalkInfoText</h3><ol><li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211642270.png'></li><li>打开事件图表，创建自定义事件ShowTalkInfo(Text)，用于Player靠近NPC时，显示和隐藏NPC头上的信息；<img src='https://img-blog.csdnimg.cn/20201110211814747.png'></li></ol><h2 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h2><h3 id="将NPC互动更改为蓝图接口模式"><a href="#将NPC互动更改为蓝图接口模式" class="headerlink" title="将NPC互动更改为蓝图接口模式"></a>将NPC互动更改为蓝图接口模式</h3><ol><li>删除绑定事件OnInteract;</li><li>在ClassSettings中添加蓝图接口I_Interaction;</li><li>打开BP_RPG_NPC，在事件开始时将ConversationData(DataTable)添加至TalkInfo(S_Conversation);<img src='https://img-blog.csdnimg.cn/20201110204835322.png'></li><li>将Overlap事件更改为调用蓝图接口函数EventBeginOverlapTargetObject和EventEndOverlapTargetObject;<img src='https://img-blog.csdnimg.cn/20201110205210283.png'></li><li>删除OnInteract事件，更改为蓝图接口函数EventOnInteractWith，主要功能为：NPC头顶信息的显示与隐藏，对话选项盒的UI构建;<img src='https://img-blog.csdnimg.cn/20201110212312661.png'><img src='https://img-blog.csdnimg.cn/20201110212357282.png'><img src='https://img-blog.csdnimg.cn/20201110212443312.png'></li></ol><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ol><li><p>修改UpdateQuest，改为仅设置PlayLevel;<img src='https://img-blog.csdnimg.cn/20201110205805908.png'></p></li><li><p>创建事件OnClickedTalkTypeInfo，根据直接对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110213025561.png'></p></li><li><p>创建事件ContinueSelect，根据分支对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110215727110.png'></p></li><li><p>[E_TalkType]枚举事件：</p><ul><li><p>创建事件OnClickedQuestInfo，当点击类型为QuestInfo的对话选项条时，播放对话剧本，并展示对话分支选项，并根据分支选项判断是否接取Quest；</p></li><li><p>创建事件OnClickedEndTalk，结束对话并清空UI;</p></li><li><p>创建事件OnClickedElseInfo(尚未实装)</p></li><li><p>创建事件OnClickedGoodsStore(尚未实装)</p></li><li><p>创建事件OnClickedWeaponStore(尚未实装)</p></li><li><p>创建事件OnClickedEquipStore(尚未实装)</p></li><li><p>创建事件OnClickedDrugStore(尚未实装)</p></li><li><p>创建事件OnClickedFoodStore(尚未实装)</p></li></ul><p><img src='https://img-blog.csdnimg.cn/20201110213742981.png'><img src='https://img-blog.csdnimg.cn/20201110213844323.png'></p></li><li><p>[E_SelectSubGoalType]枚举事件：</p><ul><li>创建事件OnClickedContinue</li><li>创建事件OnClickedBack</li><li>创建事件OnClickedAddQuest</li><li>创建事件OnClickedQuit</li></ul></li></ol><h3 id="实例设置-NPC皮特"><a href="#实例设置-NPC皮特" class="headerlink" title="实例设置(NPC皮特)"></a>实例设置(NPC皮特)</h3><img src='https://img-blog.csdnimg.cn/20201110220234754.png'><h2 id="剧本编辑"><a href="#剧本编辑" class="headerlink" title="剧本编辑"></a>剧本编辑</h2><h3 id="创建Data-Table"><a href="#创建Data-Table" class="headerlink" title="创建Data Table"></a>创建Data Table</h3><ol><li>创建D_NPC_Conversation；<img src='https://img-blog.csdnimg.cn/20201110202006809.png'></li></ol><h3 id="编辑对话选项内容（含分支选项）"><a href="#编辑对话选项内容（含分支选项）" class="headerlink" title="编辑对话选项内容（含分支选项）"></a>编辑对话选项内容（含分支选项）</h3><ol><li><p>[QuestInfo]任务接取向——接取FindGrain任务：</p><img src='https://img-blog.csdnimg.cn/20201110203722362.png'></li><li><p>[ElseInfo]剧情介绍向——与NPC闲聊；<img src='https://img-blog.csdnimg.cn/20201110202040377.png'></p></li><li><p>[GoodsStore]市场交易向——杂货店：<img src='https://img-blog.csdnimg.cn/20201110202215835.png'></p></li><li><p>[WeaponStore]市场交易向——武器商店：<img src='https://img-blog.csdnimg.cn/20201110202303511.png'></p></li><li><p>[DrugStore]市场交易向——药品商店：<img src='https://img-blog.csdnimg.cn/20201110202358802.png'></p></li><li><p>[FoodStore]市场交易向——食物商店：<img src='https://img-blog.csdnimg.cn/20201110202638264.png'></p></li><li><p>[EquipStore]市场交易向——防具商店：<img src='https://img-blog.csdnimg.cn/20201110202659579.png'></p></li><li><p>[End]结束对话：<img src='https://img-blog.csdnimg.cn/2020111020280739.png'></p></li></ol><h3 id="编辑对话剧本"><a href="#编辑对话剧本" class="headerlink" title="编辑对话剧本"></a>编辑对话剧本</h3><table><thead><tr><th align="center">TalkerName</th><th align="center">SpeechInfo</th></tr></thead><tbody><tr><td align="center">Shinbi</td><td align="center">嗨，大叔，你知道如何才能进入峡谷吗？</td></tr><tr><td align="center">皮特</td><td align="center">大叔？小哥年方十八！</td></tr><tr><td align="center">Shibi</td><td align="center">…</td></tr><tr><td align="center">皮特</td><td align="center">咳咳。。。峡谷常年迷雾，又有猛兽出没，凶险万分，姑娘切莫深入。</td></tr><tr><td align="center">Shinbi</td><td align="center">大叔放心，小女子十八般武艺样样精通，拳打南山猛虎，脚踢北海蛟龙，正好顺道为名除害！</td></tr><tr><td align="center">皮特</td><td align="center">。。。大叔。。的确，看姑娘的着装并非普通女子，非富即贵，只是。。。</td></tr><tr><td align="center">Shinbi</td><td align="center">哈哈…就是，小女子才貌双全，大叔有何难处尽管直言！</td></tr><tr><td align="center">皮特</td><td align="center">呃。。这个，最近天降大雪，家中缺粮，我这不出来寻粮了吗，如果姑娘能带来一袋小麦，我将带你进入峡谷的入口。。。</td></tr><tr><td align="center">Shinbi(分支1-1)</td><td align="center">哈哈，小事情，交给我吧！不过这荒天雪地的能不能折现？？</td></tr><tr><td align="center">Shinbi(分支1-2)</td><td align="center">这荒天雪地的上哪去找一袋小麦。。</td></tr><tr><td align="center">皮特</td><td align="center">这个、、、多谢女侠，折合成市价30硬币。</td></tr><tr><td align="center">Shinbi(分支2-1)</td><td align="center">给与30硬币。</td></tr><tr><td align="center">Shinbi(分支2-2)</td><td align="center">给与一袋小麦。</td></tr><tr><td align="center">Shinbi(分支2-3)</td><td align="center">我再想想。。</td></tr></tbody></table><img src='https://img-blog.csdnimg.cn/20201110203809964.png'><img src='https://img-blog.csdnimg.cn/20201110203838787.png'><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201110194837692.png'><img src='https://img-blog.csdnimg.cn/20201110194928442.png'><img src='https://img-blog.csdnimg.cn/20201110195002450.png'><img src='https://img-blog.csdnimg.cn/2020111019504116.png'><img src='https://img-blog.csdnimg.cn/20201110195118759.png'><img src='https://img-blog.csdnimg.cn/20201110195145659.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建Npc对话系统（开篇），编辑剧本。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十五)</title>
    <link href="http://example.com/2020/11/07/RPG-Dev-Log-15/"/>
    <id>http://example.com/2020/11/07/RPG-Dev-Log-15/</id>
    <published>2020-11-07T16:13:02.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统续，任务分支完成互动。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="W-PC-Main相关"><a href="#W-PC-Main相关" class="headerlink" title="W_PC_Main相关"></a>W_PC_Main相关</h2><ol><li><p>创建动画HideAll，用于隐藏主界面的所有用户自定义控件；<img src='https://img-blog.csdnimg.cn/20201108003424947.png'></p></li><li><p>创建函数[Float] PlayHideAll(Boolean)，用于控制HideAll动画的播放；<img src='https://img-blog.csdnimg.cn/20201108004704213.png'></p></li></ol><h2 id="W-Mission相关"><a href="#W-Mission相关" class="headerlink" title="W_Mission相关"></a>W_Mission相关</h2><ol><li>界面优化：打开W_Mission，为任务列表栏和任务详情栏添加边框(Image/Border);<img src='https://img-blog.csdnimg.cn/20201108002312944.png'></li><li>控件添加：添加返回按钮，取消勾选Interaction&gt;IsFocusable，并创建OnClick事件：点击按钮时隐藏任务系统界面并显示主界面；<img src='https://img-blog.csdnimg.cn/20201108004137729.png'><img src='https://img-blog.csdnimg.cn/20201108012623353.png'></li><li>动画添加：为SelectedBorder和CancelBorder添加ButtonPlay和ButtonCancel动画（两个动画除绑定对象不同外，其余都相同），并分别创建OnClick事件：点击SelectButton时播放ButtonPlay动画，调用SelectNewQuest事件，并隐藏SelectButton所在的HorizantalBox（使其无法再次被选择）。点击ButtonCancel时播放ButtonCancel动画。最后修改函数UpdateDetailWindow，比较SelectedQuest是否为CurrentQuest，若为真则隐藏SelectedHorizantalBox，否则显示SelectedHorizantalBox；<img src='https://img-blog.csdnimg.cn/20201108012156563.png'><img src='https://img-blog.csdnimg.cn/20201108014256728.png'><img src='https://img-blog.csdnimg.cn/2020110801435634.png'></li><li>函数修改：修改函数GenertateSubGoals，将参数HuntIndex传入W_MissionSubGoal；<img src='https://img-blog.csdnimg.cn/20201108231031870.png'></li></ol><h2 id="W-MissionSubGoal相关"><a href="#W-MissionSubGoal相关" class="headerlink" title="W_MissionSubGoal相关"></a>W_MissionSubGoal相关</h2><ol><li>修改函数Update，更新Hunt类型分支任务的信息；<img src='https://img-blog.csdnimg.cn/20201108024335447.png'></li></ol><h2 id="W-Quest相关"><a href="#W-Quest相关" class="headerlink" title="W_Quest相关"></a>W_Quest相关</h2><ol><li>修改函数[void]SelectSubGoal(W_SubGoal)，当SelectedSubGoal与传入的SubGoal不同时，更新SelectedSubGoal;<img src='https://img-blog.csdnimg.cn/20201108021956595.png'></li></ol><h2 id="W-SubGoal相关"><a href="#W-SubGoal相关" class="headerlink" title="W_SubGoal相关"></a>W_SubGoal相关</h2><ol><li>控件添加：添加FailedImage，对应SuccessImage;<img src='https://img-blog.csdnimg.cn/20201108020420640.png'></li><li>函数功能扩展：修改函数[void]DisableButton()为[void]DisableButton(Success?)，当任务完成时显示SuccessImage，任务失败时显示FailedImage;<img src='https://img-blog.csdnimg.cn/2020110916482665.png'></li><li>函数功能扩展：修改函数Update，添加CurrentSubGoal索引查询，并设置为HuntedIndex。添加SubGoalState，并对其作一个Select，以更新SubGoal信息（注意，如果此处不作select，SubGoal当前击杀/寻找数会循环0,1,2）;<img src='https://img-blog.csdnimg.cn/20201108023744297.png'><img src='https://img-blog.csdnimg.cn/20201109164737918.png'></li></ol><h2 id="BP-MasterQuest相关"><a href="#BP-MasterQuest相关" class="headerlink" title="BP_MasterQuest相关"></a>BP_MasterQuest相关</h2><ol><li>创建函数[Boolean]SelectInMission()，用于判断SelectedQuest是否为CurrentQuest；<img src='https://img-blog.csdnimg.cn/20201108014943318.png'></li><li>修改函数SetupStartingSubGoals，根据StartSubGoalIndices的数组长度对CurrentHuntedAmount数组进行Resize;<img src='https://img-blog.csdnimg.cn/20201108015344389.png'></li><li>修改函数[void]CompleteSubGoal(SubGoalIndex，Success?)，将传入参数Success提升为本地变量，并传入函数DisableButton(Success?)；<img src='https://img-blog.csdnimg.cn/20201109165028882.png'><img src='https://img-blog.csdnimg.cn/20201109165053562.png'><img src='https://img-blog.csdnimg.cn/20201109165133515.png'><img src='https://img-blog.csdnimg.cn/20201109165224466.png'></li><li>修改自定义事件UpdateCompletedSubGoal，初始化CurrentHuntedAmout数组为0，修改SubGoal的延迟更新条件;<img src='https://img-blog.csdnimg.cn/2020110802323032.png'><img src='https://img-blog.csdnimg.cn/20201108023250768.png'></li></ol><h2 id="BP-Enemy相关"><a href="#BP-Enemy相关" class="headerlink" title="BP_Enemy相关"></a>BP_Enemy相关</h2><ol><li>打开事件图表，修改自定义事件OnDeath，调用QuestManager自定义事件OnEnemyKilled；<img src='https://img-blog.csdnimg.cn/20201108031744839.png'></li></ol><h2 id="BP-QuestTest相关"><a href="#BP-QuestTest相关" class="headerlink" title="BP_QuestTest相关"></a>BP_QuestTest相关</h2><ol><li>打开测试专用Quest，创建Hunt型分支任务，猎杀目标为Enemy_Grunting;<img src='https://img-blog.csdnimg.cn/20201108031950863.png'></li></ol><h2 id="BP-TargetObject及其相关子类"><a href="#BP-TargetObject及其相关子类" class="headerlink" title="BP_TargetObject及其相关子类"></a>BP_TargetObject及其相关子类</h2><ol><li><p>BP_TargetObject组件面板修改如下（StaticMesh已被删除）；</p><img src='https://img-blog.csdnimg.cn/20201108033013777.png'></li><li><p>为Object_Treasure单独添加StaticMesh组件；</p></li><li><p>创建新的子类Object_Grain，并添加StaticMesh组件，将谷物袋子模型导入，设置Name和Interact文本初始值。添加接口EventOnInteractWith（Character)，调用OnObjectFound事件；<img src='https://img-blog.csdnimg.cn/20201108033817418.png'></p></li></ol><h2 id="QuestManager相关"><a href="#QuestManager相关" class="headerlink" title="QuestManager相关"></a>QuestManager相关</h2><ol><li>函数模块化：打开函数[void] AddQuest(QuestClass,DirectlyStart)，将Branch之后有关Quest和SubGoal动画播放的蓝图迁移至自定义事件SelectNewQuest(NewQuest)，当CurrentQuest为NULL时更新Quest并播放动画，不为NULL时检测SubGoal首项是否有效（若无效则更新Quest，否则延迟更新直至SubGoal首项无效）。在AddQuest中被调用;<img src='https://img-blog.csdnimg.cn/20201108011601891.png'></li><li>创建自定义事件OnEnemyKilled(Class)，锁定类型为Hunt的分支任务的Index，并根据击杀的敌人类型判断是否为有效击杀，若为有效击杀则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若击杀数大于需求数，则调用CompleteSubGoal。<img src='https://img-blog.csdnimg.cn/20201108030332689.png'><img src='https://img-blog.csdnimg.cn/20201108031407189.png'></li><li>创建自定义事件OnObjectFound(Class)，锁定类型为Search的分支任务的Index，并根据找到的物品类型判断是否为有效寻找，若为有效寻找则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若找到的数量大于需求数，则调用CompleteSubGoal。（相关蓝图与OnEnemyKilled(Class)类似）</li></ol><h2 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h2><ol><li>打开事件图表，修改Tab事件，打开任务系统界面时暂停游戏；<img src='https://img-blog.csdnimg.cn/2020110800393081.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="【子任务】狩猎小鬼完成效果"><a href="#【子任务】狩猎小鬼完成效果" class="headerlink" title="【子任务】狩猎小鬼完成效果"></a>【子任务】狩猎小鬼完成效果</h2><p><img src='https://img-blog.csdnimg.cn/20201109160208908.png'><img src='https://img-blog.csdnimg.cn/202011091641213.png'></p><h2 id="【子任务】寻找小麦完成效果"><a href="#【子任务】寻找小麦完成效果" class="headerlink" title="【子任务】寻找小麦完成效果"></a>【子任务】寻找小麦完成效果</h2><img src='https://img-blog.csdnimg.cn/20201108230246514.png'><img src='https://img-blog.csdnimg.cn/20201108230310157.png'><h2 id="【子任务】完成前后对比"><a href="#【子任务】完成前后对比" class="headerlink" title="【子任务】完成前后对比"></a>【子任务】完成前后对比</h2><img src='https://img-blog.csdnimg.cn/20201108230013575.png'><img src='https://img-blog.csdnimg.cn/20201108230045246.png'><img src='https://img-blog.csdnimg.cn/2020110916421358.png'><img src='https://img-blog.csdnimg.cn/20201109164242272.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统续，任务分支完成互动。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十四)</title>
    <link href="http://example.com/2020/11/04/RPG-Dev-Log-14/"/>
    <id>http://example.com/2020/11/04/RPG-Dev-Log-14/</id>
    <published>2020-11-04T15:01:43.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统创建(续篇),蓝图UI任务数据绑定。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="创建W-MissionSubGoal"><a href="#创建W-MissionSubGoal" class="headerlink" title="创建W_MissionSubGoal"></a>创建W_MissionSubGoal</h2><ol><li>创建控件W_MissionSubGoal，作为W_Mission中任务分支信息SubGoalInfoVerticalBox的子控件；<br><img src='https://img-blog.csdnimg.cn/20201105072242910.png'><img src='https://img-blog.csdnimg.cn/20201105072311908.png'></li><li>创建函数Update，用于更新SubGoalText的文本内容(这部分蓝图可从W_SubGoal中的Update函数迁移过来)，并根据任务状态设置CurrentImage、SuccessImage、FailedImage的可视性，并在事件开始构造时调用；<img src='https://img-blog.csdnimg.cn/20201105072948473.png'></li></ol><h2 id="任务列表项W-QuestBorder"><a href="#任务列表项W-QuestBorder" class="headerlink" title="任务列表项W_QuestBorder"></a>任务列表项W_QuestBorder</h2><ol><li>打开S_QuestInfo，添加属性SuggestedLevel(Integer)；</li><li>打开W_QuestBorder，创建函数[void] Update()，用于绑定W_QuestBorder相关任务数据，包括QuestName、Frame、RegionText、LevelText、QuestTypeIcon等控件的文本、颜色、图标等，并且对QuestName控件的文本进行长度检测（任务名过长时缩略显示）；<img src='https://img-blog.csdnimg.cn/20201104232620180.png'></li><li>创建自定义事件UpdateSuggestedLevelColor(PlayerLevel)并绑定至事件调度UpdateLevelQuest。每当角色升级时，调用此事件，更新任务推荐等级的文本颜色，为游戏玩家提供更好的视觉效果（具体方法与Enemy的头衔颜色更新类似，通过PlayerLevel/Suggested的值设置Alpha的值，从而设置颜色过渡）。最后调用Update函数，完成任务列表所有数据项的显示更新;<img src='https://img-blog.csdnimg.cn/20201104233806488.png'></li></ol><h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><ol><li>打开W_QuestBorder，为AnimBorder创建划入(AddQuestBorder)和划出(RemoveQuestBorder)动画；<img src='https://img-blog.csdnimg.cn/20201104234440454.png'><img src='https://img-blog.csdnimg.cn/20201104234537409.png'></li><li>创建宏ShowQuestBorder(Visible)，用于根据当前控件的可视性播放划入或划出动画；<img src='https://img-blog.csdnimg.cn/20201104234832171.png'></li><li>为CurrentQuestButton、CompletedQuestButton、FailedQuestButton、HasQuestButton添加绑定事件：以CurrentQuestButton为例，当点击按钮时，隐藏CompletedScrollBox、FailedScrollBox、HasQuestScrollBox三个滚动框，并显示CurrentScrollBox（其余三个按钮同理）；<img src='https://img-blog.csdnimg.cn/2020110423525363.png'></li><li>创建自定义事件UpdateSuggestedLevel(PlayerLevel)，用于设置任务详情中推荐等级的文本颜色（设置方法同上）,并将此自定义事件绑定至事件调度UpdateLevelForQuest；<img src='https://img-blog.csdnimg.cn/2020110500005662.png'><img src='https://img-blog.csdnimg.cn/20201105000436852.png'></li><li>创建函数UpdateDescription，用于更新任务的具体描述，相关控件为DescriptionText，这里需要注意文本换行符的转义方式;<img src='https://img-blog.csdnimg.cn/2020110500113572.png'></li><li>创建函数UpdateDetailWindow，用于绑定W_Mission任务详情的相关任务数据，包括QuestName、TypeText、QuestTypeImage、RegionText、SuggestedLevel、MoneyText、ExpText、PrestigeText等控件的文本、颜色和图标等，数据源为SelectedQuest(BP_MasterQuest，所有Quest的父类)中的QuestInfo，并调用函数UpdateSuggestedLevel(PlayerLevel)，UpdateDescription，GenerateSubGoals；<img src='https://img-blog.csdnimg.cn/20201105064907715.png'><img src='https://img-blog.csdnimg.cn/20201105065000665.png'><img src='https://img-blog.csdnimg.cn/20201105065053167.png'><img src='https://img-blog.csdnimg.cn/2020110506512638.png'></li><li>创建函数GenerateSubGoals，用于更新SubGoalVerticalBox控件，绑定任务分支信息的相关数据，数据源为SelectedQuest(BP_MasterQuest)中的CompleteSubGoalInfo和CurrentSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201105071813592.png'></li><li>创建枚举E_QuestState；<img src='https://img-blog.csdnimg.cn/20201105073933672.png'></li><li>创建函数AddQuestBorder(Quest)，用于任务列表项W_QuestBorder(CurrentScrollBox等滚动框的子控件)的添加；<img src='https://img-blog.csdnimg.cn/20201105073719617.png'></li><li>创建自定义事件OnQuestBorderClicked(QuestBorder)，绑定至W_QuestBorder中的按钮QuestBorderButton。当任务列表项被点击时，禁用该列表项按钮，并调用函数UpdateDetailWindow，完成任务详情的更新；<img src='https://img-blog.csdnimg.cn/20201105074414237.png'><img src='https://img-blog.csdnimg.cn/20201105074646874.png'></li></ol><h2 id="任务组件QuestManager"><a href="#任务组件QuestManager" class="headerlink" title="任务组件QuestManager"></a>任务组件QuestManager</h2><ol><li>创建结构体S_CompletedSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201105065535758.png'></li><li>创建枚举E_SubGoalState；<img src='https://img-blog.csdnimg.cn/20201105065701141.png'></li></ol><h2 id="任务父类BP-MasterQuest"><a href="#任务父类BP-MasterQuest" class="headerlink" title="任务父类BP_MasterQuest"></a>任务父类BP_MasterQuest</h2><ol><li>打开BP_MasterQuest，重新设置CompletedSubGoalsInfo变量类型为S_CompletedSubGoalInfo（原来为S_SubGoalInfo，即扩展SubGoalIndex、Succesful两个引脚);</li><li>函数功能扩展：函数CompleteSubGoal(SubGoalIndex)变更为CompleteSubGoal(SubGoalIndex,Success?)，传入任务是否成功完成的参数，以便于CompletedSubGoalsInfo变量的更新;</li><li>函数功能扩展：函数SetupStartingSubGoals新增Description的数据更新，数据源为QuestInfo;</li><li>函数功能扩展：函数AddQuest(QuestClass)变更为AddQuest(QuestClass,DirectlyStart)，根据当前任务数量和DirectlyStart的布尔值判断是否自动接取任务。若自动接取任务，则播放动画PlayQuest和PlaySubGoal(来着W_Quest)；</li><li>关联事件修改：打开事件图表，修改自定义事件UpdateCompletedSubGoal；</li></ol><h2 id="任务实例设置"><a href="#任务实例设置" class="headerlink" title="任务实例设置"></a>任务实例设置</h2><h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><img src='https://img-blog.csdnimg.cn/20201105080724734.png'><h3 id="支线任务"><a href="#支线任务" class="headerlink" title="支线任务"></a>支线任务</h3><img src='https://img-blog.csdnimg.cn/20201105080758220.png'><h3 id="副本任务"><a href="#副本任务" class="headerlink" title="副本任务"></a>副本任务</h3><img src='https://img-blog.csdnimg.cn/20201105080823342.png'><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201105082833827.png'><img src='https://img-blog.csdnimg.cn/20201105082916789.png'><img src='https://img-blog.csdnimg.cn/20201105083011449.png'><img src='https://img-blog.csdnimg.cn/20201105082938769.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统创建(续篇),蓝图UI任务数据绑定。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十三)</title>
    <link href="http://example.com/2020/11/03/RPG-Dev-Log-13/"/>
    <id>http://example.com/2020/11/03/RPG-Dev-Log-13/</id>
    <published>2020-11-03T03:31:15.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：大任务系统创建（进阶），UI设计应用细讲。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><h3 id="任务类型侧边栏"><a href="#任务类型侧边栏" class="headerlink" title="任务类型侧边栏"></a>任务类型侧边栏</h3><p>涉及组件：</p><ul><li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]</li><li>Common: [Border]、[Button]、[Text]</li></ul><h4 id="层级面板"><a href="#层级面板" class="headerlink" title="层级面板"></a>层级面板</h4><img src='https://img-blog.csdnimg.cn/20201103114016404.png'><h4 id="实装效果"><a href="#实装效果" class="headerlink" title="实装效果"></a>实装效果</h4><img src='https://img-blog.csdnimg.cn/20201103114544272.png'><h4 id="组件动画"><a href="#组件动画" class="headerlink" title="组件动画"></a>组件动画</h4><p>Widget可视性：</p><blockquote><p>**Visible(可视)**： 可见、可点击<br>**Collapsed(已折叠)**： 不可见、不占用布局空间（性能优于 Hidden）<br>**Hidden(隐藏)**： 不可见、占用布局空间<br>**HitTestInvisible(非可命中测试（自身和所有子项）)**： 可见、当前 Widget 不可点击、所有 Child Widget 不可点击<br>**SelfHitTestInvisible(非可命中测试（仅自身）)**： 可见、当前 Widget 不可点击、不影响 Child Widget</p></blockquote><ol><li>打开W_Mission,添加组件动画OpenMission;<img src='https://img-blog.csdnimg.cn/20201103120349278.png'></li><li>创建宏ShowMission(Visible);<img src='https://img-blog.csdnimg.cn/20201103121441665.png'></li><li>创建自定义事件PlayMission(Visible)，调用宏ShowMission(Visible)；</li></ol><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>设计组件：</p><ul><li>Panel: [Size Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li><li>Common: [Border]、[Text]</li></ul><h4 id="层级面板-1"><a href="#层级面板-1" class="headerlink" title="层级面板"></a>层级面板</h4><img src='https://img-blog.csdnimg.cn/20201103114907317.png'><h4 id="实装效果-1"><a href="#实装效果-1" class="headerlink" title="实装效果"></a>实装效果</h4><img src='https://img-blog.csdnimg.cn/20201103114943124.png'><h3 id="任务详情"><a href="#任务详情" class="headerlink" title="任务详情"></a>任务详情</h3><p>涉及组件：</p><ul><li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li><li>Common: [Border]、[Button]、[Text]、[Image]</li></ul><h4 id="层级面板-2"><a href="#层级面板-2" class="headerlink" title="层级面板"></a>层级面板</h4><img src='https://img-blog.csdnimg.cn/20201103115323410.png'><h4 id="实装效果-2"><a href="#实装效果-2" class="headerlink" title="实装效果"></a>实装效果</h4><img src='https://img-blog.csdnimg.cn/2020110311543341.png'><h2 id="任务提示界面W-QuestBorder"><a href="#任务提示界面W-QuestBorder" class="headerlink" title="任务提示界面W_QuestBorder"></a>任务提示界面W_QuestBorder</h2><h3 id="层级面板-3"><a href="#层级面板-3" class="headerlink" title="层级面板"></a>层级面板</h3><img src='https://img-blog.csdnimg.cn/20201103120105457.png'><h3 id="实装效果-3"><a href="#实装效果-3" class="headerlink" title="实装效果"></a>实装效果</h3><img src='https://img-blog.csdnimg.cn/20201103120130439.png'><h2 id="热键测试"><a href="#热键测试" class="headerlink" title="热键测试"></a>热键测试</h2><p>打开RPG_PlayerController，添加热键Tab响应事件，切入和切出任务系统主界面；<br><img src='https://img-blog.csdnimg.cn/20201103121909957.png'></p><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020110311322945.png'><img src='https://img-blog.csdnimg.cn/20201103113402801.png'></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：大任务系统创建（进阶），UI设计应用细讲。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>游戏人工智能:从FSM到Behavior Tree</title>
    <link href="http://example.com/2020/11/01/AI-BehaviorTree/"/>
    <id>http://example.com/2020/11/01/AI-BehaviorTree/</id>
    <published>2020-11-01T13:34:44.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A behavior tree is to express the behavior of artificial intelligence. The behavior tree has a characteristic that is easy to change state transitions than FSM(Finite State Machine).</p></blockquote><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以RPG游戏为例，无论是PVE模式还是PVP模式，都会涉及人工智能这个概念。其中包括引导新手的NPC，玩家对战的NPC等。</p><h2 id="FSM-Finite-State-Machine"><a href="#FSM-Finite-State-Machine" class="headerlink" title="FSM(Finite State Machine)"></a>FSM(Finite State Machine)</h2><p>双FSM是目前最常用的一样方法，它定义了有限多个状态（行为），用图表来表达状态之间的因果关系。虽然理解状态的组成和转移很容易，但有个问题：状态和转移越多，维护就越困难。</p><img src='https://img-blog.csdnimg.cn/20201101214601997.png' alt='[Fig.1] FSM'><h3 id="Fig-1-FSM"><a href="#Fig-1-FSM" class="headerlink" title="[Fig.1] FSM"></a>[Fig.1] FSM</h3><p>图示给出了FSM的一个例子。它由Search、Chase和Attack状态组成，状态转换条件显示在箭头之上。为了改进FSM，实现更加精密的人工智能开发，提出了行为树的概念。它仍然具有类似于FSM的形式，但是即便状态和状态之间的关系再多，管理难度也远小于FSM。它更适合具有复杂行为和功能的智能体。</p><h2 id="Behavior-Tree"><a href="#Behavior-Tree" class="headerlink" title="Behavior Tree"></a>Behavior Tree</h2><img src='https://img-blog.csdnimg.cn/20201101220407953.png' alt='[Fig.2] Behavior Tree'><h3 id="Fig-2-Behavior-Tree"><a href="#Fig-2-Behavior-Tree" class="headerlink" title="[Fig.2] Behavior Tree"></a>[Fig.2] Behavior Tree</h3><p>图示给出了一个行为树的例子。这些行为树在PRG/RTS/FPS等类型的游戏中都具备可用性。对于单个对象的行为或控制逻辑，我们认为没有必要使用行为树。</p><h3 id="原理和方法"><a href="#原理和方法" class="headerlink" title="原理和方法"></a>原理和方法</h3><p>行为树是通过将AI的角色行为定义为树的方法，通过连接角色行为的条件和因果关系，优先级等对应的节点来完成。 </p><h3 id="Unreal-Engine中的BT"><a href="#Unreal-Engine中的BT" class="headerlink" title="Unreal Engine中的BT"></a>Unreal Engine中的BT</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li>Task：基础节点。</li><li>Decorator：定义当前分支返回结果是否为真。</li><li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li><li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li><li>Service：在固定更新频率的黑板上运行。</li></ul><img src='https://img-blog.csdnimg.cn/20201101222235173.png' alt='[Table 2] Unreal Engine'><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><img src='https://img-blog.csdnimg.cn/20201101225753418.png' alt='[Fig.5] Unreal Engine Behavior Tree'><h3 id="Unity-Engine中的BT"><a href="#Unity-Engine中的BT" class="headerlink" title="Unity Engine中的BT"></a>Unity Engine中的BT</h3><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><ul><li>Action：基础节点。</li><li>Decorator：定义当前分支返回结果是否为真。</li><li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li><li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li><li>Priority selector：决定最高优先级的节点。</li><li>Parallel: 平行子节点将被同时执行。</li></ul><img src='https://img-blog.csdnimg.cn/20201101222050462.png' alt='[Table 1] Unity Engine'><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><img src='https://img-blog.csdnimg.cn/20201101230244379.png' alt='[Fig.6] Unity Engine Behavior Tree'><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == FAILURE:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selector_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == SUCCESS:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FAILURE</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parallel</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index_list = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">if</span> len(run_index_list) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> run_index_list:</span><br><span class="line">            state_dic[index] = child_list[index](owner)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        run_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">            state_dic[run_index] = child_list[run_index](owner)</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> state_dic.count(SUCCESS) &gt;= MIN_SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> SUCCESS</span><br><span class="line">    <span class="keyword">elif</span> state_dic.count(FAILURE) &gt;= MIN_FAILURE:</span><br><span class="line">        <span class="keyword">return</span> FAILURE</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> RUNNING</span><br></pre></td></tr></table></figure><h3 id="两大引擎中的BT对比-参照UE4"><a href="#两大引擎中的BT对比-参照UE4" class="headerlink" title="两大引擎中的BT对比(参照UE4)"></a>两大引擎中的BT对比(参照UE4)</h3><p>​        两个引擎的行为树具有很多共同点，就是可以很容易地了解一个行为实现的条件和下一个行为是什么。</p><p>我们定义一组AI行为：</p><ol><li><p>[EnemyNotInRange]以AI当前位置为中心，在一定范围内没有基地的情况下，为了寻找基地，AI将自主移动前进。</p></li><li><p>[EnemyInRange]若在前进途中遇到敌人，则攻击它，受到伤害降低生命值。</p></li><li><p>[NotHealth]若生命值为0，则死亡，否则继续执行1。</p></li><li><p>[EnemyBaseInRange]若发现基地，则攻击基地。</p></li></ol><img src='https://img-blog.csdnimg.cn/20201101225148412.png'  alt='[Fig.3] Unreal Engine Behavior Tree'><img src='https://img-blog.csdnimg.cn/20201101230351316.png' alt='[Fig.4] Unity Engine Behavior Tree'><h4 id="行为树为事件驱动型"><a href="#行为树为事件驱动型" class="headerlink" title="行为树为事件驱动型"></a>行为树为事件驱动型</h4><blockquote><p>行为树可避免在每帧中执行大量工作。行为树并不会经常检查相关变化是否已经发生，它只会被动地等待在树中引起变化的“事件”。</p><p>事件驱动型结构对运行性能和除错大有帮助。如果希望获得这些帮助，必须理解虚幻引擎树的其他不同点，并正确搭建行为树结构。</p><p>代码在整个树的每个标记中无需迭代，因此运行性能将大大提升！从概念上而言，我们不需要不停地问“我们到了吗”，只需要轻松休息，会有人来告诉我们“到啦！”</p><p>在行为树执行日志中反复查看对行为进行纠错时，最佳的方法是让日志显示相关的变更，不显示无关的变更。在事件驱动型应用中，无需过滤出在树上迭代并选择之前相同行为的无关步骤，因为额外的迭代从开始便并未发生！只有树中执行位置或黑板数值发生的变化会产生影响，不同之处显而易见。</p></blockquote><h4 id="条件语句并非叶节点"><a href="#条件语句并非叶节点" class="headerlink" title="条件语句并非叶节点"></a>条件语句并非叶节点</h4><blockquote><p>在行为树标准模型中，条件语句为 Task 叶节点，除成功和失败外不执行任何操作。虽然也可以使用传统的条件 tasks，但还是强烈推荐您使用 Decorator 系统作为条件语句。</p><p>使用 decorators 而非 tasks 作为条件语句有多个明显优点。</p><p>首先，条件 decorators 使行为树 UI 显得更加直观易读。条件语句位于其所控制分支树的根部，因此一旦条件语句未被满足，便可直接看到树的哪个部分被“关闭”。此外，所有叶节点均为行动 tasks，因此更容易分辨树在对哪些实际行动下达命令。 在传统模型中，条件语句混于叶节点中，因此需要花更多时间分辨哪些叶节点是条件语句，哪些叶节点是行动。</p></blockquote><h4 id="并发行为的特殊处理"><a href="#并发行为的特殊处理" class="headerlink" title="并发行为的特殊处理"></a>并发行为的特殊处理</h4><blockquote><p>标准行为树通常使用 <strong>Parallel composite</strong> 节点来处理并发行为。Parallel 节点同时执行其所有子项。在一个或多个子项树完成时，特殊规则将决定如何执行（取决于所需行为）。</p><p>Parallel 节点不是绝对的多线程（完全同步执行任务）。它们只是概念上一次执行多个任务的方式。它们经常在同一线程上运行，并在一些序列中开始。该序列应为不相关，因为它们全部在同一框架中发生。但有时它也很重要。</p><p>UE4 行为树抛弃了复杂 Parallel 节点，使用 <strong>Simple Parallel</strong> 节点和称为 <strong>Services</strong> 的特殊节点，以实现同类行为。</p><h4 id="Simple-Parallel-节点"><a href="#Simple-Parallel-节点" class="headerlink" title="Simple Parallel 节点"></a>Simple Parallel 节点</h4><p>Simple Parallel 节点只允许两个子项的存在：一个必为单独任务节点（含可选 decorators）、另一个为一个完整的分支树。</p><p>可以将 Simple Parallel 节点理解为：“执行 A 的同时也执行 B。”举例而言：“在攻击敌人时向敌人移动。”基本上来说，A 是主要任务，而 B 是等待 A 完成时执行的次要或补充任务。</p><p>有一些选项可以处理同时进行的次要任务（任务 B）。较之于传统 Parallel 节点，该节点在概念上还是相对简单。然而，它支持 Parallel 节点的多数常规用法。</p><p>可利用 Simple Parallel 节点简便地进行一些事件驱动型优化。而 Full Parallel 节点的优化则要复杂许多。</p><h4 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h4><p><strong>Services</strong> 是与 composite 节点（Selector、Sequence、或 Simple Parallel）相关的特殊节点。它能在每 X 秒注册回呼并执行多个定期发生类型的更新。</p><p>举例而言，service 能用于确定哪名敌人是 AI pawn 的最佳追逐目标；与此同时，pawn 在其行为树中继续正常追踪当前敌人。</p><p>只有执行仍然处于以 composite 节点（与 service 相关）为根的分支树中时，Services 方为有效。</p><h4 id="Decorator-“Observer-Aborts”-属性"><a href="#Decorator-“Observer-Aborts”-属性" class="headerlink" title="Decorator “Observer Aborts” 属性"></a>Decorator “Observer Aborts” 属性</h4><p>标准 Parallel 节点的一个常见用途是不断对条件进行检查，以便在条件无法达成时中止任务。举例而言，有一只猫执行序列，如“摇屁股”或“猛扑”，在老鼠已经逃进洞后，直接放弃任务。如使用 Parallel 节点，有一个子项将检查猫是否可以扑到老鼠，另一子项就是要执行的序列。因为 UE4 行为树是事件驱动型，条件 decorators 将观察数值，并在需要时中止任务。（在该例中，只需要在序列上添加“老鼠是否能被扑到” decorator，然后将 “Observer Aborts” 设为 “Self”。）</p></blockquote><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p>[1].Myoun-Jae Lee.A Proposal on Game Engine Behavior Tree[J].Journal of Digital Convergence,2016,14(8),415-421.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A behavior tree is to express the behavior of artificial intelligence. The behavior tree has a characteristic that is easy to change state transitions than FSM(Finite State Machine).&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Theories" scheme="http://example.com/categories/Theories/"/>
    
    
    <category term="Artificial Intelligence" scheme="http://example.com/tags/Artificial-Intelligence/"/>
    
    <category term="Behavior Tree" scheme="http://example.com/tags/Behavior-Tree/"/>
    
    <category term="Finite State Machine" scheme="http://example.com/tags/Finite-State-Machine/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十二)</title>
    <link href="http://example.com/2020/11/01/RPG-Dev-Log-12/"/>
    <id>http://example.com/2020/11/01/RPG-Dev-Log-12/</id>
    <published>2020-11-01T08:01:47.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：制作简单的粒子特效，获得经验金币，重生Enemy。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="敌人死后消亡特效"><a href="#敌人死后消亡特效" class="headerlink" title="敌人死后消亡特效"></a>敌人死后消亡特效</h2><ol><li>创建MaterialFunction[MF_DissolveEffect]，添加Input[Visibility]，Type=Function Input Scalar；<img src='https://img-blog.csdnimg.cn/2020110116235018.png'></li><li>打开Enemy材质球，调用MF_DissolveEffect，添加OnHit和Visibility参数，设置EmissiveColor和OpacityMask；<img src='https://img-blog.csdnimg.cn/20201101162845368.png'></li><li>创建Enemy材质球实例，选择PreviewMesh，设置EffectColor，调整OnHit和Visibility的值可预览Enemy被攻击时、消亡时的材质效果；<img src='https://img-blog.csdnimg.cn/20201101164744129.png'></li><li>创建AnimationNotify[ANS_DissolveEffect]，添加重载函数Received_NotifyTick，根据动画曲线[Dissolve_Spawn]渐变Visibility的值；<img src='https://img-blog.csdnimg.cn/20201101165355339.png'></li><li>为Enemy的七种随机死亡动画添加Notify[ANS_DissolveEffect]和Curve[Dissolve_Spawn];<img src='https://img-blog.csdnimg.cn/20201101165816602.png'></li></ol><h2 id="击杀敌人获得战利品"><a href="#击杀敌人获得战利品" class="headerlink" title="击杀敌人获得战利品"></a>击杀敌人获得战利品</h2><h3 id="获取经验值"><a href="#获取经验值" class="headerlink" title="获取经验值"></a>获取经验值</h3><h4 id="创建粒子特效"><a href="#创建粒子特效" class="headerlink" title="创建粒子特效"></a>创建粒子特效</h4><ol><li><p>创建材质球[P_Base]，添加Input[ParticleColor]，设置EmissiveColor和Opacity;<img src='https://img-blog.csdnimg.cn/20201101170341930.png'></p></li><li><p>创建材质球实例[P_Base_Inst];</p></li><li><p>打开初学者内容包里的P_Teleport_Tell_Source粒子特效，重命名为P_SoulXP，并打开;</p></li><li><p>对于第一个ParticleEmitter，将Emitter Duration设置为0，添加DirectLocation;</p></li><li><p>对于第二个ParticleEmitter，直接关闭;</p></li><li><p>对于第三个ParticleEmitter，将Emitter Duration设置为0，略微调大InitialSize，调整Sphere StartLocation的Z轴；</p></li><li><p>新建一个ParticleEmitter，将Material设置为P_Base_Inst，Spawn Rate设置为0，Burst Count设置为1，删除InitVelocity，调整ColorOverLife，添加Direct Location；</p></li><li><p>新建一个ParticleEmitter,TypeData设置为GPU Sprites,设置Spawn Distribution为Distribution Float Constant,添加Sphere并设置颜色;<img src='https://img-blog.csdnimg.cn/20201101172623580.png'></p></li></ol><h4 id="创建BP-XP"><a href="#创建BP-XP" class="headerlink" title="创建BP_XP"></a>创建BP_XP</h4><ol><li><p>创建Actor[BP_XP]，添加组件Sphere Collision，设置半径，应用物理属性，设置重量为3kg，更改碰撞预设为Custom;<img src='https://img-blog.csdnimg.cn/20201101173214860.png'></p></li><li><p>添加组件ParticleSystem，将Particle Template设置为P_SoulXP;</p></li><li><p>打开BP_Player事件图表，创建自定义事件AddXP(XP);<img src='https://img-blog.csdnimg.cn/20201101174006324.png'></p></li><li><p>打开事件图表，设置物理模拟，添加TimeLine[MoveToPlayer],实现玩家击杀敌人后吸收经验的效果。创建自定义事件FinishCollect，调用自定义事件AddXP；<img src='https://img-blog.csdnimg.cn/20201101174735841.png'><img src='https://img-blog.csdnimg.cn/20201101174658471.png'></p></li></ol><h4 id="设置EnemyXP"><a href="#设置EnemyXP" class="headerlink" title="设置EnemyXP"></a>设置EnemyXP</h4><ol><li><p>打开BP_Enemy,打开函数SetNameAndLevel，创建变量XP_Points，扩展函数功能，可通过敌人和玩家的等级差设置XP_Points(默认为10)，具体为：</p><p>XP_Points = 10 + 2*(EnemyLevel-1) + MAX(0,EnemyLevel-PlayerLevel);<img src='https://img-blog.csdnimg.cn/20201101175450907.png'></p></li><li><p>接上，函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101175712965.png'></p></li><li><p>创建函数[Void]SpawnXPAndMoney(FirstIndex),用于经验球和金币的生成,并在自定义事件OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101180333637.png'><img src='https://img-blog.csdnimg.cn/2020110118043023.png'></p></li></ol><h3 id="获取金币"><a href="#获取金币" class="headerlink" title="获取金币"></a>获取金币</h3><h4 id="创建BP-SpawnMoney"><a href="#创建BP-SpawnMoney" class="headerlink" title="创建BP_SpawnMoney"></a>创建BP_SpawnMoney</h4><ol><li>复制BP_XP,重命名为BP_SpawnMoney，删除ParticleSystem，添加StaticMesh和RotatingMovement；</li><li>设置StaticMesh为SM_Coin_Small，编辑材质球，调整EmissiveColor,提高亮度;</li><li>修改自定义事件FinishCollect，调用玩家蓝图中的自定义事件GetMoney;<img src='https://img-blog.csdnimg.cn/20201101181026191.png'></li></ol><h4 id="设置EnemyMoney"><a href="#设置EnemyMoney" class="headerlink" title="设置EnemyMoney"></a>设置EnemyMoney</h4><ol><li><p>函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101181416558.png'></p></li><li><p>函数SpawnXPAndMoney中关于金币生成的部分，在OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101181603620.png'></p></li></ol><h2 id="重生Enemy"><a href="#重生Enemy" class="headerlink" title="重生Enemy"></a>重生Enemy</h2><ol><li>创建结构体S_RespawnEnemy;<img src='https://img-blog.csdnimg.cn/20201101182318659.png'></li><li>创建Actor[BP_SpawnEnemy]，添加组件SpehreCollison，碰撞预设为NoCollison;</li><li>打开事件图表，创建变量EnemyList(S_RespawnEnemy),SpawnTimer(TimerHandle),IndicesToSpawn(Integer[]);</li><li>创建自定义事件RespawnEnemy(S_RespawnEnemy)，将死亡的敌人记录到EnemtList中，并用SpawnTimer控制自定义事件RespawnTick的调用，IndicesToSpawn数组用于记录敌人重生的索引顺序；<img src='https://img-blog.csdnimg.cn/20201101184746163.png'><img src='https://img-blog.csdnimg.cn/20201101184831482.png'><img src='https://img-blog.csdnimg.cn/20201101184908545.png'></li><li>打开BP_Enemy，在OnDeath中调用RespawnEnemy;<img src='https://img-blog.csdnimg.cn/2020110118502269.png'></li><li>打开BehaviorComponent，修改函数SetBehavior，对传入的AI行为进行判断,若与当前的AI行为不同，则将传入的AI行为设置为当前行为；<img src='https://img-blog.csdnimg.cn/2020110118562015.png'></li><li>打开BTS_UpdateBehaviorTree，添加重载事件Recieve Tick AI；<img src='https://img-blog.csdnimg.cn/20201101185829997.png'></li><li>设置BP_Enemy,Auto Prossess AI = Placed in World or Spawned；</li><li>设置Enemy_Grunting，Auto Prossess AI = Placed in World or Spawned，并设置默认属性值，敌人等级的随机生成；<img src='https://img-blog.csdnimg.cn/20201101190150116.png'></li><li>将BP_SpawnSphere添加到场景，并指定场景中的Enemy的RespawnActor为BP_SpawnSphere;</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/2020110116105649.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：制作简单的粒子特效，获得经验金币，重生Enemy。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十一)</title>
    <link href="http://example.com/2020/10/27/RPG-Dev-Log-11/"/>
    <id>http://example.com/2020/10/27/RPG-Dev-Log-11/</id>
    <published>2020-10-27T10:21:00.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：战斗系统（续篇），AI设置，蒙太奇动画。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="蒙太奇动画"><a href="#蒙太奇动画" class="headerlink" title="蒙太奇动画"></a>蒙太奇动画</h2><h3 id="玩家被击蒙太奇"><a href="#玩家被击蒙太奇" class="headerlink" title="玩家被击蒙太奇"></a>玩家被击蒙太奇</h3><ol><li>添加ShinBi被攻击时的骨骼动画，创建Montage，将HitRect_Back、HitRect_Font、HitReact_Left、HitRect_Right分成4个section添加进来;<img src='https://img-blog.csdnimg.cn/20201027183226400.png'></li><li>打开BP_Shibi事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次角色被攻击时，随机播放4个section中的一个；<img src='https://img-blog.csdnimg.cn/20201027183642919.png'></li></ol><h3 id="敌人被击蒙太奇"><a href="#敌人被击蒙太奇" class="headerlink" title="敌人被击蒙太奇"></a>敌人被击蒙太奇</h3><ol><li>创建[AM_React_LightHit]蒙太奇，添加轻击时的骨骼动画，共2种,分成2个Section;<img src='https://img-blog.csdnimg.cn/20201027190551416.png'></li><li>创建[AM_React_HeavyHit]蒙太奇，添加两种重击时的骨骼动画，共2种Section,分成2个Section；<img src='https://img-blog.csdnimg.cn/20201027190633867.png'></li><li>打开BP_Enemy事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次敌人被攻击时，随机播放2个section中的一个，根据伤害是否暴击播放不同的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201027191532830.png'></li></ol><h3 id="敌人死亡蒙太奇"><a href="#敌人死亡蒙太奇" class="headerlink" title="敌人死亡蒙太奇"></a>敌人死亡蒙太奇</h3><ol><li>创建[AM_Death]蒙太奇，添加敌人死亡时的骨骼动画，共7种，分成7个Section；<img src='https://img-blog.csdnimg.cn/20201027191035160.png'></li><li>打开BP_Enemy事件图表，在OnDeath事件添加敌人死亡的随机蒙太奇动画播放，随机个数为7；<img src='https://img-blog.csdnimg.cn/20201027194633761.png'></li></ol><h2 id="战斗系统（续篇）"><a href="#战斗系统（续篇）" class="headerlink" title="战斗系统（续篇）"></a>战斗系统（续篇）</h2><h3 id="玩家相关"><a href="#玩家相关" class="headerlink" title="玩家相关"></a>玩家相关</h3><ol><li>打开BP_Shibi，添加自定义事件LineAttack，调用OnRecieveDamage事件，用于判定玩家是否成功命中敌人；<img src='https://img-blog.csdnimg.cn/20201027184947351.png'></li><li>打开三连攻击和空中攻击Montage动画，在PlaySound后添加AttackHit动画通知；在动画图表中调用BP_Shibi中的自定义事件LineAttack;<img src='https://img-blog.csdnimg.cn/20201027184701875.png'></li><li>修改函数[void]ModifyAttribute(Attribute,ModifyValue,Critical);</li><li>创建函数[void]UpdateLevel()，用于玩家升级后自身属性和技能点的更新；<img src='https://img-blog.csdnimg.cn/20201027213303392.png'></li><li>打开事件图表，修改自定义事件UpLevel，调用UpdateLevel()完成所有属性的更新；<img src='https://img-blog.csdnimg.cn/2020102721360097.png'></li><li>修改MeleeAttack（普通三连攻击）和Space Bar（二段跳)事件，实装耐力值消耗；</li><li>创建自定义事件CoolDownFighting和CountTime，用于玩家当前是否脱战的判定;<img src='https://img-blog.csdnimg.cn/20201027215037170.png'></li><li>精简Regeneration分类下的所有Tick事件的功能；</li></ol><h3 id="敌人相关"><a href="#敌人相关" class="headerlink" title="敌人相关"></a>敌人相关</h3><ol><li>打开E_Behavior，添加新的AI行为Death；</li><li>打开BP_Enemy，添加自定义事件ModifyValue(Boolean:Critical,Float:Damage),用于敌人攻击玩家时的伤害显示，并根据自身当前血量，设置Death或HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201027193429331.png'></li><li>添加OnRecieveDamage事件,接收来自玩家的伤害数据，调用事件ModifyValue,计算伤害并应用伤害;<img src='https://img-blog.csdnimg.cn/20201027193207452.png'></li><li>添加自定义事件OnDeath,用于敌人死亡时的动画播放和自身销毁（如果有武器，武器也销毁）；<img src='https://img-blog.csdnimg.cn/20201027223511642.png'></li><li>创建函数[Boolean] IsPlayingMontage()，用于判断当前是否已添加蒙太奇；<img src='https://img-blog.csdnimg.cn/2020102719201244.png'></li><li>创建函数[void]UpdateAttribute,用于不同等级的敌人的属性更新（在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/20201027195155263.png'></li><li>创建函数[void]SetNameAndLevel(Integer),此函数除了设置NameAndHealthBar的文本外，还可根据玩家和敌人的等级差，设置不同的文本颜色渐变(在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/2020102720012115.png'><img src='https://img-blog.csdnimg.cn/20201027200251916.png'></li><li>添加胶囊碰撞体ShowEnemyWidget，并添加BeginOverlap和EndOverlap事件，当玩家与敌人的胶囊体发生碰撞时，显示NameAndHealthBar，离开胶囊体区域时隐藏；<img src='https://img-blog.csdnimg.cn/20201027200721727.png'></li></ol><h2 id="AI设置"><a href="#AI设置" class="headerlink" title="AI设置"></a>AI设置</h2><h3 id="敌人攻击流畅度优化"><a href="#敌人攻击流畅度优化" class="headerlink" title="敌人攻击流畅度优化"></a>敌人攻击流畅度优化</h3><ol><li>为BTTask_Attack添加Decorator[CoolDown]，冷却时间设置为1s；</li><li>打开BTTask_Attack，新增蒙太奇动画检测，若敌人正在攻击则延迟播放；<img src='https://img-blog.csdnimg.cn/20201027192842439.png'></li></ol><h3 id="敌人死亡Sequence"><a href="#敌人死亡Sequence" class="headerlink" title="敌人死亡Sequence"></a>敌人死亡Sequence</h3><ol><li>创建BTTask_Death，调用BP_Enemy中的OnDeath事件；<img src='https://img-blog.csdnimg.cn/20201027194039645.png'></li><li>创建Sequence并添加Blackboard Decorator[EventDeath],设置BlackboardKey=Behavior,KeyValue=Death，序列执行顺序为:BTTask_Death—&gt;Wait(5)（then Loop);<img src='https://img-blog.csdnimg.cn/20201027194357652.png'></li></ol><h3 id="离开敌人仇恨范围后脱战"><a href="#离开敌人仇恨范围后脱战" class="headerlink" title="离开敌人仇恨范围后脱战"></a>离开敌人仇恨范围后脱战</h3><ol><li>打开E_Behavior，添加新的AI行为RunBack；</li><li>创建服务BTS_CheckOriginalDistance，用于判断玩家是否已经离开了敌人AI的仇恨范围，并执行RunBack行为；<img src='https://img-blog.csdnimg.cn/20201027220346975.png'></li><li>打开BB_Base，添加新的键值IsRunningBack?(Boolean)和RandomRange(Float);</li><li>将服务BTS_CheckOriginalDistance添加至Selector(HasSeenPlayer)，并添加Blackboard Decorator[IsNotRunningBack]至子节点sequence，设置BlackboardKey=IsRunningBack?;</li><li>打开BTTask_RandomLocation，将浮点型变量RandomRadius修改为BlackBoardKey类型，并在BP_Enemy BeginPlay中添加传值；</li><li>创建任务BTTask_Reset，用于判断敌人AI是否已经脱仇，并执行来自BP_Enemy的Reset事件；<img src='https://img-blog.csdnimg.cn/2020102722221863.png'><img src='https://img-blog.csdnimg.cn/20201027222301945.png'></li><li>创建Sequence并添加Blackboard Decorator[RunBack],设置BlackboardKey=Behavior,KeyValue=RunBack，序列执行顺序为:MoveTo(Original)—&gt;BTTask_Reset（then Loop);<img src='https://img-blog.csdnimg.cn/20201027222635974.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/2020102813041126.gif'><img src='https://img-blog.csdnimg.cn/20201028130602858.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：战斗系统（续篇），AI设置，蒙太奇动画。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(十)</title>
    <link href="http://example.com/2020/10/25/RPG-Dev-Log-10/"/>
    <id>http://example.com/2020/10/25/RPG-Dev-Log-10/</id>
    <published>2020-10-25T11:58:21.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建Enemy；创建战斗系统（开篇）。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[InfinityBlade:Adversaries]</p><p>虚幻商城[Action RPG]</p><p>虚幻商城[User Interface Kit]</p><h2 id="创建Enemy"><a href="#创建Enemy" class="headerlink" title="创建Enemy"></a>创建Enemy</h2><h3 id="创建敌人动画蓝图"><a href="#创建敌人动画蓝图" class="headerlink" title="创建敌人动画蓝图"></a>创建敌人动画蓝图</h3><ol><li><p>以BP_RPG_Character为父类，创建BP_Enemy;</p></li><li><p>将InfinityBlade:Adversaries资源[Enemy_Grunting]导入，创建动画蓝图ABP_Grunting和一维混合空间BS_Grunting_Skeleton_BlendSpace1D;</p></li><li><p>打开项目Action RPG,将骨骼动画Idle_Grunting导出为fbx文件，随后添加至ContentBrowser；</p></li><li><p>打开BS_Grunting_Skeleton_BlendSpace1D，设置水平坐标为Speed，最大水平值为400。将骨骼动画Idle、Walk_Slow、Walk、Run添加至适当坐标，并勾选Walk_Slow、Walk、Run的ForceFontXAxis选项；</p></li><li><p>打开ABP_Grunting，添加蓝图获取PawnOwner的Speed;</p></li><li><p>进入动画图表，新建状态机，添加Start&lt;=&gt;Locomotion状态及过渡规则（此处省略状态动画的相关蓝图设置）；<img src='https://img-blog.csdnimg.cn/20201025201901720.png'><img src='https://img-blog.csdnimg.cn/20201025202013508.png'></p></li></ol><h3 id="创建敌人蓝图"><a href="#创建敌人蓝图" class="headerlink" title="创建敌人蓝图"></a>创建敌人蓝图</h3><ol><li><p>以BP_Enemy为父类，创建蓝图Enemy_Grunting，添加骨骼和骨骼动画，调整碰撞胶囊体大小；</p></li><li><p>打开BP_Enemy，修改PaperSprite样式，添加组件Widget,命名为NameAndHealthBar，并添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201025203024776.png'></p></li></ol><h3 id="创建武器蓝图"><a href="#创建武器蓝图" class="headerlink" title="创建武器蓝图"></a>创建武器蓝图</h3><ol><li><p>创建BP_Weapon，添加组件Sphere、StaticMesh、SkeletalMesh、Capsule，设置相关参数；</p></li><li><p>以BP_Weapon为父类，创建Weapon_Grunting,添加Grunting武器模型，调整胶囊体和武器朝向；</p></li><li><p>打开Enemy_Grunting骨骼，添加Sockect[Weapon]至b_MF_Weapon_R,添加preview assets，设置预览动画，调整Socket位置;</p></li><li><p>打开事件图表，添加蓝图，将Weapon添加至敌人身上；<img src='https://img-blog.csdnimg.cn/20201025C204213703.png'></p></li></ol><h3 id="创建敌人名称血量UI"><a href="#创建敌人名称血量UI" class="headerlink" title="创建敌人名称血量UI"></a>创建敌人名称血量UI</h3><ol><li>创建Widget[W_Enemy]，层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201025204659690.png'></li><li>打开BP_Enemy，将W_Enemy添加至NameAndHealthBar，并调整其位置;</li><li>创建结构体S_EnemyAttribute，添加敌人血量上限、物理攻击/法术攻击、物理防御/法术防御等属性；<img src='https://img-blog.csdnimg.cn/20201025205105844.png'></li><li>打开BP_Enemy，创建函数[void] SetHealthPercent()，用于控制敌人血量百分比显示,在EventBegin添加调用；<img src='https://img-blog.csdnimg.cn/2020102520543750.png'></li></ol><h3 id="创建敌人AI行为——Random"><a href="#创建敌人AI行为——Random" class="headerlink" title="创建敌人AI行为——Random"></a>创建敌人AI行为——Random</h3><ol><li><p>打开E_Behaviors，添加AI行为枚举[Random]；</p></li><li><p>创建Componet[Behavior创建Componet],创建事件调度OnBehaviorChanged(E_Behaviors);</p></li><li><p>创建函数[void] SetBehavior(E_Behaviors),用于Call事件调度；<img src='https://img-blog.csdnimg.cn/20201025210057184.png'></p></li><li><p>将BehaviorComponet添加至BP_RPG_Character；</p></li><li><p>打开行为树BT_NPC，打开服务BTS_UpdateBehaviorTree，删除重载函数ReceiveTickAI，添加重载函数ReveiveSearchStartAI,创建自定义事件OnBehaviorChanged(E_Behaviors),调用宏SetBehavior;<img src='https://img-blog.csdnimg.cn/20201025211113194.png'></p></li><li><p>打开之前创建的BP_RPG_NPC_Warriors巡逻NPC，通过Behavior组件调用宏SetBehavior，实现AI行为改变；</p></li><li><p>打开BB_Base，添加Key[Originl]、[Random]、[Target];</p></li><li><p>创建Task[BTTask_RandomLocation],重载ReceiveExecuteAI事件，控制AI随机半径巡逻;<img src='https://img-blog.csdnimg.cn/20201025211959614.png'></p></li><li><p>打开行为树BT_NPC，创建Sequence并添加Blackboard Decorator[RandomLocation],序列执行顺序为:Wait（5)—&gt;BTTask_RandomLocation(SelfActor,Random,2000)—&gt;MoveTo(Random)（then Loop);<img src='https://img-blog.csdnimg.cn/20201026163507753.png'></p></li><li><p>打开BP_Enemy，初始化Blackboard的Original值为ActorLocation,设置AI行为为Random;<img src='https://img-blog.csdnimg.cn/20201025214715454.png'></p></li><li><p>设置AI Controller Class为AIC_Controller。</p></li></ol><h2 id="创建战斗系统（开篇）"><a href="#创建战斗系统（开篇）" class="headerlink" title="创建战斗系统（开篇）"></a>创建战斗系统（开篇）</h2><h3 id="创建敌人AI行为——HasSeenPlayer"><a href="#创建敌人AI行为——HasSeenPlayer" class="headerlink" title="创建敌人AI行为——HasSeenPlayer"></a>创建敌人AI行为——HasSeenPlayer</h3><ol><li><p>打开BP_Enemy，添加组件PawnSensing，设置视野半径和周边视野角度；<img src='https://img-blog.csdnimg.cn/20201026162705473.png'></p></li><li><p>打开BB_Base，添加key[Target]，类型为Actor;添加IsInAttackRange，类型为Boolean。打开E_Behavior，添加枚举HasSeenPlayer；</p></li><li><p>打开BP_Enemy事件图表，添加OnSeePawn(PawnSensing)事件，当Enemy感知Player时，加速靠近Player并执行HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201026163212433.png'></p></li><li><p>创建任务BTTask_Check，重载事件ReceiveExcuteAI，用于检测Player是否在AI视野范围内；<img src='https://img-blog.csdnimg.cn/2020102616394518.png'></p></li><li><p>创建任务BTTask_Attack，重载事件ReceiveExecuteAI,调用BP_Enemy的Attack事件。创建自定义事件FinalAttack，成功执行返回success；<img src='https://img-blog.csdnimg.cn/20201026164404943.png'></p></li></ol><h3 id="创建敌人攻击动画"><a href="#创建敌人攻击动画" class="headerlink" title="创建敌人攻击动画"></a>创建敌人攻击动画</h3><ol><li>将InfinityBlade:Adversaries资源[Enemy_Anim_Sword_Combat_Swing_Montage]导入，创建动画Montage;</li><li>打开ABP_Grunting，状态Locomotion添加DefaultSlot，使动画Montage生效；</li><li>打开BP_Enemy事件图表，创建自定义事件Attack,执行Attack蒙太奇动画，并调用BTTask_Attack中的自定义事件FinalAttack;<img src='https://img-blog.csdnimg.cn/20201026165559988.png'></li><li>打开行为树BT_NPC,创建Selector并添加Blackboard Decorator[HasSeenPlayer],设置BlackboardKey=Behavior,KeyValue=HasSeenPlayer；创建Sequence，序列执行顺序为BTTask_Check(Target,IsInAttackRange,AttackRange)——&gt;MoveTo(Target)[CheckAttackRange(Target)]——&gt;BTTask_Attack(then loop);<img src='https://img-blog.csdnimg.cn/20201026165758704.png'></li><li>创建AnimNotifyState[ANS_Weapon]，创建重载函数Reveived_NotifyBegin，Received_NotifyEnd，当敌人攻击角色时，临时关闭胶囊体碰撞；<img src='https://img-blog.csdnimg.cn/20201026174431299.png'></li></ol><h3 id="创建敌人攻击伤害显示"><a href="#创建敌人攻击伤害显示" class="headerlink" title="创建敌人攻击伤害显示"></a>创建敌人攻击伤害显示</h3><ol><li><p>创建蓝图接口I_Damageable,创建接口函数[void] OnRecieveDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage);</p></li><li><p>打开BP_Enemy，添加蓝图接口I_Damageable；</p></li><li><p>打开BP_RPG_Character，创建函数[Boolean:IsCritical?，Float:Damage] CalculateDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage,Float:PhysicalDefence，Float:MagicDefence，Boolean:AbsoluteDefence);</p></li><li><p>函数CalculateDamage用于综合敌人攻击属性和玩家防御属性，计算最终伤害，计算公式为：</p><p>Damage=</p><p>[</p><p>PhysicalDamage×random(0.9,1.1)-PhysicalDefence</p><p>+</p><p>MagicDamage×random(0.7,1.3)-MagicDefence</p><p>]</p><p>×</p><p>(IsCritical ?  1 :  CriticalDamage)；<img src='https://img-blog.csdnimg.cn/20201026171644771.png'></p></li><li><p>打开Enemy_Grunting，整合BeginPlay事件至父类BP_Enemy中的自定义事件CreateWeapon，并修改为在BP_Enemy中的BeginPlay事件中调用；<img src='https://img-blog.csdnimg.cn/20201026173117268.png'></p></li><li><p>打开BP_Shibi，添加OnRecieveDamage函数实现，调用CalculateDamage和ModifyAttribute(新的参数Critical,用于暴击判定，最终传入SetDamageText)，实现敌人伤害计算并应用于玩家的血量变更；<img src='https://img-blog.csdnimg.cn/20201026173731535.png'></p></li><li><p>打开BP_Weapon，添加事件ActorBeginOverlap，当敌人追上玩家时，传入敌人属性，调用OnRecieveDamage事件；<img src='https://img-blog.csdnimg.cn/20201026174639179.png'></p></li><li><p>打开W_DamageText，扩展UpdateValue函数功能，添加新的传入参数[Critical]，用于暴击伤害时伤害数字的特殊显示；<img src='https://img-blog.csdnimg.cn/20201026175016824.png'></p></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201026011936218.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建Enemy；创建战斗系统（开篇）。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(九)</title>
    <link href="http://example.com/2020/10/23/RPG-Dev-Log-9/"/>
    <id>http://example.com/2020/10/23/RPG-Dev-Log-9/</id>
    <published>2020-10-23T10:13:57.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：任务完成的互动，混合骨骼动画，普通攻击三连制作等；</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Infinity Blade:Adversaries]</p><p>虚幻商城[Infinity Blade:Effects]</p><h2 id="优化开箱互动"><a href="#优化开箱互动" class="headerlink" title="优化开箱互动"></a>优化开箱互动</h2><ol><li>打开Object_Treasure事件图表，创建TimeLine [MoveToPlayer]，创建Float Track，作为金币移动至人物身上的Alpha通道（类指数曲线）;<img src='https://img-blog.csdnimg.cn/20201023182304187.png'></li><li>扩展自定义事件Event On Interact With功能，实现金币被角色吸引——产生马里奥金币音效的效果；<img src='https://img-blog.csdnimg.cn/20201023182357341.png'></li></ol><h2 id="创建移动平台"><a href="#创建移动平台" class="headerlink" title="创建移动平台"></a>创建移动平台</h2><ol><li>创建Acotr [BP_MovePlane]，添加一个StaticMesh,添加SM_Env_Ice_Cliffs；</li><li>打开事件图表，创建TimeLine[Move]，创建Float Track，作为平台移动的Alpha通道（类正弦曲线）,勾选Loop模式；<img src='https://img-blog.csdnimg.cn/20201023183342627.png'></li><li>在Event BeginPlay实现平台相对于自身的偏移移动；<img src='https://img-blog.csdnimg.cn/20201023183559104.png'></li></ol><h2 id="任务完成的互动"><a href="#任务完成的互动" class="headerlink" title="任务完成的互动"></a>任务完成的互动</h2><ol><li><p>打开S_SubGoalInfo，添加成员HasFollowingIndex?(Boolean);</p></li><li><p>打开W_SubGoal，创建函数DisableButton，用于SelectButton按钮的disable,Done图标和SubGoalText文本的高亮显示；<img src='https://img-blog.csdnimg.cn/20201023184922881.png'></p></li><li><p>打开W_Quest,创建宏AnimateSubGoalWidget(Exec，Boolean)，将宏PlayHideAll中有关SubGoal的显示动画（Show/Text）整合进来，并扩展功能，使其在Quest完成时播放隐藏动画；<img src='https://img-blog.csdnimg.cn/20201023190840946.png'><img src='https://img-blog.csdnimg.cn/20201023190652645.png'></p></li><li><p>打开EvenGraph，添加自定义事件PlaySubGoal(Boolean)，调用宏AnimateSubGoalWidget(Boolean)，修改自定义事件PlayQuest()为PlayQuest(Boolean)，调用宏PlayHideAll(Boolean);<img src='https://img-blog.csdnimg.cn/20201023191105631.png'></p></li><li><p>打开函数GenerateSubGoal，当SubGoal循环添加完成时,调用自定义事件PlaySubGoal，播放相关动画；</p></li><li><p>打开BP_MasterQuest，创建自定义事件UpdateCompleteSubGoal,创建变量CompletedSubGoalsInfo(S_SubGoalInfo)、CompletedSubGoalIndex(Integer),用于记录已完成的SubGoal信息和索引。当所有<strong>已显示</strong>的SubGoal都被标记为完成时，执行PlaySubGoal(false)动画，并判断是否仍有FollowingIndex。若有，则延迟1.5s后调用函数GenrateSubGoal和SelectSubGoal，再生SubGoal；<img src='https://img-blog.csdnimg.cn/20201023193814396.png'></p></li><li><p>创建函数CompletedSubGoal(Integer)，用于记录已完成的SubGoal信息和索引更新，并同步UI更新（调用函数DisableButton和自定义事件UpdateCompleteSubGoal)；<img src='https://img-blog.csdnimg.cn/20201023194332860.png'><img src='https://img-blog.csdnimg.cn/20201023194354363.png'></p></li><li><p>复制一份BP_FirstQuest，命名为BP_FirstQuestTest，修改index=3的SubGoal,勾选HasFollowingIndex?,添加FollowingSubGoalIndices;<img src='https://img-blog.csdnimg.cn/20201023195017556.png'></p></li><li><p>打开BP_Shibi事件图表，创建J键盘事件，测试任务完成时的互动效果；<img src='https://img-blog.csdnimg.cn/20201023194602440.png'></p></li></ol><h2 id="普通攻击三连制作"><a href="#普通攻击三连制作" class="headerlink" title="普通攻击三连制作"></a>普通攻击三连制作</h2><ol><li>导入Shibi角色MeleeAttack动画（Air/B/C/D)，创建Montage，命名为Air_Melee、Melee_B、Melee_C、Melee_D；</li><li>导入Shibi角色Attack音效（1/2/3/4）,创建Cue，命名为Shinbi_Effect_Attack，编辑蓝图实现4种攻击音效随机播放的效果；<img src='https://img-blog.csdnimg.cn/20201024173918860.png'></li><li>打开Montage[Air_Melee],添加Notify [Play Sound]、Skeleton Notify [Reset]；<img src='https://img-blog.csdnimg.cn/2020102417450352.png'></li><li>打开Montage[Melee_B],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174714903.png'></li><li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174753486.png'></li><li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174837728.png'></li><li>打开BP_Shibi，创建自定义事件MeleeAttack、SaveAttack、ResetComb;</li><li>打开ABP_Shibi事件图表，AnimNotify_Save调用SaveAttack事件，AnimNotify_Reset调用ResetComb事件；<img src='https://img-blog.csdnimg.cn/20201024175438930.png'></li><li>返回BP_Shibi，完成自定义事件MeleeAttack、SaveAttack、ResetComb，SavaAttack用于记录当前普通攻击归属第几段，当角色停止普通攻击时，ResetComb将初始化Attack信息;<img src='https://img-blog.csdnimg.cn/20201024175625435.png'></li><li>创建Q键盘事件，关联普通攻击，调用MeleeAttack事件，并根据角色是否滞空播放相应的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201024175856577.png'></li></ol><h2 id="混合骨骼动画"><a href="#混合骨骼动画" class="headerlink" title="混合骨骼动画"></a>混合骨骼动画</h2><ol><li><p>打开ABP_Shibi事件图表，完善动画更新事件，判断角色是否处于加速状态或FullBody状态；<img src='https://img-blog.csdnimg.cn/20201024180437185.png'></p></li><li><p>打开ABP_Shibi动画图表，添加按骨骼分层混合，以及按布尔值混合姿势。当角色处于加速状态并且Body Curve返回值为0时，输出按骨骼分层混合姿势，否则输出UpBody姿势；<img src='https://img-blog.csdnimg.cn/20201024181347328.png'></p><img src='https://img-blog.csdnimg.cn/20201024180639713.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/2020102417301295.gif'><img src='https://img-blog.csdnimg.cn/20201024173043229.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：任务完成的互动，混合骨骼动画，普通攻击三连制作等；&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(八)</title>
    <link href="http://example.com/2020/10/21/RPG-Dev-Log-8/"/>
    <id>http://example.com/2020/10/21/RPG-Dev-Log-8/</id>
    <published>2020-10-21T08:47:22.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：任务坐标，Money互动等;</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Content Examples]</p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：脚印、钱包]</p><h2 id="创建搜寻目标"><a href="#创建搜寻目标" class="headerlink" title="创建搜寻目标"></a>创建搜寻目标</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>创建Interface [I_Interaction],添加函数BeginOverlapTargetObject、EndOverlapTargetObject、OnInteractWith(Char_Shibi);</p></li><li><p>创建Actor [BP_TargetObject]，添加组件StaticMesh、Widget、PaperSprite，并在事件开始时隐藏PaperSprite;</p></li><li><p>将I_Interaction蓝图接口添加至BP_TargetObject;</p></li><li><p>打开S_SubGoalInfo，添加属性TargetClass(Actor)、TargetClassID(Integer);</p></li><li><p>打开Char_Shibi,添加Box碰撞体，并添加碰撞事件，调用I_Interaction接口函数；<img src='https://img-blog.csdnimg.cn/20201021171021322.png'></p></li><li><p>为E键盘事件扩展功能，使其借助蓝图接口实现互动；<img src='https://img-blog.csdnimg.cn/20201021171350706.png'></p></li><li><p>重命名W_NameForNPC为W_Interaction，并添加到BP_TargetObject的Widget上，在事件开始运行时设置W_Interaction的Name和Interact的文本；<img src='https://img-blog.csdnimg.cn/20201021171832273.png'></p></li><li><p>打开BP_TargetObject事件蓝图，实现蓝图接口中三个接口函数;<img src='https://img-blog.csdnimg.cn/20201021172214999.png'></p></li></ol><h3 id="创建目标实例-藏宝箱"><a href="#创建目标实例-藏宝箱" class="headerlink" title="创建目标实例(藏宝箱)"></a>创建目标实例(藏宝箱)</h3><ol><li>以BP_TargetObject为父类，创建子类Object_Treasure；</li><li>将[Content Examples]资源包中的StaticMesh [SM_Chest_Bottom、SM_Chest_Lid、SM_Coin_Small]添加进来，调整Transform;</li><li>实现蓝图接口I_Interaction中的接口函数OnInteractWith，使用TimeLine实现宝箱打开、金币弹出并旋转的交互动画;<img src='https://img-blog.csdnimg.cn/20201021173246323.png'><img src='https://img-blog.csdnimg.cn/20201021173324992.png'></li></ol><h3 id="创建目标小地图指示"><a href="#创建目标小地图指示" class="headerlink" title="创建目标小地图指示"></a>创建目标小地图指示</h3><ol><li><p>打开W_MiniMap，扩展Widget显示内容，注意<strong>TargetDirection</strong>属性<strong>Pivot</strong>的设置，需要根据Angle作调整,使其无论如何旋转，都能正确显示位置，层级面板作如下修改<img src='https://img-blog.csdnimg.cn/20201021173858989.png'>预览效果<img src='https://img-blog.csdnimg.cn/20201021174021728.png'></p></li><li><p>打开QuestManager，创建纯函数[void] DistanceToTarget(Integer),用于计算角色到目标的空间距离；<img src='https://img-blog.csdnimg.cn/20201021174336258.png'></p></li><li><p>创建函数[void] UpdateTargetDirection()，用于更新目标相对于角色的所在方位；<img src='https://img-blog.csdnimg.cn/2020102117461731.png'></p></li><li><p>打开函数AddQuest,在末尾设置CurrentQuest=LocalQuest;</p></li><li><p>创建自定义事件OnSwitchSubGoalInfo，用于点击子任务列表时，根据当前选择的子任务（是否为Search任务），显示和隐藏目标距离和方位；<img src='https://img-blog.csdnimg.cn/20201021175129176.png'><img src='https://img-blog.csdnimg.cn/20201021175154953.png'></p></li><li><p>创建自定义事件OnPlayerMove，用于角色移动时更新搜寻目标距离和方位信息；<img src='https://img-blog.csdnimg.cn/202010211755540.png'></p></li><li><p>打开RPG_PlayerController，在移动事件末尾添加OnPlayerMove事件的调用；</p></li></ol><h2 id="Money互动"><a href="#Money互动" class="headerlink" title="Money互动"></a>Money互动</h2><ol><li>打开W_CharacterBorder，添加一个Horizatal Box，添加Money图标和文本；</li><li>打开Char_Shibi，创建函数[void]CountMoney()，用于更新Money文本；<img src='https://img-blog.csdnimg.cn/20201021213916456.png'></li><li>创建自定义事件[void] GetMoney(Integer)，使用TimerHandle控制CountMoney函数的循环调用；<img src='https://img-blog.csdnimg.cn/20201021214258222.png'></li><li>打开Object_Treasure事件图表，在Event OnInteractWith末尾添加GetMoney事件的调用，可实现宝箱打开金币旋转动画结束后，自动增加Money的值；</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201021165022723.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：任务坐标，Money互动等;&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(七)</title>
    <link href="http://example.com/2020/10/20/RPG-Dev-Log-7/"/>
    <id>http://example.com/2020/10/20/RPG-Dev-Log-7/</id>
    <published>2020-10-20T13:19:37.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：AI初讲，BehaviorTree–Patrol等;</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="角色边界跳跃"><a href="#角色边界跳跃" class="headerlink" title="角色边界跳跃"></a>角色边界跳跃</h2><ol><li>在场景中添加NavLinkProxy，设置PointLink[0].Left和PointLinks[0].Right在场景中的位置；</li><li>打开细节面板，按照实际情况将Simple Link和Smart Link Direction都设置为Right to Left，将Area Class都设置为NavArea_Default;<img src='https://img-blog.csdnimg.cn/20201020213951911.png'></li></ol><h2 id="AI行为树初讲"><a href="#AI行为树初讲" class="headerlink" title="AI行为树初讲"></a>AI行为树初讲</h2><h3 id="PatrolPath"><a href="#PatrolPath" class="headerlink" title="PatrolPath"></a>PatrolPath</h3><ol><li>清除场景中的所有Block Volume;</li><li>创建Actor [BP_PatrolPath],添加组件Scene、Billboard、Spine;</li><li>进入事件图表，创建变量CloseLoop（Boolean),在构造函数中设置ClosedLoop;<img src='https://img-blog.csdnimg.cn/20201020215735408.png'></li><li>CloseLoop可用于设置AI巡逻路线是否闭环；<img src='https://img-blog.csdnimg.cn/20201020220053700.png'></li><li>在场景中添加BP_PatrolPath，并自定义路线；<img src='https://img-blog.csdnimg.cn/20201020220243597.png'></li></ol><h3 id="PatrolComponent"><a href="#PatrolComponent" class="headerlink" title="PatrolComponent"></a>PatrolComponent</h3><ol><li>创建Component [PatrolComponent],添加变量PatrolPath(BP_PatrolPath)、PatrolIndex(Integer)、RevereDirection(Boolean);</li><li>创建纯函数[Vector] GetSpinePointLocation(Integer)，用于获取巡逻路线各个节点在世界坐标系中的位置；<img src='https://img-blog.csdnimg.cn/20201020220912376.png'></li><li>创建函数[void] UpdatePatrolIndex()，用于实时更新PatrolIndex；当ColoseLoop=true时，实现闭环寻路；当CloseLoop=false时，实现来回寻路；<img src='https://img-blog.csdnimg.cn/20201020221021193.png'></li><li>为BP_RPG_Character添加组件PatrolComponent;</li><li>点击场景中的巡逻NPC，将场景中的PatrolPath指定给NPC;</li></ol><h3 id="BehaviorTree–Patrol"><a href="#BehaviorTree–Patrol" class="headerlink" title="BehaviorTree–Patrol"></a>BehaviorTree–Patrol</h3><ol><li><p>创建Enum [Behaviors] = {Idle,Patrol,Hit,Ability};</p></li><li><p>创建BehaviorTree [BT_NPC]；</p></li><li><p>创建BlackBoard [BB_Base],新建Keys [Behaviors],类型为Enum Behaviors;</p></li><li><p>新建Service [BTS_UpdateBehaviorTree],添加变量BehaviorKey(Blackboard Key),添加宏[Exec] SetBehavior(Behaviors,Exec),将BehaviorKey设置为枚举值；<img src='https://img-blog.csdnimg.cn/20201020222511510.png'></p></li><li><p>在Event Receive Tick AI中调用SetBehavior，选择枚举类型为Patrol;<img src='https://img-blog.csdnimg.cn/20201020222734181.png'></p></li><li><p>新建Task [BTTask_Patrol],添加事件Event Receive Execute AI和Event Receive Abort AI,用于AI行为的执行和中断；<img src='https://img-blog.csdnimg.cn/20201020223107766.png'></p></li><li><p>打开BT_NPC，建立Root——Selector(Service)——Sequence(Decorator)——Leaf(Task);</p><blockquote><p>行为树节点</p><p>一、Composite组合节点：</p><p>1、Selector</p><p>　　要求比较低：只要有一个子节点成功就可以了。</p><p>　　只要子节点有一个返回true，则停止执行其它子节点，并且Selector返回true。如果所有子节点都返回false，则Selector返回false。</p><p>2、Sequence</p><p>　　要求比较高：期望所有子节点都成功。</p><p>　　只要有一个子节点返回false，则停止执行其它子节点，并且Sequence返回false。如果所有子节点都返回true，则Sequence返回true。</p><p>二、Task叶子：</p><p>　　实际执行操作，不含输出链接。</p><p>三、Decorator装饰节点</p><p>　　依附于其它节点，条件节点：如果返回true则执行位于“Decorator”下面的节点，否则就不执行。</p><p>四、Services服务节点</p><p>　　只能附加在Composite组合节点上，只要其附加的节点被执行，Services节点就会被执行，通常用来检查和更新黑板。</p></blockquote><img src='https://img-blog.csdnimg.cn/20201020223938437.png'></li><li><p>选取父类AIController，创建蓝图AIC_NPCController,进入蓝图，在EventBeginPlay添加BlackBoard [BB_Base]和BehaviorTree [BT_NPC];<img src='https://img-blog.csdnimg.cn/20201020214613446.png'></p></li><li><p>选择场景中的NPC，设置</p><p>Animation Mode=Use Animaion Blueprint;</p><p>Pawn&gt;Auto Possess AI = Placed in World or Spawned,AI Controller Class = AIC_NPCController;</p></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/2020102021303566.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：AI初讲，BehaviorTree–Patrol等;&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(六)</title>
    <link href="http://example.com/2020/10/20/RPG-Dev-Log-6/"/>
    <id>http://example.com/2020/10/20/RPG-Dev-Log-6/</id>
    <published>2020-10-20T05:33:47.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：创建NPC，骨骼重定向，任务互动发放等；</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p><p>虚幻商城[Generic NPC Anim Pack]</p><p>虚幻商城[Infinity Blade:Warriors]</p><p>虚幻商城[Advanced Locomotion System]</p><p>内置Package[Mannequin]添加组件S</p><p>Adobe官网<a href="https://www.mixamo.com/">Mixamo</a></p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：圆、问号]</p><h2 id="创建NPC"><a href="#创建NPC" class="headerlink" title="创建NPC"></a>创建NPC</h2><ol><li>打开BP_RPG_Character，删除组件MapArm及其附属组件ChildActor;</li><li>以BP_RPG_Character为父类，创建蓝图BP_RPG_NPC;</li><li>下载地图指示图标，右键Apply Paper2D Texture Settings,并Create Sprite。将圆形图标添加到NPC的PaperSprite；</li><li>为BP_RPG_NPC添加组件SpringArm及其附属组件ChildActor,ChildActor Class选取MiniCapture;</li><li>打开PaperSprite，取消勾选Owner No See。并打开事件图表，添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201020140456848.png'></li><li>以BP_RPG_NPC为父类，创建蓝图BP_NPC_Warriors,将SK_CharM_Pit导入进来；</li></ol><h2 id="NPC骨骼重定向"><a href="#NPC骨骼重定向" class="headerlink" title="NPC骨骼重定向"></a>NPC骨骼重定向</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ol><li>打开SK_CharM_Pit的Retarget Manager,在SetupRig项目选择引擎默认的Humanoid人形骨骼；</li><li>点击AutoMap，自动匹配和建立骨骼映射，ShowBase/ShowAdvanced可用于查看基本骨骼和精细骨骼映射关系；</li><li>打开UE4_Mannequin_Skeleton，同样选取rig为Humanoid人形骨骼，自动建立骨骼映射，在ManageRetargetSource项目Add重定向源SK_Mannequin;</li><li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为SK_Mannequin_Skeleton，并确保base pose一致（Here is Apos)；<img src='https://img-blog.csdnimg.cn/20201020143635944.png'></li><li>将重定向后生成的动画添加至NPC蓝图即可；</li></ol><h3 id="进阶篇（Mixamo"><a href="#进阶篇（Mixamo" class="headerlink" title="进阶篇（Mixamo)"></a>进阶篇（Mixamo)</h3><ol><li>进入虚幻商城[Advanced Locomotion System]，可下载Tpos模型[ALS_Mannequin_T_Pose]；</li><li>打开ALS_Mannequin_T_Pose，选取CurrentPose创建PoseAssets[UE4_PoseAsset];</li><li>打开Apos的小白人骨骼模型，在Manage Retarget Base Pose项目，点击Modify,选择UE4_PoseAsset为当前pose,并import进来；</li><li>打开Mixamo官网下载的模型，手动建立骨骼映射；</li><li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为maria_j_j_ong_Skeleton，并确保base pose一致（Here is Tpos)；<img src='https://img-blog.csdnimg.cn/20201020150458513.png'></li></ol><h2 id="任务互动发放"><a href="#任务互动发放" class="headerlink" title="任务互动发放"></a>任务互动发放</h2><ol><li><p>创建Widget[W_NameForNPC]，</p><p>层级面板<img src='https://img-blog.csdnimg.cn/2020102015102250.png'>,</p><p>预览效果<img src='https://img-blog.csdnimg.cn/20201020151116574.png'></p></li><li><p>打开父类BP_RPG_Character，添加组件Widget，并在子类BP_RPG_NPC中添加Widget Class为W_NameForNPC，设置Space=Screen;</p></li><li><p>添加Sphere碰撞组件，设置碰撞预设;<img src='https://img-blog.csdnimg.cn/20201020151809375.png'></p></li><li><p>添加NPC互动效果蓝图 <img src='https://img-blog.csdnimg.cn/20201020152018538.png'></p></li><li><p>打开Char_Shibi,创建事件调度OnInteract，将与E键盘事件关联；</p></li><li><p>打开BP_RPG_NPC,创建自定义事件OnInteract，用于判断角色与NPC交互时，NPC身上是否有未分发的任务<img src='https://img-blog.csdnimg.cn/20201020152724167.png'></p></li><li><p>打开Char_Shibi，创建事件调度UpdateLevelForQuest(Integer),在UpLevel之后调用；</p></li><li><p>打开BP_RPG_NPC,创建变量QuestInLevel(Map)，将Level映射到Quest类。创建自定义事件UpdateQuest(Integer),用于在角色升级后，判断NPC身上是否产生新的任务；<img src='https://img-blog.csdnimg.cn/20201020153139435.png'></p></li><li><p>复制BP_MasterQuest两份，命名为BP_FirstEventQuest和BP_FirstSideQuest，并修改任务信息；</p></li></ol><h2 id="UI动画添加"><a href="#UI动画添加" class="headerlink" title="UI动画添加"></a>UI动画添加</h2><ol><li>打开W_Quest，为Border创建HideAll动画；<img src='https://img-blog.csdnimg.cn/20201020154300252.png'></li><li>为Text创建Text动画；<img src='https://img-blog.csdnimg.cn/20201020154331675.png'></li><li>打开W_SubGoal，为Border创建Show动画；<img src='https://img-blog.csdnimg.cn/20201020154514839.png'></li><li>打开W_Quest事件蓝图，添加宏[Exec] PlayHideAll(Exec,Boolean)，组织和关联HideAll、Text、Show动画执行时机<img src='https://img-blog.csdnimg.cn/20201020154615593.png'></li><li>创建自定义事件PlayQuest调用PlayHideAll，并在UpdateQuest末尾添加调用;</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201020134241578.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：创建NPC，骨骼重定向，任务互动发放等；&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(五)</title>
    <link href="http://example.com/2020/10/18/RPG-Dev-Log-5/"/>
    <id>http://example.com/2020/10/18/RPG-Dev-Log-5/</id>
    <published>2020-10-18T04:23:00.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：跳跃动作制作，创建任务系统（开篇）</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>虚幻商城[Advanced Mission And Notification System]</p><h2 id="跳跃动作制作"><a href="#跳跃动作制作" class="headerlink" title="跳跃动作制作"></a>跳跃动作制作</h2><ol><li>打开ABP_Shibi事件图表，将Is Falling返回值保存至变量IsInAir;</li><li>进入状态机，添加Idle_Move&lt;=&gt;Jump状态过渡，并将过渡规则与IsInAir关联；</li><li>进入Jump状态，新建状态机Jump，点击进入，设置Entry-&gt;JumpStart=&gt;Loop=&gt;JumpEnd状态过渡，并将过渡规则设置为自动；</li><li>为JumpStart、Loop、JumpEnd添加Jump_Start、Jump_Apex、Jump_Land,并调整播放速率；</li><li>打开Char_Shibi事件图表，添加Space Bar键盘事件，使得角色获得二段跳能力；<img src='https://img-blog.csdnimg.cn/20201018130500837.png'></li><li>打开CharacterMovement细节面板，设置Character Movement:Jump/Falling，Jump Z Velocity=620，Air Control=0.5;</li></ol><h2 id="创建任务系统（开篇）"><a href="#创建任务系统（开篇）" class="headerlink" title="创建任务系统（开篇）"></a>创建任务系统（开篇）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建枚举E_QuestCategories = {主线任务，支线任务，副本任务}；</li><li>创建枚举E_Regions = {冰岛，洞穴，香格里拉}；</li><li>创建枚举E_SubGoalType = {Custom,Hunt,Search,Talk};</li><li>创建结构体S_QuestReward = {Money(Integer),Experience(Integer),Prestige(Integer)};</li><li>创建结构体S_TargetLocation = {HasLocation?(Boolean),Location(Vector)};</li><li>创建结构体S_SubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018132339967.png'></li><li>创建结构体S_QuestInfo;<img src='https://img-blog.csdnimg.cn/20201018132440276.png'></li></ol><h3 id="创建任务实例的父类"><a href="#创建任务实例的父类" class="headerlink" title="创建任务实例的父类"></a>创建任务实例的父类</h3><h4 id="变量创建"><a href="#变量创建" class="headerlink" title="变量创建"></a>变量创建</h4><ol><li>创建Actor BP_MasterQuest,作为创建任务实例的父类；</li><li>创建变量QuestInfo(S_QuestInfo)，用于记录所有<strong>Quest</strong>信息；</li><li>创建变量StartSubGoalIndices(Integer [])，用于记录开始<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li><li>创建变量CurrentSubGoalIndices(Integer [])，用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li><li>创建变量CurrentHuntedAmount(Integer[])，用于记录当前猎杀数量；</li><li>创建变量CurrentSubGoalInfo(S_SubGoalInfo []),用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>信息；</li><li>创建变量SelectedSubGoalIndex(Integer)，用于记录当前选择的<strong>SubGoal</strong>索引；</li></ol><h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><ol><li>创建函数void UpdateSubGoalInfo(),用于根据CurrentSubGoalIndices，更新CurrentSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201018135432102.png'></li><li>创建函数void SetopStartingSubGoals()，用于设置CurrentSubGoalIndices,并调用UpdateSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018135750624.png'></li><li>创建函数Boolean GoToNextSubGoal()，用于判断当前Quest是否还有SubGoal，若有，则将NextIndex保存至CurrentSubGoalIndices，并返回true;<img src='https://img-blog.csdnimg.cn/20201018140354801.png'></li></ol><h3 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h3><h4 id="创建W-SubGoal"><a href="#创建W-SubGoal" class="headerlink" title="创建W_SubGoal"></a>创建W_SubGoal</h4><ol start="2"><li><p>创建Widget [W_SubGoal],</p><p>层级面板如下<img src='https://img-blog.csdnimg.cn/20201018141429316.png'>,</p><p>最终效果<img src='https://img-blog.csdnimg.cn/20201018141521486.png'>;</p></li><li><p>打开事件图表</p><p><strong>创建变量</strong></p><p>W_Quest_SubGoalInfo(S_SubGoalInfo)，</p><p>W_Quest_AssignedQuest(BP_MasterQuest),</p><p>W_Quest(W_Quest),</p><p>SubGoalIndex(Integer),</p><p>SubGoalInfo(Text);</p><p><strong>创建函数</strong></p><p>void Update(),用于根据W_Quest_SubGoalInfo从W_Quest_AssignedQuest中获取QuestInfo，并更新Text;<img src='https://img-blog.csdnimg.cn/20201018143047970.png'></p><p><strong>函数调用</strong></p><p>事件开始构造时调用Update()，点击SelectedButton时调用W_Quest中的SelectSubGoal()；</p></li></ol><h4 id="创建W-Quest"><a href="#创建W-Quest" class="headerlink" title="创建W_Quest"></a>创建W_Quest</h4><ol><li><p>创建Widget [W_Quest]，</p><p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201018144005433.png'></p><p>最终效果<img src='https://img-blog.csdnimg.cn/20201018144100772.png'>;</p></li><li><p>打开事件图表</p><p><strong>创建变量</strong></p><p>SubGoalWidgets(W_SubGoal),</p><p>AssignedQuest(BP_MasterQuest),</p><p>SelectedSubGoal(W_SubGoal);</p><p><strong>创建函数</strong></p><ol><li><p>void GenerateSubGoal(),用于清空SubGolaVerticalBox，并从AssignedQuest中获取CurrentSubGoalInfo,循环添加至SubGolaVerticalBox;<img src='https://img-blog.csdnimg.cn/20201018145035536.png'></p></li><li><p>void UpdateCurrentSubGoal(),用于更新SubGoalIcon、SubGoalType、SubGoalInfo等控件信息；<img src='https://img-blog.csdnimg.cn/20201018152129831.png'></p></li><li><p>void SelectSubGoal(W_SubGoal)，用于激活SelectedButton,并调用UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/202010181515354.png'></p></li><li><p>void UpdateQuest(Quest),用于从AssignedQuest中获取CurrentSubGoalInfo，根据任务Categories设置文本和任务图标样式，并调用GenerateSubGoal和UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/20201018151930868.png'></p></li></ol></li></ol><h3 id="创建QuestManager"><a href="#创建QuestManager" class="headerlink" title="创建QuestManager"></a>创建QuestManager</h3><ol><li><p>创建Actor Componet [QuestManager]，并添加至Char_Shibi;</p></li><li><p>创建变量</p><p>CurrentQuest(BP_MasterQuest),</p><p>AllQuests(BP_MasterQuest[] Object reference),</p><p>AllQuestClasses(BP_MasterQuest[] class reference),</p><p>Shibi(Char_Shibi);</p></li><li><p>创建函数void AddQuest(BP_MasterQuest),用于从所有Quest class中添加、生成Quest Actor实例,并调用BP_MasterQuest.SetupStartingSubGoals和W_Quest.UpdateQuest;<img src='https://img-blog.csdnimg.cn/20201018153733195.png'></p></li></ol><h3 id="绑定Q键盘事件"><a href="#绑定Q键盘事件" class="headerlink" title="绑定Q键盘事件"></a>绑定Q键盘事件</h3><img src='https://img-blog.csdnimg.cn/20201018154325823.png'><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201018123029836.png'><img src='https://img-blog.csdnimg.cn/20201018123051461.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：跳跃动作制作，创建任务系统（开篇）&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(四)</title>
    <link href="http://example.com/2020/10/14/RPG-Dev-Log-4/"/>
    <id>http://example.com/2020/10/14/RPG-Dev-Log-4/</id>
    <published>2020-10-14T09:04:18.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：自动回复系统，迷你小地图制作，IceLands场景导入等。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>UI素材来源：</p><p>虚幻商城[Infinity Blade IceLands]</p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：目标]</p><h2 id="自动回复系统"><a href="#自动回复系统" class="headerlink" title="自动回复系统"></a>自动回复系统</h2><ol><li>打开W_Level，创建Event Dispatchers(事件调度器) UpdateLevel(Integer)，并在CharacterLevel更新后调用;</li><li>打开人物蓝图Char_Shibi，创建自定义事件[void] UpLevel(Integer),用于升级后更新血量/蓝条/耐力值上限,并将W_Level中有关升级粒子动画特效的蓝图迁移整合；<img src='https://img-blog.csdnimg.cn/20201014174148886.png'></li><li>修改[void] ModifyAttribute(E_Attribute,Float)为[void] ModifyAttribute(E_Attribute,Float,Float),扩展函数功能，第三个参数MaxValue用于更新升级后的血量/蓝条/耐力值上限，思路与ModifyValue类似；</li><li>在Event BeginPlay事件末尾绑定事件调度器UpdateLevel至自定义事件UpLevel;<img src='https://img-blog.csdnimg.cn/20201014174040200.png'></li><li>打开W_Level事件图表，将GetXP事件后的结点折叠至图表LoopLevel;</li><li>打开W_PC_Main事件图表，删除Event Construct后有关获取W_Level等自定义组件的节点；</li><li>打开S_Attribute，添加RegenInterval[Float]（回复间隔）、MaxRegenTime[Float]（最大回复时间）、RegenFunctionName[String]（回复回调函数名）、RegenTimerHandle[TimerHandle]（回复TimerHandle);</li><li>打开Char_Shibi，设置Attributes，单次回复量=MaxValue*(RegenInterval/MaxRegenTime)，按照公式，设置数值，使得单次回复量耐力值&gt;血量&gt;灵力；</li><li>创建回调函数[void]HealthRegenTick()、[void]ManaRegenTick()、[void]StaminaRegenTick()回调函数，用于脱战状态和战斗状态回复数值计算，三个函数仅参数不同；<img src='https://img-blog.csdnimg.cn/20201027161819931.png'></li><li>创建函数[void] HandleRegeneration(E_Attribute)，当状态回满时，使用TimerHandle中断回调函数;<img src='https://img-blog.csdnimg.cn/20201027214351835.png'></li><li>创建自定义事件Regenerations,在Event BeginPlay调用，用于循环更新Health/Mana/Stamina相关值，事件末尾调用HandleRegeneration，启用和中止相关tick函数；<img src='https://img-blog.csdnimg.cn/20201014180647554.png'></li><li>函数ModifyAttribute末尾也添加HandleRegeneration的调用，每次修改后都进行一次TimerHandle核对；</li></ol><h2 id="迷你小地图制作"><a href="#迷你小地图制作" class="headerlink" title="迷你小地图制作"></a>迷你小地图制作</h2><ol><li>创建Render Target [MiniMap],右键创建Material [M_MiniMap_Mat]，设置Material Domain=User Interface,Blend Mode=Translucent，编辑蓝图如下;<img src='https://img-blog.csdnimg.cn/2020101423132354.png'></li><li>创建材质实例[Inst_MiniMap_Mat];</li><li>选取父类为SceneCapture2D创建蓝图MiniCapture,将TextureTarget设置为[MiniMap],并取消勾选天气、光线、特效的ShowFlags；</li><li>打开人物蓝图BP_RPG_Character，添加SpringArm、ChildActor,调整SpringArm的Rotation和Arm Length；</li><li>导入direction图标，修改Compression Settings=UserInterface2D(RGBA)，Texture Group=UI，右键创建sprite；</li><li>返回BP_RPG_Character，添加PaperSprite，将刚创建的direction_sprite添加进来，调整rotation，修改颜色，并将碰撞预设设为NoCollision,并勾选Render&gt;Owner No See;</li><li>创建Widget [W_MiniMap]，将Inst_MiniMap_Mat以及相关minimap frame添加进来，并调整zOder顺序，根据[W_MiniMap]中的效果修改Inst_MiniMap_Mat中Density和Radius的值；</li><li>在W_MiniMap中添加Plus和Minus按钮，用于缩放地图，设计思路为：获取Actor[MiniCapture]的拷贝，并通过它获取Capture Component 2D,修改FOV Angle;<img src='https://img-blog.csdnimg.cn/20201014232845269.png'></li></ol><h2 id="IceLands场景导入"><a href="#IceLands场景导入" class="headerlink" title="IceLands场景导入"></a>IceLands场景导入</h2><ol><li>将Map [FrozenCove]导入并构建，打开World Settings，设置Game Mode 为RPG_GameMode;</li><li>完成光源的简单布置，光源大小、颜色、数量等，将部分PointLight由Stationary改为Static；</li><li>完成场景地面的延伸扩展，Nav Mesh Bounds的延伸扩展（需勾选Can ever Affect Navigation),为扩展的地面添加Default碰撞预设；</li><li>修改玩家出生点至平台。</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201014171750989.gif'><img src='https://img-blog.csdnimg.cn/2020101417191758.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：自动回复系统，迷你小地图制作，IceLands场景导入等。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(三)</title>
    <link href="http://example.com/2020/10/13/RPG-Dev-Log-3/"/>
    <id>http://example.com/2020/10/13/RPG-Dev-Log-3/</id>
    <published>2020-10-13T13:30:26.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：人物等级属性绑定，经验条动画效果等。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>UI素材来源：</p><p>虚幻商城[Advanced Mission And Notification System]</p><p><a href="http://www.aigei.com/">爱给网</a> [SlicedImages]</p><h2 id="经验条动画效果"><a href="#经验条动画效果" class="headerlink" title="经验条动画效果"></a>经验条动画效果</h2><ol><li><p>创建Widget [W_Level]，涉及素材资源：进度条和经验徽章边框,</p><p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201013221953333.png'></p><p>最终效果,<img src='https://img-blog.csdnimg.cn/20201013222300719.png'></p></li><li><p>创建HideXPBar动画(0.5s，第一帧X轴缩放为0，最后一帧为1);<img src='https://img-blog.csdnimg.cn/20201013222531735.png'></p></li><li><p>打开Event Graph，事件构造时绑定Character Level 至Level Text;</p></li><li><p>创建宏 [Exec] PlayAnimation(Exec,Boolean)，用于经验条动画循环播放以及播放模式设置；<img src='https://img-blog.csdnimg.cn/20201013223428875.png'></p></li><li><p>创建函数 [void] IncreaseXP()，用于更新level经验条百分比，此处利用Handle可以在任意位置暂停和恢复运行经验条动画；<img src='https://img-blog.csdnimg.cn/20201013223800968.png'></p></li><li><p>在StarterContent资源包中搜索P_Explosion粒子特效，删除FireBall、Sparks、fire_Light、Smoke效果，更改shockwave参数，达到以下效果；<img src='https://img-blog.csdnimg.cn/20201013225153345.png'></p></li><li><p>搜索Shibi角色升级的相关动画，在合适位置添加粒子特效动画和音效，并以此为基础创建AnimMontage;<img src='https://img-blog.csdnimg.cn/2020101322552387.png'></p></li><li><p>打开控件蓝图W_PC_Main，关联Shibi和W_Level，以便获取character movement;</p></li><li><p>创建自定义事件 void GetXP(Float)，调用PlayAnimation和IncreaseXP，完成经验的增加，等级的更新，经验条上限更改，以及升级时添加动画蒙太奇（蓝图较复杂，不再展示）；</p></li><li><p>打开人物蓝图Char_Shibi，添加Key F键盘事件，调用自定义事件GetXP。</p></li></ol><h2 id="任务等级属性绑定"><a href="#任务等级属性绑定" class="headerlink" title="任务等级属性绑定"></a>任务等级属性绑定</h2><h3 id="血条-蓝条材质球创建"><a href="#血条-蓝条材质球创建" class="headerlink" title="血条/蓝条材质球创建"></a>血条/蓝条材质球创建</h3><ol><li><p>创建Material，Material Domain设置为User Interface，Blend Mode设置为Masked,导入uf_fill_green（填充效果图），相关蓝图如下；<img src='https://img-blog.csdnimg.cn/20201013230852397.png'> <img src='https://img-blog.csdnimg.cn/20201013230948299.png'></p></li><li><p>创建材质实例Inst_HealthBar和HealthRemove，修改公开变量Texture 、Scaler(PercentLeft、PercentRight)、Vector(Color)；</p></li><li><p>用同样的方法复制创建Inst_ManaBar和Inst_ManaRemove;</p></li></ol><h3 id="血条-蓝条-角色Border控件蓝图创建"><a href="#血条-蓝条-角色Border控件蓝图创建" class="headerlink" title="血条/蓝条/角色Border控件蓝图创建"></a>血条/蓝条/角色Border控件蓝图创建</h3><ol><li><p>创建Widget [W_HealthBar]，</p><p>层级面板如下，<img src='https://img-blog.csdnimg.cn/2020101323190811.png'></p><p>最终效果；<img src='https://img-blog.csdnimg.cn/20201013232000940.png'></p></li><li><p>用同样的方法复制一份，修改参数命名为W_ManaBar;</p></li><li><p>创建Widget [W_CharacterBorder]，整合frame、HealthBar、ManaBar、StaminaBar、LevelText&amp;Border、Figure&amp;Border、BuffBox，</p><p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201013232626224.png'></p><p>最终效果；<img src='https://img-blog.csdnimg.cn/20201013232731899.png'></p></li></ol><h3 id="Shibi人物蓝图修改"><a href="#Shibi人物蓝图修改" class="headerlink" title="Shibi人物蓝图修改"></a>Shibi人物蓝图修改</h3><ol><li>修改[S_Attribute] UpdateAttribute(E_Attribute)为[void] UpdateAttribute(E_Attribute)，扩展函数功能（由原先的计算和更新血球百分比，动态颜色，扩展至Mana、Stamina，函数核心逻辑不变；<img src='https://img-blog.csdnimg.cn/20201013233125525.png'></li><li>修改[void] SetupAttributeBars()，扩展函数功能（由原先的Health、Mana扩展至Stamina);<img src='https://img-blog.csdnimg.cn/20201013233517102.png'></li><li>修改Num-/+ 键盘事件，测试扩展至Mana、Stamina;<img src='https://img-blog.csdnimg.cn/20201013233813393.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201013220531552.gif'><img src='https://img-blog.csdnimg.cn/20201013220800638.gif'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：人物等级属性绑定，经验条动画效果等。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(二)</title>
    <link href="http://example.com/2020/10/12/RPG-Dev-Log-2/"/>
    <id>http://example.com/2020/10/12/RPG-Dev-Log-2/</id>
    <published>2020-10-12T09:33:57.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：UI血条创建；绑定角色属性等。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="UI血条创建"><a href="#UI血条创建" class="headerlink" title="UI血条创建"></a>UI血条创建</h2><p>UI素材来源：虚幻商城[User Interface Kit]</p><h3 id="材质球制作"><a href="#材质球制作" class="headerlink" title="材质球制作"></a>材质球制作</h3><ol><li>创建Material [M_GlassBall]，将gb（T5,include frame,gloss,over) 拖拽进材质球蓝图;</li><li>创建Material Function [MF_Vertical]，用于处理血球垂直方向的颜色线性渐变，此处Clamp限制Alpha(0~1)，减少性能消耗；<img src='https://img-blog.csdnimg.cn/20201012182956977.png'></li><li>打开[M_GlassBall]，完成第一部分蓝图，涉及UV平衡器（Panner）、图像混合模式（Blend Overlay)、插值计算等,完成Fill (V3)参数传递<img src='https://img-blog.csdnimg.cn/20201012183538901.png'></li><li>完成第二部分蓝图，MF_Vertical—&gt;M_GlassBall，这部分主要设计血球的框架和形状，Ceil用于向上取整<img src='https://img-blog.csdnimg.cn/20201012184100410.png'></li><li>创建材质实例Inst_GlassBall,设置Color、Intensity（强度）、Percentage（血量百分比）等参数</li></ol><h3 id="控件蓝图设计"><a href="#控件蓝图设计" class="headerlink" title="控件蓝图设计"></a>控件蓝图设计</h3><ol><li>创建Widget Blueprint [W_ActionBar]，删除默认的canvas panel，设置为custom模式，添加Scale Box,组件结构如下<img src='https://img-blog.csdnimg.cn/20201012181046997.png'>Textures涉及:actionbar frame(T3,include L ,R,Center);</li><li>创建Widget Blueprint [W_GlassBall]，同上，从User Created分类下，在Scale Box内添加预设的Inst_GlassBall，添加Event Construct事件，用于设置血球颜色以便于灵力球的添加和血量动态颜色；<img src='https://img-blog.csdnimg.cn/20201012185331871.png'></li><li>创建Widget Blueprint [W_PC_Main]，添加预设的Action Bar以及Glass Ball，并调整anchors,Size,Alignment,etc;</li><li>打开Char_Shibi人物蓝图，在Event Graph添加W_PC_Main控件即可。</li></ol><h2 id="绑定角色属性"><a href="#绑定角色属性" class="headerlink" title="绑定角色属性"></a>绑定角色属性</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>准备工作：创建枚举[E_Attribute]=[None,Health,Mana,Stamain],创建结构体[S_Attribute]=[CurrentValue(Float),MinValue(Float),MaxValue(Float),ClassBallWidget(W Glass Ball)];</li><li>核心数据结构：E_Attribute 到 S_Attribute Map 映射关系；</li><li>函数[S_Attribute] GetAttribute(E_Attribute),用于根据键值对获取某一属性的相关值；</li><li>函数[void] SetAttribute(E_Attribute,S_Attribute),用于添加新的属性键值对；</li><li>函数[void] SetupAttributeBars()，实装Health&amp;Mana等属性绑定；</li><li>函数[S_Attribute] UpdateAttribute(E_Attribute),用于计算和更新血球百分比，动态颜色；</li><li>函数[void] ModifyAttribute(E_Attribute,Float),用于伤害显示，同时调用4、6。</li></ol><h3 id="受伤-回血实装"><a href="#受伤-回血实装" class="headerlink" title="受伤/回血实装"></a>受伤/回血实装</h3><ol><li>GetAttribute<img src='https://img-blog.csdnimg.cn/20201012195017253.png'></li><li>SetAttribute<img src='https://img-blog.csdnimg.cn/20201012195137455.png'></li><li>SetupAttributeBars<img src='https://img-blog.csdnimg.cn/20201012195223773.png'></li><li>UpdateAttribute<img src='https://img-blog.csdnimg.cn/20201012195331529.png'></li><li>ModiftAttribute<img src='https://img-blog.csdnimg.cn/20201012195518275.png'></li></ol><h3 id="受伤-回血数字显示"><a href="#受伤-回血数字显示" class="headerlink" title="受伤/回血数字显示"></a>受伤/回血数字显示</h3><ol><li>创建Widget [W_DamageText]，添加FadeOut动画，用于伤害数字浮动显示并消失；<img src='https://img-blog.csdnimg.cn/2020101219394440.png'></li><li>打开W_DamageText 事件图表，事件开始构造时播放1s的Fadeout动画,添加自定义事件UpdateValue，用于受伤/回血时不同的文字内容&amp;颜色显示；</li><li>创建Widget Component [WC_OnDamaged],创建自定义事件SetDamageText,内部调用UpdateValue事件；</li><li>打开函数ModifyAttribute，在Health值被修改前将WC_OnDamaged控件调出,并调用自定义事件SetDamageText，将会自动播放FadeOut动画。</li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201012175955500.png'><img src='https://img-blog.csdnimg.cn/20201012180028750.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：UI血条创建；绑定角色属性等。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
  <entry>
    <title>RPG Game开发日志(一)</title>
    <link href="http://example.com/2020/10/11/RPG-Dev-Log-1/"/>
    <id>http://example.com/2020/10/11/RPG-Dev-Log-1/</id>
    <published>2020-10-11T03:53:42.000Z</published>
    <updated>2020-11-16T09:52:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>涉及内容：简单场景创建；鼠标跟随贴花制作；动画蓝图制作；移动操控绑定等。</p><a id="more"></a><h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="简单场景创建"><a href="#简单场景创建" class="headerlink" title="简单场景创建"></a>简单场景创建</h2><ol><li>清理默认物体，如Floor、Capsule等;</li><li>添加Box Brush，Transform&gt;Location=(0,0,0)，Brush Settings &gt; X=5000,Y=5000,Z=800;</li><li>快捷键ALT复制一个，Transform&gt;Location(0,0,50)，Brush Settings &gt; X=4800,Y=4800,Z=700, Brush Type=Subtractive;</li><li>利用Geometry Editing创建几个测试平台、楼梯等；</li><li>添加StarterContent初学者内容包，为场景物体添加材质。</li><li>保存场景为Training至RPG_Game&gt;Maps。</li></ol><img src="https://img-blog.csdnimg.cn/20201011122013690.png"><h2 id="鼠标跟随贴花制作"><a href="#鼠标跟随贴花制作" class="headerlink" title="鼠标跟随贴花制作"></a>鼠标跟随贴花制作</h2><ol><li>图标来源：<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a>  </li><li>添加Goal图标至RPG_Game&gt;Textures；</li><li>创建材质球M_GoalDecal，设置Material Domain=Deferred Decal，Blend Mode=Translucent，Decal Blend Mode = Emissive；</li><li>设置Material蓝图参数；<img src='https://img-blog.csdnimg.cn/20201011123828721.png'></li><li>创建材质实例Inst_GoalDecal，Sets the preview mesh to a plane primitive，修改公开变量Color和EmissiveValue(高光度)；</li><li>以上M_GoalDecal、Inst_GoalDecal添加至RPG_Game&gt;Materials；</li><li>创建Actor BP_GoalDecal至RPG_Game&gt;Actors，添加Decal组件和Box collision，在Event Graph 内添加Begin Overlap(Box)事件。<img src='https://img-blog.csdnimg.cn/20201011124835193.png'></li></ol><h2 id="动画蓝图制作"><a href="#动画蓝图制作" class="headerlink" title="动画蓝图制作"></a>动画蓝图制作</h2><ol><li>骨骼网格体、动画来源：虚幻商城[虚幻争霸：心菲]</li><li>以下将会用到Skeletal Mesh (Shinbi)，Animation Sequence (Shibi_Fwd、Shibi_Idle);</li><li>创建一维混合空间Shibi_BlendSpace1D，Horizontal Axis 命名为 Speed，区间设置为[0,400],0处添加Idle,400处添加Fwd;</li><li>创建动画蓝图ABP_Shibi至RPG_Game&gt;Characters&gt;Animations，新建状态机:Entry-&gt;Idle_Move,新建变量:Speed,设置动画蓝图如下；<img src='https://img-blog.csdnimg.cn/20201011130431251.png'></li><li>进入Event Graph,设置动画蓝图事件如下。<img src='https://img-blog.csdnimg.cn/20201011130521861.png'></li></ol><h2 id="移动操控绑定"><a href="#移动操控绑定" class="headerlink" title="移动操控绑定"></a>移动操控绑定</h2><ol><li>创建Character BP_RPG_Character至RPG_Game&gt;Blueprints，并创建子类Char_Shibi;</li><li>打开Char_Shibi,添加SpringArm和Camera(依附于SpringArm)，设置SpringArm Rotation=(0,-45,0),Target Arm Length=650;</li><li>创建RPG_PlayerController至RPG_Game&gt;Blueprints；</li><li>创建RPG_Game_Mode至RPG_Game&gt;Blueprints,设置Player Controller Class为RPG_PlayerController,Default Pawn Class为Char_Shibi;</li><li>打开项目设置，设置Default GameMode 为RPG_GameMode,Default Maps为Training,添加轴映射MoveForward(W/S)、MoveRight(A/D)、LookUp(Mouse Y)、Turn(Mouse X);</li><li>打开RPG_PlayerController,创建函数CancelMovementCommand,用于处理角色移动状态时销毁鼠标贴花；<img src='https://img-blog.csdnimg.cn/20201011132117897.png'></li><li>Shibi Object获取；<img src='https://img-blog.csdnimg.cn/20201011132352696.png'></li><li>鼠标贴花生成；<img src='https://img-blog.csdnimg.cn/20201011132417698.png'></li><li>移动转向控制。<img src='https://img-blog.csdnimg.cn/20201011133109943.png'><img src='https://img-blog.csdnimg.cn/20201011133157497.png' ><img src='https://img-blog.csdnimg.cn/20201011133223590.png'><img src='https://img-blog.csdnimg.cn/2020101113325827.png'><img src='https://img-blog.csdnimg.cn/20201011133327798.png'></li></ol><h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><img src='https://img-blog.csdnimg.cn/20201012174104608.png'><img src='https://img-blog.csdnimg.cn/20201012174324500.png'>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及内容：简单场景创建；鼠标跟随贴花制作；动画蓝图制作；移动操控绑定等。&lt;/p&gt;</summary>
    
    
    
    <category term="Logs" scheme="http://example.com/categories/Logs/"/>
    
    
    <category term="UE_4.22" scheme="http://example.com/tags/UE-4-22/"/>
    
  </entry>
  
</feed>
