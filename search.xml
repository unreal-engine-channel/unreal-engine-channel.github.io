<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>游戏人工智能:从FSM到Behavior Tree</title>
    <url>/2020/11/01/AI-BehaviorTree/</url>
    <content><![CDATA[<blockquote>
<p>A behavior tree is to express the behavior of artificial intelligence. The behavior tree has a characteristic that is easy to change state transitions than FSM(Finite State Machine).</p>
</blockquote>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以RPG游戏为例，无论是PVE模式还是PVP模式，都会涉及人工智能这个概念。其中包括引导新手的NPC，玩家对战的NPC等。</p>
<h2 id="FSM-Finite-State-Machine"><a href="#FSM-Finite-State-Machine" class="headerlink" title="FSM(Finite State Machine)"></a>FSM(Finite State Machine)</h2><p>双FSM是目前最常用的一样方法，它定义了有限多个状态（行为），用图表来表达状态之间的因果关系。虽然理解状态的组成和转移很容易，但有个问题：状态和转移越多，维护就越困难。</p>
<p><img src='https://img-blog.csdnimg.cn/20201101214601997.png' alt='[Fig.1] FSM'></p>
<h3 id="Fig-1-FSM"><a href="#Fig-1-FSM" class="headerlink" title="[Fig.1] FSM"></a>[Fig.1] FSM</h3><p>图示给出了FSM的一个例子。它由Search、Chase和Attack状态组成，状态转换条件显示在箭头之上。为了改进FSM，实现更加精密的人工智能开发，提出了行为树的概念。它仍然具有类似于FSM的形式，但是即便状态和状态之间的关系再多，管理难度也远小于FSM。它更适合具有复杂行为和功能的智能体。</p>
<h2 id="Behavior-Tree"><a href="#Behavior-Tree" class="headerlink" title="Behavior Tree"></a>Behavior Tree</h2><p><img src='https://img-blog.csdnimg.cn/20201101220407953.png' alt='[Fig.2] Behavior Tree'></p>
<h3 id="Fig-2-Behavior-Tree"><a href="#Fig-2-Behavior-Tree" class="headerlink" title="[Fig.2] Behavior Tree"></a>[Fig.2] Behavior Tree</h3><p>图示给出了一个行为树的例子。这些行为树在PRG/RTS/FPS等类型的游戏中都具备可用性。对于单个对象的行为或控制逻辑，我们认为没有必要使用行为树。</p>
<h3 id="原理和方法"><a href="#原理和方法" class="headerlink" title="原理和方法"></a>原理和方法</h3><p>行为树是通过将AI的角色行为定义为树的方法，通过连接角色行为的条件和因果关系，优先级等对应的节点来完成。 </p>
<h3 id="Unreal-Engine中的BT"><a href="#Unreal-Engine中的BT" class="headerlink" title="Unreal Engine中的BT"></a>Unreal Engine中的BT</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul>
<li>Task：基础节点。</li>
<li>Decorator：定义当前分支返回结果是否为真。</li>
<li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li>
<li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li>
<li>Service：在固定更新频率的黑板上运行。</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20201101222235173.png' alt='[Table 2] Unreal Engine'></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src='https://img-blog.csdnimg.cn/20201101225753418.png' alt='[Fig.5] Unreal Engine Behavior Tree'></p>
<h3 id="Unity-Engine中的BT"><a href="#Unity-Engine中的BT" class="headerlink" title="Unity Engine中的BT"></a>Unity Engine中的BT</h3><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><ul>
<li>Action：基础节点。</li>
<li>Decorator：定义当前分支返回结果是否为真。</li>
<li>Sequence：顺序执行子节点，直到有一个返回失败。如果所有的子节点都返回成功，则该序列也返回成功。</li>
<li>Selector：顺序执行子节点，直到有一个返回成功。如果所有的子节点都返回失败，则该选择器也返回失败。</li>
<li>Priority selector：决定最高优先级的节点。</li>
<li>Parallel: 平行子节点将被同时执行。</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20201101222050462.png' alt='[Table 1] Unity Engine'></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src='https://img-blog.csdnimg.cn/20201101230244379.png' alt='[Fig.6] Unity Engine Behavior Tree'></p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == FAILURE:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selector_node</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">        res = child_list[run_index](owner)</span><br><span class="line">        <span class="keyword">if</span> res == SUCCESS:</span><br><span class="line">            set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> res == RUNNING:</span><br><span class="line">            set_run_index(node_name, run_index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    set_run_index(node_name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FAILURE</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parallel</span>(<span class="params">owner, node_name</span>):</span></span><br><span class="line">    run_index_list = get_run_index(node_name)</span><br><span class="line">    <span class="keyword">if</span> len(run_index_list) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> run_index_list:</span><br><span class="line">            state_dic[index] = child_list[index](owner)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        run_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> run_index &lt; len(child_list):</span><br><span class="line">            state_dic[run_index] = child_list[run_index](owner)</span><br><span class="line">            run_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> state_dic.count(SUCCESS) &gt;= MIN_SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> SUCCESS</span><br><span class="line">    <span class="keyword">elif</span> state_dic.count(FAILURE) &gt;= MIN_FAILURE:</span><br><span class="line">        <span class="keyword">return</span> FAILURE</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> RUNNING</span><br></pre></td></tr></table></figure>
<h3 id="两大引擎中的BT对比-参照UE4"><a href="#两大引擎中的BT对比-参照UE4" class="headerlink" title="两大引擎中的BT对比(参照UE4)"></a>两大引擎中的BT对比(参照UE4)</h3><p>​        两个引擎的行为树具有很多共同点，就是可以很容易地了解一个行为实现的条件和下一个行为是什么。</p>
<p>我们定义一组AI行为：</p>
<ol>
<li><p>[EnemyNotInRange]以AI当前位置为中心，在一定范围内没有基地的情况下，为了寻找基地，AI将自主移动前进。</p>
</li>
<li><p>[EnemyInRange]若在前进途中遇到敌人，则攻击它，受到伤害降低生命值。</p>
</li>
<li><p>[NotHealth]若生命值为0，则死亡，否则继续执行1。</p>
</li>
<li><p>[EnemyBaseInRange]若发现基地，则攻击基地。</p>
</li>
</ol>
<p><img src='https://img-blog.csdnimg.cn/20201101225148412.png'  alt='[Fig.3] Unreal Engine Behavior Tree'></p>
<p><img src='https://img-blog.csdnimg.cn/20201101230351316.png' alt='[Fig.4] Unity Engine Behavior Tree'></p>
<h4 id="行为树为事件驱动型"><a href="#行为树为事件驱动型" class="headerlink" title="行为树为事件驱动型"></a>行为树为事件驱动型</h4><blockquote>
<p>行为树可避免在每帧中执行大量工作。行为树并不会经常检查相关变化是否已经发生，它只会被动地等待在树中引起变化的“事件”。</p>
<p>事件驱动型结构对运行性能和除错大有帮助。如果希望获得这些帮助，必须理解虚幻引擎树的其他不同点，并正确搭建行为树结构。</p>
<p>代码在整个树的每个标记中无需迭代，因此运行性能将大大提升！从概念上而言，我们不需要不停地问“我们到了吗”，只需要轻松休息，会有人来告诉我们“到啦！”</p>
<p>在行为树执行日志中反复查看对行为进行纠错时，最佳的方法是让日志显示相关的变更，不显示无关的变更。在事件驱动型应用中，无需过滤出在树上迭代并选择之前相同行为的无关步骤，因为额外的迭代从开始便并未发生！只有树中执行位置或黑板数值发生的变化会产生影响，不同之处显而易见。</p>
</blockquote>
<h4 id="条件语句并非叶节点"><a href="#条件语句并非叶节点" class="headerlink" title="条件语句并非叶节点"></a>条件语句并非叶节点</h4><blockquote>
<p>在行为树标准模型中，条件语句为 Task 叶节点，除成功和失败外不执行任何操作。虽然也可以使用传统的条件 tasks，但还是强烈推荐您使用 Decorator 系统作为条件语句。</p>
<p>使用 decorators 而非 tasks 作为条件语句有多个明显优点。</p>
<p>首先，条件 decorators 使行为树 UI 显得更加直观易读。条件语句位于其所控制分支树的根部，因此一旦条件语句未被满足，便可直接看到树的哪个部分被“关闭”。此外，所有叶节点均为行动 tasks，因此更容易分辨树在对哪些实际行动下达命令。 在传统模型中，条件语句混于叶节点中，因此需要花更多时间分辨哪些叶节点是条件语句，哪些叶节点是行动。</p>
</blockquote>
<h4 id="并发行为的特殊处理"><a href="#并发行为的特殊处理" class="headerlink" title="并发行为的特殊处理"></a>并发行为的特殊处理</h4><blockquote>
<p>标准行为树通常使用 <strong>Parallel composite</strong> 节点来处理并发行为。Parallel 节点同时执行其所有子项。在一个或多个子项树完成时，特殊规则将决定如何执行（取决于所需行为）。</p>
<p>Parallel 节点不是绝对的多线程（完全同步执行任务）。它们只是概念上一次执行多个任务的方式。它们经常在同一线程上运行，并在一些序列中开始。该序列应为不相关，因为它们全部在同一框架中发生。但有时它也很重要。</p>
<p>UE4 行为树抛弃了复杂 Parallel 节点，使用 <strong>Simple Parallel</strong> 节点和称为 <strong>Services</strong> 的特殊节点，以实现同类行为。</p>
<h4 id="Simple-Parallel-节点"><a href="#Simple-Parallel-节点" class="headerlink" title="Simple Parallel 节点"></a>Simple Parallel 节点</h4><p>Simple Parallel 节点只允许两个子项的存在：一个必为单独任务节点（含可选 decorators）、另一个为一个完整的分支树。</p>
<p>可以将 Simple Parallel 节点理解为：“执行 A 的同时也执行 B。”举例而言：“在攻击敌人时向敌人移动。”基本上来说，A 是主要任务，而 B 是等待 A 完成时执行的次要或补充任务。</p>
<p>有一些选项可以处理同时进行的次要任务（任务 B）。较之于传统 Parallel 节点，该节点在概念上还是相对简单。然而，它支持 Parallel 节点的多数常规用法。</p>
<p>可利用 Simple Parallel 节点简便地进行一些事件驱动型优化。而 Full Parallel 节点的优化则要复杂许多。</p>
<h4 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h4><p><strong>Services</strong> 是与 composite 节点（Selector、Sequence、或 Simple Parallel）相关的特殊节点。它能在每 X 秒注册回呼并执行多个定期发生类型的更新。</p>
<p>举例而言，service 能用于确定哪名敌人是 AI pawn 的最佳追逐目标；与此同时，pawn 在其行为树中继续正常追踪当前敌人。</p>
<p>只有执行仍然处于以 composite 节点（与 service 相关）为根的分支树中时，Services 方为有效。</p>
<h4 id="Decorator-“Observer-Aborts”-属性"><a href="#Decorator-“Observer-Aborts”-属性" class="headerlink" title="Decorator “Observer Aborts” 属性"></a>Decorator “Observer Aborts” 属性</h4><p>标准 Parallel 节点的一个常见用途是不断对条件进行检查，以便在条件无法达成时中止任务。举例而言，有一只猫执行序列，如“摇屁股”或“猛扑”，在老鼠已经逃进洞后，直接放弃任务。如使用 Parallel 节点，有一个子项将检查猫是否可以扑到老鼠，另一子项就是要执行的序列。因为 UE4 行为树是事件驱动型，条件 decorators 将观察数值，并在需要时中止任务。（在该例中，只需要在序列上添加“老鼠是否能被扑到” decorator，然后将 “Observer Aborts” 设为 “Self”。）</p>
</blockquote>
<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p>[1].Myoun-Jae Lee.A Proposal on Game Engine Behavior Tree[J].Journal of Digital Convergence,2016,14(8),415-421.</p>
]]></content>
      <categories>
        <category>Theories</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence</tag>
        <tag>Behavior Tree</tag>
        <tag>Finite State Machine</tag>
      </tags>
  </entry>
  <entry>
    <title>Digital-Image-Processing</title>
    <url>/2021/06/28/Digital-Image-Processing/</url>
    <content><![CDATA[<h2 id="Image-enhancement-in-the-spatial-domain-空间域图像增强"><a href="#Image-enhancement-in-the-spatial-domain-空间域图像增强" class="headerlink" title="Image enhancement in the spatial domain (空间域图像增强)"></a>Image enhancement in the spatial domain (空间域图像增强)</h2><h3 id="Intensity-transformation-灰度变换"><a href="#Intensity-transformation-灰度变换" class="headerlink" title="Intensity transformation (灰度变换)"></a>Intensity transformation (灰度变换)</h3><h4 id="基本灰度变换函数"><a href="#基本灰度变换函数" class="headerlink" title="基本灰度变换函数"></a>基本灰度变换函数</h4><h5 id="Image-negatives-图像反转"><a href="#Image-negatives-图像反转" class="headerlink" title="Image negatives (图像反转)"></a>Image negatives (图像反转)</h5><p>s = L - 1 - r</p>
<h5 id="log-transformation-对数变换"><a href="#log-transformation-对数变换" class="headerlink" title="log transformation (对数变换)"></a>log transformation (对数变换)</h5><p>s = clog(1+r)</p>
<h5 id="power-law-transformation-gamma-correction-幂次变换（gamma校正）"><a href="#power-law-transformation-gamma-correction-幂次变换（gamma校正）" class="headerlink" title="power-law transformation (gamma correction) (幂次变换（gamma校正）)"></a>power-law transformation (gamma correction) (幂次变换（gamma校正）)</h5><p>s = cr^r</p>
<h4 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h4><h5 id="Contrast-stretching-对比拉伸"><a href="#Contrast-stretching-对比拉伸" class="headerlink" title="Contrast stretching (对比拉伸)"></a>Contrast stretching (对比拉伸)</h5><p><img src="https://img-blog.csdnimg.cn/20210629155650684.png"></p>
<h5 id="gray-level-slicing-灰度切割"><a href="#gray-level-slicing-灰度切割" class="headerlink" title="gray-level slicing (灰度切割)"></a>gray-level slicing (灰度切割)</h5><h5 id="bit-plane-slicing-位图切割"><a href="#bit-plane-slicing-位图切割" class="headerlink" title="bit-plane slicing (位图切割)"></a>bit-plane slicing (位图切割)</h5><h4 id="Histogram-Processing-直方图处理"><a href="#Histogram-Processing-直方图处理" class="headerlink" title="Histogram Processing (直方图处理)"></a>Histogram Processing (直方图处理)</h4><h5 id="Histogram-equalization-直方图均衡化"><a href="#Histogram-equalization-直方图均衡化" class="headerlink" title="Histogram equalization (直方图均衡化)"></a>Histogram equalization (直方图均衡化)</h5><p>(1) 统计各灰度级rk的像素数目n k (k=0,1,2,…L-1)<br>(2) 用p(rk)=n k /n 计算图像直方图<br>(3) 用变换函数<img src="https://img-blog.csdnimg.cn/20210629160359854.png"><br>计算映射后输出的灰度级sk，舍入处理得sk’<br>(4)将灰度级为rk的像素灰度级变为sk’<br>(5) 统计映射后新的灰度级sk’的像素数目nk ’<br>(6) 计算输出图像的直方图 </p>
<h5 id="Histogram-matching-specification-直方图规定化（直方图匹配）"><a href="#Histogram-matching-specification-直方图规定化（直方图匹配）" class="headerlink" title="Histogram matching(specification) (直方图规定化（直方图匹配）)"></a>Histogram matching(specification) (直方图规定化（直方图匹配）)</h5><p> (1)求出已知图像的直方图</p>
<p>(2)利用 <img src="https://img-blog.csdnimg.cn/20210629161712194.png">对每一灰度级rk预计算映射灰度级sk.<br> (3)利用<img src="https://img-blog.csdnimg.cn/20210629161734137.png">从给定的Pz(z)得到变换函数G.<br> (4)利用<img src="https://img-blog.csdnimg.cn/20210629161755669.png">对每一个sk值求zk.<br> (5)将灰度级为rk的像素灰度级变为zk.<br> 对于原始图像的每个像素,若像素值为rk,将该值映射到其对应的灰度级sk; 然后映射灰度级sk到最终灰度级zk.</p>
<h3 id="Spatial-filtering-空域滤波"><a href="#Spatial-filtering-空域滤波" class="headerlink" title="Spatial filtering (空域滤波)"></a>Spatial filtering (空域滤波)</h3><h4 id="Smoothing-spatial-filters-平滑空域滤波器"><a href="#Smoothing-spatial-filters-平滑空域滤波器" class="headerlink" title="Smoothing spatial filters (平滑空域滤波器)"></a>Smoothing spatial filters (平滑空域滤波器)</h4><h5 id="Averaging-filter-均值滤波器"><a href="#Averaging-filter-均值滤波器" class="headerlink" title="Averaging filter (均值滤波器)"></a>Averaging filter (均值滤波器)</h5><p>The output (response) of a smoothing, linear spatial filter is simply the average of the pixels contained in the neighborhood of the filter mask. These filters sometimes are called averaging filter. </p>
<p><img src="https://img-blog.csdnimg.cn/2021062916243138.png"></p>
<h5 id="Order-Statistic-Filters-顺序排序滤波器"><a href="#Order-Statistic-Filters-顺序排序滤波器" class="headerlink" title="Order-Statistic Filters (顺序排序滤波器)"></a>Order-Statistic Filters (顺序排序滤波器)</h5><p>Order-statistics filters are nonlinear spatial filters whose response is based on ordering the pixels contained in the image area encompassed by the filter, and then replacing the value of the center pixel with the value determined by the ranking result.</p>
<h5 id="median-filter-中值滤波器"><a href="#median-filter-中值滤波器" class="headerlink" title="median filter (中值滤波器)"></a>median filter (中值滤波器)</h5><p>Replace the value of a pixel by the median of the gray levels in the neighborhood of that pixel.</p>
<h4 id="sharpening-spatial-filters-锐化空域滤波器"><a href="#sharpening-spatial-filters-锐化空域滤波器" class="headerlink" title="sharpening spatial filters (锐化空域滤波器)"></a>sharpening spatial filters (锐化空域滤波器)</h4><h5 id="一阶微分"><a href="#一阶微分" class="headerlink" title="一阶微分"></a>一阶微分</h5><ul>
<li><p>the gradient operator (梯度算子)</p>
<p><img src="https://img-blog.csdnimg.cn/2021062916362410.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629163645554.png"></p>
</li>
<li><p>the Roberts cross-gradient operators (Roberts交叉算子)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629163945506.png"></p>
<p><img src="https://img-blog.csdnimg.cn/2021062916401035.png"></p>
</li>
<li><p>Sobel operators (Sobel算子)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629164038662.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629164103664.png"></p>
</li>
<li><p>Prewitt operators (Prewitt算子)</p>
<p><img src="https://img-blog.csdnimg.cn/2021062916413020.png"></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210629164149919.png"></p>
<h5 id="二阶微分"><a href="#二阶微分" class="headerlink" title="二阶微分"></a>二阶微分</h5><ul>
<li><p>The laplacian operator (拉普拉斯算子)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629163003867.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629163033680.png"></p>
</li>
<li><p>Laplacian-based Enhancement operator (拉普拉斯增强算子)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629163255390.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629163322935.png"></p>
</li>
<li><p>unsharp masking (非锐化掩蔽)</p>
</li>
<li><p>highboost filtering (高提升滤波)</p>
</li>
</ul>
<h2 id="Image-enhancement-in-the-frequency-domain-频域图像增强"><a href="#Image-enhancement-in-the-frequency-domain-频域图像增强" class="headerlink" title="Image enhancement in the frequency domain (频域图像增强)"></a>Image enhancement in the frequency domain (频域图像增强)</h2><h3 id="Fourier-transform-傅里叶变换"><a href="#Fourier-transform-傅里叶变换" class="headerlink" title="Fourier transform (傅里叶变换)"></a>Fourier transform (傅里叶变换)</h3><h4 id="Discrete-Fourier-Transform-离散傅里叶变换DFT"><a href="#Discrete-Fourier-Transform-离散傅里叶变换DFT" class="headerlink" title="Discrete Fourier Transform (离散傅里叶变换DFT)"></a>Discrete Fourier Transform (离散傅里叶变换DFT)</h4><p><img src="https://img-blog.csdnimg.cn/20210629134320105.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629134354229.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629134811667.png"></p>
<ul>
<li><p>Translational property (平移性)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629135229681.png"></p>
</li>
<li><p>Periodic property (周期性)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629135706652.png"></p>
</li>
<li><p>Conjugate symmetric property (共轭对称性)</p>
<p><img src="https://img-blog.csdnimg.cn/20210629135737567.png"></p>
</li>
<li><p>Average property (平均值定理)</p>
<p>令u=0,v=0,则F(0,0)=~f(x,y):</p>
<p><img src="https://img-blog.csdnimg.cn/20210629140040481.png"></p>
</li>
<li><p>Convolution theorem (卷积定理)</p>
</li>
</ul>
<p>  <img src="https://img-blog.csdnimg.cn/20210629141847116.png"></p>
<p>  <img src="https://img-blog.csdnimg.cn/20210629141918104.png"></p>
<p>  令s=-m,t=-n,g(x,y)=f(x,y)*h(x,y):</p>
<p>  <img src="https://img-blog.csdnimg.cn/20210629141702901.png"></p>
<h3 id="频域滤波流程"><a href="#频域滤波流程" class="headerlink" title="频域滤波流程"></a>频域滤波流程</h3><p><img src="https://img-blog.csdnimg.cn/20210629143232377.png"></p>
<h3 id="Low-pass-filtering-低通滤波器"><a href="#Low-pass-filtering-低通滤波器" class="headerlink" title="Low-pass filtering (低通滤波器)"></a>Low-pass filtering (低通滤波器)</h3><h4 id="Ideal-lowpass-filters-理想低通滤波器"><a href="#Ideal-lowpass-filters-理想低通滤波器" class="headerlink" title="Ideal lowpass filters (理想低通滤波器)"></a>Ideal lowpass filters (理想低通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629143940232.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144013339.png"></p>
<h4 id="Butterworth-lowpass-filters-巴特沃斯低通滤波器"><a href="#Butterworth-lowpass-filters-巴特沃斯低通滤波器" class="headerlink" title="Butterworth lowpass filters (巴特沃斯低通滤波器)"></a>Butterworth lowpass filters (巴特沃斯低通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629144115517.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144141403.png"></p>
<h4 id="Gaussian-lowpass-filters-高斯低通滤波器"><a href="#Gaussian-lowpass-filters-高斯低通滤波器" class="headerlink" title="Gaussian lowpass filters (高斯低通滤波器)"></a>Gaussian lowpass filters (高斯低通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629144231223.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144304278.png"></p>
<h3 id="High-pass-filtering-高通滤波器"><a href="#High-pass-filtering-高通滤波器" class="headerlink" title="High-pass filtering (高通滤波器)"></a>High-pass filtering (高通滤波器)</h3><h4 id="Ideal-highpass-filters-理想高通滤波器"><a href="#Ideal-highpass-filters-理想高通滤波器" class="headerlink" title="Ideal highpass filters (理想高通滤波器)"></a>Ideal highpass filters (理想高通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629144444982.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144511267.png"></p>
<h4 id="Butterworth-highpass-filters-巴特沃斯高通滤波器"><a href="#Butterworth-highpass-filters-巴特沃斯高通滤波器" class="headerlink" title="Butterworth highpass filters (巴特沃斯高通滤波器)"></a>Butterworth highpass filters (巴特沃斯高通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629144558939.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144624469.png"></p>
<h4 id="Gaussian-highpass-filters-高斯高通滤波器"><a href="#Gaussian-highpass-filters-高斯高通滤波器" class="headerlink" title="Gaussian highpass filters (高斯高通滤波器)"></a>Gaussian highpass filters (高斯高通滤波器)</h4><p><img src="https://img-blog.csdnimg.cn/20210629144659924.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629144854316.png"></p>
<h3 id="Homomorphic-Filtering-同态滤波"><a href="#Homomorphic-Filtering-同态滤波" class="headerlink" title="Homomorphic Filtering (同态滤波)"></a>Homomorphic Filtering (同态滤波)</h3><h4 id="同态滤波流程"><a href="#同态滤波流程" class="headerlink" title="同态滤波流程"></a>同态滤波流程</h4><p>An image f(x, y) can be expressed as the product of </p>
<p>illumination i(x, y) </p>
<p>and </p>
<p>reflectance components r(x, y):</p>
<p><img src="https://img-blog.csdnimg.cn/2021062914560259.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629145343962.png"></p>
<h4 id="Gray-level-range-compression-灰度范围压缩"><a href="#Gray-level-range-compression-灰度范围压缩" class="headerlink" title="Gray-level range compression (灰度范围压缩)"></a>Gray-level range compression (灰度范围压缩)</h4><h4 id="Contrast-enhancement-对比度增强"><a href="#Contrast-enhancement-对比度增强" class="headerlink" title="Contrast enhancement (对比度增强)"></a>Contrast enhancement (对比度增强)</h4><h2 id="Morphological-image-processing（形态学图像处理）"><a href="#Morphological-image-processing（形态学图像处理）" class="headerlink" title="Morphological image processing（形态学图像处理）"></a>Morphological image processing（形态学图像处理）</h2><h3 id="Dilation-膨胀"><a href="#Dilation-膨胀" class="headerlink" title="Dilation (膨胀)"></a>Dilation (膨胀)</h3><p>在B相对于自身原点的反射对这些元素移位操作的结果与A至少重叠一个元素，B的原点位置的集合。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629131220812.png"></p>
<h3 id="Erosion-腐蚀"><a href="#Erosion-腐蚀" class="headerlink" title="Erosion (腐蚀)"></a>Erosion (腐蚀)</h3><p>在B完全包括在A中时，B的原点位置的集合。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629131029843.png"></p>
<h3 id="Opening-开"><a href="#Opening-开" class="headerlink" title="Opening (开)"></a>Opening (开)</h3><p>复合运算：先腐蚀后膨胀。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629131601431.png"></p>
<h3 id="Closing-闭"><a href="#Closing-闭" class="headerlink" title="Closing  (闭)"></a>Closing  (闭)</h3><p>复合运算：先膨胀后腐蚀。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629131635639.png"></p>
<h3 id="Hit-or-miss-击中与否"><a href="#Hit-or-miss-击中与否" class="headerlink" title="Hit-or-miss (击中与否)"></a>Hit-or-miss (击中与否)</h3><p><img src="https://img-blog.csdnimg.cn/20210629132222221.png"></p>
<h2 id="Image-segmentation（图像分割）"><a href="#Image-segmentation（图像分割）" class="headerlink" title="Image segmentation（图像分割）"></a>Image segmentation（图像分割）</h2><h3 id="Discontinuity（间断性）"><a href="#Discontinuity（间断性）" class="headerlink" title="Discontinuity（间断性）"></a>Discontinuity（间断性）</h3><h4 id="Edge-detection（边缘检测）"><a href="#Edge-detection（边缘检测）" class="headerlink" title="Edge detection（边缘检测）"></a>Edge detection（边缘检测）</h4><h5 id="Laplacian-of-Gaussian（LOG算子）"><a href="#Laplacian-of-Gaussian（LOG算子）" class="headerlink" title="Laplacian of Gaussian（LOG算子）"></a>Laplacian of Gaussian（LOG算子）</h5><p><img src="https://img-blog.csdnimg.cn/20210629115447698.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629115512268.png"></p>
<h5 id="The-Canny-edge-detector-Canny算子"><a href="#The-Canny-edge-detector-Canny算子" class="headerlink" title="The Canny edge detector (Canny算子)"></a>The Canny edge detector (Canny算子)</h5><p>算法的基本步骤：<br>  1）用Gaussian滤波器对图像进行卷积<br>  2）计算图像梯度的幅值和方向<br>  3）对梯度幅值应用非极大值抑制（置零）<br> 4）用双阈值处理和连接分析来检测并连接边缘</p>
<h5 id="Edge-linking-边缘连接"><a href="#Edge-linking-边缘连接" class="headerlink" title="Edge linking (边缘连接)"></a>Edge linking (边缘连接)</h5><h5 id="Hough-transform-霍夫变换"><a href="#Hough-transform-霍夫变换" class="headerlink" title="Hough transform (霍夫变换)"></a>Hough transform (霍夫变换)</h5><p>通过Hough变换可以把在图像空间中的直线检测问题转换到在参数空间的点检测问题。其算法步骤如下：<br>（1）在ρ、θ 的取值范围内对其分别进行m，n等分，设一个二维数组的下标与ρi 、 θj的取值对应；<br>（2）对图像上的边缘点作Hough变换，求每个点在θj (j＝0,1,…,n)对应的ρi (i=0,1,…,m)，判断(ρi ,θj )与哪个数组元素对应．则让该数组元素值加1；<br>（3）比较数组元素值的大小，最大值所对应的（ ρi 、 θj ）就是这些共线点对应的直线方程的参数。</p>
<p>检测到的直线方程为：</p>
<p><img src="https://img-blog.csdnimg.cn/2021062912062728.png"></p>
<h3 id="Similarity（相似性）"><a href="#Similarity（相似性）" class="headerlink" title="Similarity（相似性）"></a>Similarity（相似性）</h3><h4 id="Thresholding（阈值法）"><a href="#Thresholding（阈值法）" class="headerlink" title="Thresholding（阈值法）"></a>Thresholding（阈值法）</h4><h5 id="Basic-global-thresholding（基本全局阈值法）"><a href="#Basic-global-thresholding（基本全局阈值法）" class="headerlink" title="Basic global thresholding（基本全局阈值法）"></a>Basic global thresholding（基本全局阈值法）</h5><p>（1）选取一个初始估计值T；<br>（2）用T分割图像。这样便会生成两组像素集合：G1由所有灰度值大于T的像素组成，而G2由所有灰度值小于或等于T的像素组成。<br>（3）对G1和G2中所有像素计算平均灰度值u1和u2。<br>（4）计算新的阈值：T=(u1 + u2)/2。<br>（5）重复步骤（2）到（4），直到得到的T值之差小于一个事先定义的参数T0。</p>
<h5 id="Otsu’s-method（Otsu法）"><a href="#Otsu’s-method（Otsu法）" class="headerlink" title="Otsu’s method（Otsu法）"></a>Otsu’s method（Otsu法）</h5><p>（1）先计算图像的归一化直方图<br>（2） i表示分类的阈值，也即一个灰度级，从0开始迭代<br>（3通过归一化的直方图，统计0~i 灰度级的像素(背景像素) 所占整幅图像的比例w0，并统计背景像素的平均灰度u0；统计i~255灰度级的像素(前景像素) 所占整幅图像的比例w1，并统计前景像素的平均灰度u1；<br>（4）计算前景像素和背景像素的方差 g = w0<em>w1</em>(u0-u1) (u0-u1)<br>（5） i++，直到i为255时循环结束<br>（6）将最大g相应的i值作为图像的全局阈值</p>
<h5 id="Basic-adaptive-thresholding（基本自适应阈值法）"><a href="#Basic-adaptive-thresholding（基本自适应阈值法）" class="headerlink" title="Basic adaptive thresholding（基本自适应阈值法）"></a>Basic adaptive thresholding（基本自适应阈值法）</h5><h4 id="Region-based-segmentation（基于区域的分割）"><a href="#Region-based-segmentation（基于区域的分割）" class="headerlink" title="Region-based segmentation（基于区域的分割）"></a>Region-based segmentation（基于区域的分割）</h4><h5 id="Region-growing（区域生长）"><a href="#Region-growing（区域生长）" class="headerlink" title="Region growing（区域生长）"></a>Region growing（区域生长）</h5><p>1）根据图像的不同应用选择一组或多组开始点，把靠近这些点族中心的像素作为种子点（通常采用腐蚀算法）<br>2）选择一个相似性准则。<br>（灰度级、 色彩、 纹理、 梯度等特性相似）<br>3）从该种子开始向外扩张，不断将与集合中各个像素连通、且满足相似性准则的像素加入集合。<br>4）上一过程进行到不再有满足条件的新结点加入集合为止。（终止准则）</p>
<h5 id="Region-splitting-and-mergin（区域分裂与合并）"><a href="#Region-splitting-and-mergin（区域分裂与合并）" class="headerlink" title="Region splitting and mergin（区域分裂与合并）"></a>Region splitting and mergin（区域分裂与合并）</h5><h2 id="Image-feature-description（图像特征描述）"><a href="#Image-feature-description（图像特征描述）" class="headerlink" title="Image feature description（图像特征描述）"></a>Image feature description（图像特征描述）</h2><h3 id="Shape-feature（形状特征）"><a href="#Shape-feature（形状特征）" class="headerlink" title="Shape feature（形状特征）"></a>Shape feature（形状特征）</h3><h4 id="Euler-number（欧拉数）"><a href="#Euler-number（欧拉数）" class="headerlink" title="Euler number（欧拉数）"></a>Euler number（欧拉数）</h4><h4 id="Convexity-and-concavity（凹凸性）"><a href="#Convexity-and-concavity（凹凸性）" class="headerlink" title="Convexity and concavity（凹凸性）"></a>Convexity and concavity（凹凸性）</h4><h4 id="Region-measurement（区域测量）"><a href="#Region-measurement（区域测量）" class="headerlink" title="Region measurement（区域测量）"></a>Region measurement（区域测量）</h4><ul>
<li><p>Area S</p>
</li>
<li><p>Perimeter L</p>
</li>
<li><p>Length and Width</p>
</li>
<li><p>Minimum Enclosing Rectangle（最小外接矩形）</p>
<p> Rectangle Degree (矩形度) R = S / S(MER)</p>
</li>
<li><p>Roundness (圆形度)</p>
<p> R0 = 4πS / L²</p>
</li>
<li><p>Shape Complexity (形状复杂度)</p>
<p> e =  L² / S</p>
</li>
</ul>
<h4 id="skeletonization-骨架化"><a href="#skeletonization-骨架化" class="headerlink" title="skeletonization (骨架化)"></a>skeletonization (骨架化)</h4><ul>
<li><p>thinning algorithm (细化算法)</p>
<p>假设区域内点的值为1，背景点的值为0。由两个基本操作组成。</p>
<p>1.对于满足以下四个条件的边界点打标记准备删除：<br>(a)2≤N(p1)≤6  (N(p1)=p2+p3+…+p9，是点p1邻域中1的个数)<br>(b)S(p1)=1    (S(p1)是按p2,p3,…,p9顺序，0-1转换的个数)<br>(c)p2 <em> p4 </em> p6 = 0    （p2 、p4 、p6 至少有一个0）<br>(d)p4 <em> p6 </em> p8 = 0    （p4 、p6 、p8 至少有一个0）</p>
<p>2.对于满足以下四个条件的边界点打标记准备删除：</p>
<p>条件(a)、(b)与1相同，条件(c)、(d)改为：<br>(c’) p2<em> p4</em> p8= 0 （p2 、p4 、p8 至少有一个0）<br>(d’) p2<em> p6</em> p8= 0（p2 、p6 、p8 至少有一个0）</p>
</li>
</ul>
<h4 id="Moment-method-矩量法"><a href="#Moment-method-矩量法" class="headerlink" title="Moment method (矩量法)"></a>Moment method (矩量法)</h4><ul>
<li>Invariant moment (不变矩)</li>
</ul>
<h4 id="Projection-投影"><a href="#Projection-投影" class="headerlink" title="Projection (投影)"></a>Projection (投影)</h4><p><img src="https://img-blog.csdnimg.cn/20210629002244776.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210629002312284.png"></p>
<h4 id="Shape-descriptor-形状描述子"><a href="#Shape-descriptor-形状描述子" class="headerlink" title="Shape descriptor (形状描述子)"></a>Shape descriptor (形状描述子)</h4><ul>
<li><p>Chain code (链码)</p>
<p><img src="https://img-blog.csdnimg.cn/20210628230738596.png" alt="schematic diagram"></p>
<ul>
<li>链码旋转归一化得到差分码</li>
<li>差分码起点归一化得到最小差分码（形状数）</li>
</ul>
</li>
<li>shape number (形状数)</li>
<li>Fourier descriptor (傅里叶描述子)</li>
</ul>
<h3 id="Color-feature（颜色特征）"><a href="#Color-feature（颜色特征）" class="headerlink" title="Color feature（颜色特征）"></a>Color feature（颜色特征）</h3><h4 id="Color-Histogram-颜色直方图"><a href="#Color-Histogram-颜色直方图" class="headerlink" title="Color Histogram (颜色直方图)"></a>Color Histogram (颜色直方图)</h4><p><img src="https://img-blog.csdnimg.cn/20210628234440533.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20210628234511119.png"></p>
<ul>
<li>L1norm distance </li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20210628234357804.png'></p>
<ul>
<li>L2norm distance</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/2021062823471372.png'></p>
<ul>
<li>histogram intersection (直方图交)</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20210628234810144.png'></p>
<h4 id="Color-Moment-颜色矩"><a href="#Color-Moment-颜色矩" class="headerlink" title="Color Moment (颜色矩)"></a>Color Moment (颜色矩)</h4><p><img src="https://img-blog.csdnimg.cn/20210629001941115.png"></p>
<h4 id="Color-Set-颜色集"><a href="#Color-Set-颜色集" class="headerlink" title="Color Set (颜色集)"></a>Color Set (颜色集)</h4><p><img src="https://img-blog.csdnimg.cn/20210628235137337.png"></p>
<h3 id="Texture-feature（纹理特征）"><a href="#Texture-feature（纹理特征）" class="headerlink" title="Texture feature（纹理特征）"></a>Texture feature（纹理特征）</h3><h4 id="Statistical-texture-统计纹理"><a href="#Statistical-texture-统计纹理" class="headerlink" title="Statistical texture (统计纹理)"></a>Statistical texture (统计纹理)</h4><ul>
<li>Space gray level dependence matrix/entropy（空间灰度共生矩阵/熵）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210629000539776.png"></p>
<p><img src="https://img-blog.csdnimg.cn/2021062900061649.png" alt="schematic diagram"></p>
<h4 id="Structural-texture-结构纹理"><a href="#Structural-texture-结构纹理" class="headerlink" title="Structural texture (结构纹理)"></a>Structural texture (结构纹理)</h4>]]></content>
      <categories>
        <category>Theories</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(一)</title>
    <url>/2020/10/11/RPG-Dev-Log-1/</url>
    <content><![CDATA[<p>涉及内容：简单场景创建；鼠标跟随贴花制作；动画蓝图制作；移动操控绑定等。<br><a id="more"></a></p>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="简单场景创建"><a href="#简单场景创建" class="headerlink" title="简单场景创建"></a>简单场景创建</h2><ol>
<li>清理默认物体，如Floor、Capsule等;</li>
<li>添加Box Brush，Transform&gt;Location=(0,0,0)，Brush Settings &gt; X=5000,Y=5000,Z=800;</li>
<li>快捷键ALT复制一个，Transform&gt;Location(0,0,50)，Brush Settings &gt; X=4800,Y=4800,Z=700, Brush Type=Subtractive;</li>
<li>利用Geometry Editing创建几个测试平台、楼梯等；</li>
<li>添加StarterContent初学者内容包，为场景物体添加材质。</li>
<li>保存场景为Training至RPG_Game&gt;Maps。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201011122013690.png"></p>
<h2 id="鼠标跟随贴花制作"><a href="#鼠标跟随贴花制作" class="headerlink" title="鼠标跟随贴花制作"></a>鼠标跟随贴花制作</h2><ol>
<li>图标来源：<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a>  </li>
<li>添加Goal图标至RPG_Game&gt;Textures；</li>
<li>创建材质球M_GoalDecal，设置Material Domain=Deferred Decal，Blend Mode=Translucent，Decal Blend Mode = Emissive；</li>
<li>设置Material蓝图参数；<img src='https://img-blog.csdnimg.cn/20201011123828721.png'></li>
<li>创建材质实例Inst_GoalDecal，Sets the preview mesh to a plane primitive，修改公开变量Color和EmissiveValue(高光度)；</li>
<li>以上M_GoalDecal、Inst_GoalDecal添加至RPG_Game&gt;Materials；</li>
<li>创建Actor BP_GoalDecal至RPG_Game&gt;Actors，添加Decal组件和Box collision，在Event Graph 内添加Begin Overlap(Box)事件。<img src='https://img-blog.csdnimg.cn/20201011124835193.png'></li>
</ol>
<h2 id="动画蓝图制作"><a href="#动画蓝图制作" class="headerlink" title="动画蓝图制作"></a>动画蓝图制作</h2><ol>
<li>骨骼网格体、动画来源：虚幻商城[虚幻争霸：心菲]</li>
<li>以下将会用到Skeletal Mesh (Shinbi)，Animation Sequence (Shibi_Fwd、Shibi_Idle);</li>
<li>创建一维混合空间Shibi_BlendSpace1D，Horizontal Axis 命名为 Speed，区间设置为[0,400],0处添加Idle,400处添加Fwd;</li>
<li>创建动画蓝图ABP_Shibi至RPG_Game&gt;Characters&gt;Animations，新建状态机:Entry-&gt;Idle_Move,新建变量:Speed,设置动画蓝图如下；<img src='https://img-blog.csdnimg.cn/20201011130431251.png'></li>
<li>进入Event Graph,设置动画蓝图事件如下。<img src='https://img-blog.csdnimg.cn/20201011130521861.png'></li>
</ol>
<h2 id="移动操控绑定"><a href="#移动操控绑定" class="headerlink" title="移动操控绑定"></a>移动操控绑定</h2><ol>
<li>创建Character BP_RPG_Character至RPG_Game&gt;Blueprints，并创建子类Char_Shibi;</li>
<li>打开Char_Shibi,添加SpringArm和Camera(依附于SpringArm)，设置SpringArm Rotation=(0,-45,0),Target Arm Length=650;</li>
<li>创建RPG_PlayerController至RPG_Game&gt;Blueprints；</li>
<li>创建RPG_Game_Mode至RPG_Game&gt;Blueprints,设置Player Controller Class为RPG_PlayerController,Default Pawn Class为Char_Shibi;</li>
<li>打开项目设置，设置Default GameMode 为RPG_GameMode,Default Maps为Training,添加轴映射MoveForward(W/S)、MoveRight(A/D)、LookUp(Mouse Y)、Turn(Mouse X);</li>
<li>打开RPG_PlayerController,创建函数CancelMovementCommand,用于处理角色移动状态时销毁鼠标贴花；<img src='https://img-blog.csdnimg.cn/20201011132117897.png'></li>
<li>Shibi Object获取；<img src='https://img-blog.csdnimg.cn/20201011132352696.png'></li>
<li>鼠标贴花生成；<img src='https://img-blog.csdnimg.cn/20201011132417698.png'></li>
<li>移动转向控制。<img src='https://img-blog.csdnimg.cn/20201011133109943.png'><img src='https://img-blog.csdnimg.cn/20201011133157497.png' ><img src='https://img-blog.csdnimg.cn/20201011133223590.png'><img src='https://img-blog.csdnimg.cn/2020101113325827.png'><img src='https://img-blog.csdnimg.cn/20201011133327798.png'></li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201012174104608.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201012174324500.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十)</title>
    <url>/2020/10/25/RPG-Dev-Log-10/</url>
    <content><![CDATA[<p>涉及内容：创建Enemy；创建战斗系统（开篇）。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p>
<p>虚幻商城[InfinityBlade:Adversaries]</p>
<p>虚幻商城[Action RPG]</p>
<p>虚幻商城[User Interface Kit]</p>
<h2 id="创建Enemy"><a href="#创建Enemy" class="headerlink" title="创建Enemy"></a>创建Enemy</h2><h3 id="创建敌人动画蓝图"><a href="#创建敌人动画蓝图" class="headerlink" title="创建敌人动画蓝图"></a>创建敌人动画蓝图</h3><ol>
<li><p>以BP_RPG_Character为父类，创建BP_Enemy;</p>
</li>
<li><p>将InfinityBlade:Adversaries资源[Enemy_Grunting]导入，创建动画蓝图ABP_Grunting和一维混合空间BS_Grunting_Skeleton_BlendSpace1D;</p>
</li>
<li><p>打开项目Action RPG,将骨骼动画Idle_Grunting导出为fbx文件，随后添加至ContentBrowser；</p>
</li>
<li><p>打开BS_Grunting_Skeleton_BlendSpace1D，设置水平坐标为Speed，最大水平值为400。将骨骼动画Idle、Walk_Slow、Walk、Run添加至适当坐标，并勾选Walk_Slow、Walk、Run的ForceFontXAxis选项；</p>
</li>
<li><p>打开ABP_Grunting，添加蓝图获取PawnOwner的Speed;</p>
</li>
<li><p>进入动画图表，新建状态机，添加Start&lt;=&gt;Locomotion状态及过渡规则（此处省略状态动画的相关蓝图设置）；<img src='https://img-blog.csdnimg.cn/20201025201901720.png'><img src='https://img-blog.csdnimg.cn/20201025202013508.png'></p>
</li>
</ol>
<h3 id="创建敌人蓝图"><a href="#创建敌人蓝图" class="headerlink" title="创建敌人蓝图"></a>创建敌人蓝图</h3><ol>
<li><p>以BP_Enemy为父类，创建蓝图Enemy_Grunting，添加骨骼和骨骼动画，调整碰撞胶囊体大小；</p>
</li>
<li><p>打开BP_Enemy，修改PaperSprite样式，添加组件Widget,命名为NameAndHealthBar，并添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201025203024776.png'></p>
</li>
</ol>
<h3 id="创建武器蓝图"><a href="#创建武器蓝图" class="headerlink" title="创建武器蓝图"></a>创建武器蓝图</h3><ol>
<li><p>创建BP_Weapon，添加组件Sphere、StaticMesh、SkeletalMesh、Capsule，设置相关参数；</p>
</li>
<li><p>以BP_Weapon为父类，创建Weapon_Grunting,添加Grunting武器模型，调整胶囊体和武器朝向；</p>
</li>
<li>打开Enemy_Grunting骨骼，添加Sockect[Weapon]至b_MF_Weapon_R,添加preview assets，设置预览动画，调整Socket位置;</li>
<li>打开事件图表，添加蓝图，将Weapon添加至敌人身上；<img src='https://img-blog.csdnimg.cn/20201025C204213703.png'></li>
</ol>
<h3 id="创建敌人名称血量UI"><a href="#创建敌人名称血量UI" class="headerlink" title="创建敌人名称血量UI"></a>创建敌人名称血量UI</h3><ol>
<li>创建Widget[W_Enemy]，层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201025204659690.png'></li>
<li>打开BP_Enemy，将W_Enemy添加至NameAndHealthBar，并调整其位置;</li>
<li>创建结构体S_EnemyAttribute，添加敌人血量上限、物理攻击/法术攻击、物理防御/法术防御等属性；<img src='https://img-blog.csdnimg.cn/20201025205105844.png'></li>
<li>打开BP_Enemy，创建函数[void] SetHealthPercent()，用于控制敌人血量百分比显示,在EventBegin添加调用；<img src='https://img-blog.csdnimg.cn/2020102520543750.png'></li>
</ol>
<h3 id="创建敌人AI行为——Random"><a href="#创建敌人AI行为——Random" class="headerlink" title="创建敌人AI行为——Random"></a>创建敌人AI行为——Random</h3><ol>
<li><p>打开E_Behaviors，添加AI行为枚举[Random]；</p>
</li>
<li><p>创建Componet[Behavior创建Componet],创建事件调度OnBehaviorChanged(E_Behaviors);</p>
</li>
<li><p>创建函数[void] SetBehavior(E_Behaviors),用于Call事件调度；<img src='https://img-blog.csdnimg.cn/20201025210057184.png'></p>
</li>
<li><p>将BehaviorComponet添加至BP_RPG_Character；</p>
</li>
<li><p>打开行为树BT_NPC，打开服务BTS_UpdateBehaviorTree，删除重载函数ReceiveTickAI，添加重载函数ReveiveSearchStartAI,创建自定义事件OnBehaviorChanged(E_Behaviors),调用宏SetBehavior;<img src='https://img-blog.csdnimg.cn/20201025211113194.png'></p>
</li>
<li><p>打开之前创建的BP_RPG_NPC_Warriors巡逻NPC，通过Behavior组件调用宏SetBehavior，实现AI行为改变；</p>
</li>
<li><p>打开BB_Base，添加Key[Originl]、[Random]、[Target];</p>
</li>
<li><p>创建Task[BTTask_RandomLocation],重载ReceiveExecuteAI事件，控制AI随机半径巡逻;<img src='https://img-blog.csdnimg.cn/20201025211959614.png'></p>
</li>
<li><p>打开行为树BT_NPC，创建Sequence并添加Blackboard Decorator[RandomLocation],序列执行顺序为:Wait（5)—&gt;BTTask_RandomLocation(SelfActor,Random,2000)—&gt;MoveTo(Random)（then Loop);<img src='https://img-blog.csdnimg.cn/20201026163507753.png'></p>
</li>
<li><p>打开BP_Enemy，初始化Blackboard的Original值为ActorLocation,设置AI行为为Random;<img src='https://img-blog.csdnimg.cn/20201025214715454.png'></p>
</li>
<li><p>设置AI Controller Class为AIC_Controller。</p>
</li>
</ol>
<h2 id="创建战斗系统（开篇）"><a href="#创建战斗系统（开篇）" class="headerlink" title="创建战斗系统（开篇）"></a>创建战斗系统（开篇）</h2><h3 id="创建敌人AI行为——HasSeenPlayer"><a href="#创建敌人AI行为——HasSeenPlayer" class="headerlink" title="创建敌人AI行为——HasSeenPlayer"></a>创建敌人AI行为——HasSeenPlayer</h3><ol>
<li><p>打开BP_Enemy，添加组件PawnSensing，设置视野半径和周边视野角度；<img src='https://img-blog.csdnimg.cn/20201026162705473.png'></p>
</li>
<li><p>打开BB_Base，添加key[Target]，类型为Actor;添加IsInAttackRange，类型为Boolean。打开E_Behavior，添加枚举HasSeenPlayer；</p>
</li>
<li><p>打开BP_Enemy事件图表，添加OnSeePawn(PawnSensing)事件，当Enemy感知Player时，加速靠近Player并执行HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201026163212433.png'></p>
</li>
<li><p>创建任务BTTask_Check，重载事件ReceiveExcuteAI，用于检测Player是否在AI视野范围内；<img src='https://img-blog.csdnimg.cn/2020102616394518.png'></p>
</li>
<li><p>创建任务BTTask_Attack，重载事件ReceiveExecuteAI,调用BP_Enemy的Attack事件。创建自定义事件FinalAttack，成功执行返回success；<img src='https://img-blog.csdnimg.cn/20201026164404943.png'></p>
</li>
</ol>
<h3 id="创建敌人攻击动画"><a href="#创建敌人攻击动画" class="headerlink" title="创建敌人攻击动画"></a>创建敌人攻击动画</h3><ol>
<li>将InfinityBlade:Adversaries资源[Enemy_Anim_Sword_Combat_Swing_Montage]导入，创建动画Montage;</li>
<li>打开ABP_Grunting，状态Locomotion添加DefaultSlot，使动画Montage生效；</li>
<li>打开BP_Enemy事件图表，创建自定义事件Attack,执行Attack蒙太奇动画，并调用BTTask_Attack中的自定义事件FinalAttack;<img src='https://img-blog.csdnimg.cn/20201026165559988.png'></li>
<li>打开行为树BT_NPC,创建Selector并添加Blackboard Decorator[HasSeenPlayer],设置BlackboardKey=Behavior,KeyValue=HasSeenPlayer；创建Sequence，序列执行顺序为BTTask_Check(Target,IsInAttackRange,AttackRange)——&gt;MoveTo(Target)[CheckAttackRange(Target)]——&gt;BTTask_Attack(then loop);<img src='https://img-blog.csdnimg.cn/20201026165758704.png'></li>
<li>创建AnimNotifyState[ANS_Weapon]，创建重载函数Reveived_NotifyBegin，Received_NotifyEnd，当敌人攻击角色时，临时关闭胶囊体碰撞；<img src='https://img-blog.csdnimg.cn/20201026174431299.png'></li>
</ol>
<h3 id="创建敌人攻击伤害显示"><a href="#创建敌人攻击伤害显示" class="headerlink" title="创建敌人攻击伤害显示"></a>创建敌人攻击伤害显示</h3><ol>
<li><p>创建蓝图接口I_Damageable,创建接口函数[void] OnRecieveDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage);</p>
</li>
<li><p>打开BP_Enemy，添加蓝图接口I_Damageable；</p>
</li>
<li><p>打开BP_RPG_Character，创建函数[Boolean:IsCritical?，Float:Damage] CalculateDamage(Float:PhysicalDamage,Float:MagicDamage,Float:CriticalChance,Float:CriticalDamage,Float:PhysicalDefence，Float:MagicDefence，Boolean:AbsoluteDefence);</p>
</li>
<li><p>函数CalculateDamage用于综合敌人攻击属性和玩家防御属性，计算最终伤害，计算公式为：</p>
<p>Damage=</p>
<p>[</p>
<p>PhysicalDamage×random(0.9,1.1)-PhysicalDefence</p>
<p>+</p>
<p>MagicDamage×random(0.7,1.3)-MagicDefence</p>
<p>]</p>
<p>×</p>
<p>(IsCritical ?  1 :  CriticalDamage)；<img src='https://img-blog.csdnimg.cn/20201026171644771.png'></p>
</li>
<li><p>打开Enemy_Grunting，整合BeginPlay事件至父类BP_Enemy中的自定义事件CreateWeapon，并修改为在BP_Enemy中的BeginPlay事件中调用；<img src='https://img-blog.csdnimg.cn/20201026173117268.png'></p>
</li>
<li><p>打开BP_Shibi，添加OnRecieveDamage函数实现，调用CalculateDamage和ModifyAttribute(新的参数Critical,用于暴击判定，最终传入SetDamageText)，实现敌人伤害计算并应用于玩家的血量变更；<img src='https://img-blog.csdnimg.cn/20201026173731535.png'></p>
</li>
<li><p>打开BP_Weapon，添加事件ActorBeginOverlap，当敌人追上玩家时，传入敌人属性，调用OnRecieveDamage事件；<img src='https://img-blog.csdnimg.cn/20201026174639179.png'></p>
</li>
<li><p>打开W_DamageText，扩展UpdateValue函数功能，添加新的传入参数[Critical]，用于暴击伤害时伤害数字的特殊显示；<img src='https://img-blog.csdnimg.cn/20201026175016824.png'></p>
</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201026011936218.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十一)</title>
    <url>/2020/10/27/RPG-Dev-Log-11/</url>
    <content><![CDATA[<p>涉及内容：战斗系统（续篇），AI设置，蒙太奇动画。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="蒙太奇动画"><a href="#蒙太奇动画" class="headerlink" title="蒙太奇动画"></a>蒙太奇动画</h2><h3 id="玩家被击蒙太奇"><a href="#玩家被击蒙太奇" class="headerlink" title="玩家被击蒙太奇"></a>玩家被击蒙太奇</h3><ol>
<li>添加ShinBi被攻击时的骨骼动画，创建Montage，将HitRect_Back、HitRect_Font、HitReact_Left、HitRect_Right分成4个section添加进来;<img src='https://img-blog.csdnimg.cn/20201027183226400.png'></li>
<li>打开BP_Shibi事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次角色被攻击时，随机播放4个section中的一个；<img src='https://img-blog.csdnimg.cn/20201027183642919.png'></li>
</ol>
<h3 id="敌人被击蒙太奇"><a href="#敌人被击蒙太奇" class="headerlink" title="敌人被击蒙太奇"></a>敌人被击蒙太奇</h3><ol>
<li>创建[AM_React_LightHit]蒙太奇，添加轻击时的骨骼动画，共2种,分成2个Section;<img src='https://img-blog.csdnimg.cn/20201027190551416.png'></li>
<li>创建[AM_React_HeavyHit]蒙太奇，添加两种重击时的骨骼动画，共2种Section,分成2个Section；<img src='https://img-blog.csdnimg.cn/20201027190633867.png'></li>
<li>打开BP_Enemy事件图表，在OnRecieveDamage事件添加蒙太奇动画，每次敌人被攻击时，随机播放2个section中的一个，根据伤害是否暴击播放不同的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201027191532830.png'></li>
</ol>
<h3 id="敌人死亡蒙太奇"><a href="#敌人死亡蒙太奇" class="headerlink" title="敌人死亡蒙太奇"></a>敌人死亡蒙太奇</h3><ol>
<li>创建[AM_Death]蒙太奇，添加敌人死亡时的骨骼动画，共7种，分成7个Section；<img src='https://img-blog.csdnimg.cn/20201027191035160.png'></li>
<li>打开BP_Enemy事件图表，在OnDeath事件添加敌人死亡的随机蒙太奇动画播放，随机个数为7；<img src='https://img-blog.csdnimg.cn/20201027194633761.png'></li>
</ol>
<h2 id="战斗系统（续篇）"><a href="#战斗系统（续篇）" class="headerlink" title="战斗系统（续篇）"></a>战斗系统（续篇）</h2><h3 id="玩家相关"><a href="#玩家相关" class="headerlink" title="玩家相关"></a>玩家相关</h3><ol>
<li>打开BP_Shibi，添加自定义事件LineAttack，调用OnRecieveDamage事件，用于判定玩家是否成功命中敌人；<img src='https://img-blog.csdnimg.cn/20201027184947351.png'></li>
<li>打开三连攻击和空中攻击Montage动画，在PlaySound后添加AttackHit动画通知；在动画图表中调用BP_Shibi中的自定义事件LineAttack;<img src='https://img-blog.csdnimg.cn/20201027184701875.png'></li>
<li>修改函数[void]ModifyAttribute(Attribute,ModifyValue,Critical);</li>
<li>创建函数[void]UpdateLevel()，用于玩家升级后自身属性和技能点的更新；<img src='https://img-blog.csdnimg.cn/20201027213303392.png'></li>
<li>打开事件图表，修改自定义事件UpLevel，调用UpdateLevel()完成所有属性的更新；<img src='https://img-blog.csdnimg.cn/2020102721360097.png'></li>
<li>修改MeleeAttack（普通三连攻击）和Space Bar（二段跳)事件，实装耐力值消耗；</li>
<li>创建自定义事件CoolDownFighting和CountTime，用于玩家当前是否脱战的判定;<img src='https://img-blog.csdnimg.cn/20201027215037170.png'></li>
<li>精简Regeneration分类下的所有Tick事件的功能；</li>
</ol>
<h3 id="敌人相关"><a href="#敌人相关" class="headerlink" title="敌人相关"></a>敌人相关</h3><ol>
<li>打开E_Behavior，添加新的AI行为Death；</li>
<li>打开BP_Enemy，添加自定义事件ModifyValue(Boolean:Critical,Float:Damage),用于敌人攻击玩家时的伤害显示，并根据自身当前血量，设置Death或HasSeenPlayer行为；<img src='https://img-blog.csdnimg.cn/20201027193429331.png'></li>
<li>添加OnRecieveDamage事件,接收来自玩家的伤害数据，调用事件ModifyValue,计算伤害并应用伤害;<img src='https://img-blog.csdnimg.cn/20201027193207452.png'></li>
<li>添加自定义事件OnDeath,用于敌人死亡时的动画播放和自身销毁（如果有武器，武器也销毁）；<img src='https://img-blog.csdnimg.cn/20201027223511642.png'></li>
<li>创建函数[Boolean] IsPlayingMontage()，用于判断当前是否已添加蒙太奇；<img src='https://img-blog.csdnimg.cn/2020102719201244.png'></li>
<li>创建函数[void]UpdateAttribute,用于不同等级的敌人的属性更新（在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/20201027195155263.png'></li>
<li>创建函数[void]SetNameAndLevel(Integer),此函数除了设置NameAndHealthBar的文本外，还可根据玩家和敌人的等级差，设置不同的文本颜色渐变(在敌人生成时调用）；<img src='https://img-blog.csdnimg.cn/2020102720012115.png'><img src='https://img-blog.csdnimg.cn/20201027200251916.png'></li>
<li>添加胶囊碰撞体ShowEnemyWidget，并添加BeginOverlap和EndOverlap事件，当玩家与敌人的胶囊体发生碰撞时，显示NameAndHealthBar，离开胶囊体区域时隐藏；<img src='https://img-blog.csdnimg.cn/20201027200721727.png'></li>
</ol>
<h2 id="AI设置"><a href="#AI设置" class="headerlink" title="AI设置"></a>AI设置</h2><h3 id="敌人攻击流畅度优化"><a href="#敌人攻击流畅度优化" class="headerlink" title="敌人攻击流畅度优化"></a>敌人攻击流畅度优化</h3><ol>
<li>为BTTask_Attack添加Decorator[CoolDown]，冷却时间设置为1s；</li>
<li>打开BTTask_Attack，新增蒙太奇动画检测，若敌人正在攻击则延迟播放；<img src='https://img-blog.csdnimg.cn/20201027192842439.png'></li>
</ol>
<h3 id="敌人死亡Sequence"><a href="#敌人死亡Sequence" class="headerlink" title="敌人死亡Sequence"></a>敌人死亡Sequence</h3><ol>
<li>创建BTTask_Death，调用BP_Enemy中的OnDeath事件；<img src='https://img-blog.csdnimg.cn/20201027194039645.png'></li>
<li>创建Sequence并添加Blackboard Decorator[EventDeath],设置BlackboardKey=Behavior,KeyValue=Death，序列执行顺序为:BTTask_Death—&gt;Wait(5)（then Loop);<img src='https://img-blog.csdnimg.cn/20201027194357652.png'></li>
</ol>
<h3 id="离开敌人仇恨范围后脱战"><a href="#离开敌人仇恨范围后脱战" class="headerlink" title="离开敌人仇恨范围后脱战"></a>离开敌人仇恨范围后脱战</h3><ol>
<li>打开E_Behavior，添加新的AI行为RunBack；</li>
<li>创建服务BTS_CheckOriginalDistance，用于判断玩家是否已经离开了敌人AI的仇恨范围，并执行RunBack行为；<img src='https://img-blog.csdnimg.cn/20201027220346975.png'></li>
<li>打开BB_Base，添加新的键值IsRunningBack?(Boolean)和RandomRange(Float);</li>
<li>将服务BTS_CheckOriginalDistance添加至Selector(HasSeenPlayer)，并添加Blackboard Decorator[IsNotRunningBack]至子节点sequence，设置BlackboardKey=IsRunningBack?;</li>
<li>打开BTTask_RandomLocation，将浮点型变量RandomRadius修改为BlackBoardKey类型，并在BP_Enemy BeginPlay中添加传值；</li>
<li>创建任务BTTask_Reset，用于判断敌人AI是否已经脱仇，并执行来自BP_Enemy的Reset事件；<img src='https://img-blog.csdnimg.cn/2020102722221863.png'><img src='https://img-blog.csdnimg.cn/20201027222301945.png'></li>
<li>创建Sequence并添加Blackboard Decorator[RunBack],设置BlackboardKey=Behavior,KeyValue=RunBack，序列执行顺序为:MoveTo(Original)—&gt;BTTask_Reset（then Loop);<img src='https://img-blog.csdnimg.cn/20201027222635974.png'></li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102813041126.gif'></p>
<p><img src='https://img-blog.csdnimg.cn/20201028130602858.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十二)</title>
    <url>/2020/11/01/RPG-Dev-Log-12/</url>
    <content><![CDATA[<p>涉及内容：制作简单的粒子特效，获得经验金币，重生Enemy。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="敌人死后消亡特效"><a href="#敌人死后消亡特效" class="headerlink" title="敌人死后消亡特效"></a>敌人死后消亡特效</h2><ol>
<li>创建MaterialFunction[MF_DissolveEffect]，添加Input[Visibility]，Type=Function Input Scalar；<img src='https://img-blog.csdnimg.cn/2020110116235018.png'></li>
<li>打开Enemy材质球，调用MF_DissolveEffect，添加OnHit和Visibility参数，设置EmissiveColor和OpacityMask；<img src='https://img-blog.csdnimg.cn/20201101162845368.png'></li>
<li>创建Enemy材质球实例，选择PreviewMesh，设置EffectColor，调整OnHit和Visibility的值可预览Enemy被攻击时、消亡时的材质效果；<img src='https://img-blog.csdnimg.cn/20201101164744129.png'></li>
<li>创建AnimationNotify[ANS_DissolveEffect]，添加重载函数Received_NotifyTick，根据动画曲线[Dissolve_Spawn]渐变Visibility的值；<img src='https://img-blog.csdnimg.cn/20201101165355339.png'></li>
<li>为Enemy的七种随机死亡动画添加Notify[ANS_DissolveEffect]和Curve[Dissolve_Spawn];<img src='https://img-blog.csdnimg.cn/20201101165816602.png'></li>
</ol>
<h2 id="击杀敌人获得战利品"><a href="#击杀敌人获得战利品" class="headerlink" title="击杀敌人获得战利品"></a>击杀敌人获得战利品</h2><h3 id="获取经验值"><a href="#获取经验值" class="headerlink" title="获取经验值"></a>获取经验值</h3><h4 id="创建粒子特效"><a href="#创建粒子特效" class="headerlink" title="创建粒子特效"></a>创建粒子特效</h4><ol>
<li><p>创建材质球[P_Base]，添加Input[ParticleColor]，设置EmissiveColor和Opacity;<img src='https://img-blog.csdnimg.cn/20201101170341930.png'></p>
</li>
<li><p>创建材质球实例[P_Base_Inst];</p>
</li>
<li><p>打开初学者内容包里的P_Teleport_Tell_Source粒子特效，重命名为P_SoulXP，并打开;</p>
</li>
<li><p>对于第一个ParticleEmitter，将Emitter Duration设置为0，添加DirectLocation;</p>
</li>
<li><p>对于第二个ParticleEmitter，直接关闭;</p>
</li>
<li><p>对于第三个ParticleEmitter，将Emitter Duration设置为0，略微调大InitialSize，调整Sphere StartLocation的Z轴；</p>
</li>
<li><p>新建一个ParticleEmitter，将Material设置为P_Base_Inst，Spawn Rate设置为0，Burst Count设置为1，删除InitVelocity，调整ColorOverLife，添加Direct Location；</p>
</li>
<li><p>新建一个ParticleEmitter,TypeData设置为GPU Sprites,设置Spawn Distribution为Distribution Float Constant,添加Sphere并设置颜色;<img src='https://img-blog.csdnimg.cn/20201101172623580.png'></p>
</li>
</ol>
<h4 id="创建BP-XP"><a href="#创建BP-XP" class="headerlink" title="创建BP_XP"></a>创建BP_XP</h4><ol>
<li><p>创建Actor[BP_XP]，添加组件Sphere Collision，设置半径，应用物理属性，设置重量为3kg，更改碰撞预设为Custom;<img src='https://img-blog.csdnimg.cn/20201101173214860.png'></p>
</li>
<li><p>添加组件ParticleSystem，将Particle Template设置为P_SoulXP;</p>
</li>
<li><p>打开BP_Player事件图表，创建自定义事件AddXP(XP);<img src='https://img-blog.csdnimg.cn/20201101174006324.png'></p>
</li>
<li><p>打开事件图表，设置物理模拟，添加TimeLine[MoveToPlayer],实现玩家击杀敌人后吸收经验的效果。创建自定义事件FinishCollect，调用自定义事件AddXP；<img src='https://img-blog.csdnimg.cn/20201101174735841.png'><img src='https://img-blog.csdnimg.cn/20201101174658471.png'></p>
</li>
</ol>
<h4 id="设置EnemyXP"><a href="#设置EnemyXP" class="headerlink" title="设置EnemyXP"></a>设置EnemyXP</h4><ol>
<li><p>打开BP_Enemy,打开函数SetNameAndLevel，创建变量XP_Points，扩展函数功能，可通过敌人和玩家的等级差设置XP_Points(默认为10)，具体为：</p>
<p>XP_Points = 10 + 2*(EnemyLevel-1) + MAX(0,EnemyLevel-PlayerLevel);<img src='https://img-blog.csdnimg.cn/20201101175450907.png'></p>
</li>
<li><p>接上，函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101175712965.png'></p>
</li>
<li><p>创建函数[Void]SpawnXPAndMoney(FirstIndex),用于经验球和金币的生成,并在自定义事件OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101180333637.png'><img src='https://img-blog.csdnimg.cn/2020110118043023.png'></p>
</li>
</ol>
<h3 id="获取金币"><a href="#获取金币" class="headerlink" title="获取金币"></a>获取金币</h3><h4 id="创建BP-SpawnMoney"><a href="#创建BP-SpawnMoney" class="headerlink" title="创建BP_SpawnMoney"></a>创建BP_SpawnMoney</h4><ol>
<li>复制BP_XP,重命名为BP_SpawnMoney，删除ParticleSystem，添加StaticMesh和RotatingMovement；</li>
<li>设置StaticMesh为SM_Coin_Small，编辑材质球，调整EmissiveColor,提高亮度;</li>
<li>修改自定义事件FinishCollect，调用玩家蓝图中的自定义事件GetMoney;<img src='https://img-blog.csdnimg.cn/20201101181026191.png'></li>
</ol>
<h4 id="设置EnemyMoney"><a href="#设置EnemyMoney" class="headerlink" title="设置EnemyMoney"></a>设置EnemyMoney</h4><ol>
<li><p>函数UpdateAttribute中的修改；<img src='https://img-blog.csdnimg.cn/20201101181416558.png'></p>
</li>
<li><p>函数SpawnXPAndMoney中关于金币生成的部分，在OnDeath中调用；<img src='https://img-blog.csdnimg.cn/20201101181603620.png'></p>
</li>
</ol>
<h2 id="重生Enemy"><a href="#重生Enemy" class="headerlink" title="重生Enemy"></a>重生Enemy</h2><ol>
<li>创建结构体S_RespawnEnemy;<img src='https://img-blog.csdnimg.cn/20201101182318659.png'></li>
<li>创建Actor[BP_SpawnEnemy]，添加组件SpehreCollison，碰撞预设为NoCollison;</li>
<li>打开事件图表，创建变量EnemyList(S_RespawnEnemy),SpawnTimer(TimerHandle),IndicesToSpawn(Integer[]);</li>
<li>创建自定义事件RespawnEnemy(S_RespawnEnemy)，将死亡的敌人记录到EnemtList中，并用SpawnTimer控制自定义事件RespawnTick的调用，IndicesToSpawn数组用于记录敌人重生的索引顺序；<img src='https://img-blog.csdnimg.cn/20201101184746163.png'><img src='https://img-blog.csdnimg.cn/20201101184831482.png'><img src='https://img-blog.csdnimg.cn/20201101184908545.png'></li>
<li>打开BP_Enemy，在OnDeath中调用RespawnEnemy;<img src='https://img-blog.csdnimg.cn/2020110118502269.png'></li>
<li>打开BehaviorComponent，修改函数SetBehavior，对传入的AI行为进行判断,若与当前的AI行为不同，则将传入的AI行为设置为当前行为；<img src='https://img-blog.csdnimg.cn/2020110118562015.png'></li>
<li>打开BTS_UpdateBehaviorTree，添加重载事件Recieve Tick AI；<img src='https://img-blog.csdnimg.cn/20201101185829997.png'></li>
<li>设置BP_Enemy,Auto Prossess AI = Placed in World or Spawned；</li>
<li>设置Enemy_Grunting，Auto Prossess AI = Placed in World or Spawned，并设置默认属性值，敌人等级的随机生成；<img src='https://img-blog.csdnimg.cn/20201101190150116.png'></li>
<li>将BP_SpawnSphere添加到场景，并指定场景中的Enemy的RespawnActor为BP_SpawnSphere;</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020110116105649.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十三)</title>
    <url>/2020/11/03/RPG-Dev-Log-13/</url>
    <content><![CDATA[<p>涉及内容：大任务系统创建（进阶），UI设计应用细讲。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><h3 id="任务类型侧边栏"><a href="#任务类型侧边栏" class="headerlink" title="任务类型侧边栏"></a>任务类型侧边栏</h3><p>涉及组件：</p>
<ul>
<li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]</li>
<li>Common: [Border]、[Button]、[Text]</li>
</ul>
<h4 id="层级面板"><a href="#层级面板" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103114016404.png'></p>
<h4 id="实装效果"><a href="#实装效果" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/20201103114544272.png'></p>
<h4 id="组件动画"><a href="#组件动画" class="headerlink" title="组件动画"></a>组件动画</h4><p>Widget可视性：</p>
<blockquote>
<p><strong>Visible(可视)</strong>： 可见、可点击<br><strong>Collapsed(已折叠)</strong>： 不可见、不占用布局空间（性能优于 Hidden）<br><strong>Hidden(隐藏)</strong>： 不可见、占用布局空间<br><strong>HitTestInvisible(非可命中测试（自身和所有子项）)</strong>： 可见、当前 Widget 不可点击、所有 Child Widget 不可点击<br><strong>SelfHitTestInvisible(非可命中测试（仅自身）)</strong>： 可见、当前 Widget 不可点击、不影响 Child Widget</p>
</blockquote>
<ol>
<li>打开W_Mission,添加组件动画OpenMission;<br><img src='https://img-blog.csdnimg.cn/20201103120349278.png'></li>
<li>创建宏ShowMission(Visible);<br><img src='https://img-blog.csdnimg.cn/20201103121441665.png'></li>
<li>创建自定义事件PlayMission(Visible)，调用宏ShowMission(Visible)；</li>
</ol>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>设计组件：</p>
<ul>
<li>Panel: [Size Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li>
<li>Common: [Border]、[Text]</li>
</ul>
<h4 id="层级面板-1"><a href="#层级面板-1" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103114907317.png'></p>
<h4 id="实装效果-1"><a href="#实装效果-1" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/20201103114943124.png'></p>
<h3 id="任务详情"><a href="#任务详情" class="headerlink" title="任务详情"></a>任务详情</h3><p>涉及组件：</p>
<ul>
<li>Panel: [Size Box]、[Horizontal Box]、[Vertical Box]、[Overlay]、[Scroll Box]</li>
<li>Common: [Border]、[Button]、[Text]、[Image]</li>
</ul>
<h4 id="层级面板-2"><a href="#层级面板-2" class="headerlink" title="层级面板"></a>层级面板</h4><p><img src='https://img-blog.csdnimg.cn/20201103115323410.png'></p>
<h4 id="实装效果-2"><a href="#实装效果-2" class="headerlink" title="实装效果"></a>实装效果</h4><p><img src='https://img-blog.csdnimg.cn/2020110311543341.png'></p>
<h2 id="任务提示界面W-QuestBorder"><a href="#任务提示界面W-QuestBorder" class="headerlink" title="任务提示界面W_QuestBorder"></a>任务提示界面W_QuestBorder</h2><h3 id="层级面板-3"><a href="#层级面板-3" class="headerlink" title="层级面板"></a>层级面板</h3><p><img src='https://img-blog.csdnimg.cn/20201103120105457.png'></p>
<h3 id="实装效果-3"><a href="#实装效果-3" class="headerlink" title="实装效果"></a>实装效果</h3><p><img src='https://img-blog.csdnimg.cn/20201103120130439.png'></p>
<h2 id="热键测试"><a href="#热键测试" class="headerlink" title="热键测试"></a>热键测试</h2><p>打开RPG_PlayerController，添加热键Tab响应事件，切入和切出任务系统主界面；<br><img src='https://img-blog.csdnimg.cn/20201103121909957.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020110311322945.png'><img src='https://img-blog.csdnimg.cn/20201103113402801.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十四)</title>
    <url>/2020/11/04/RPG-Dev-Log-14/</url>
    <content><![CDATA[<p>涉及内容：大任务系统创建(续篇),蓝图UI任务数据绑定。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="创建W-MissionSubGoal"><a href="#创建W-MissionSubGoal" class="headerlink" title="创建W_MissionSubGoal"></a>创建W_MissionSubGoal</h2><ol>
<li>创建控件W_MissionSubGoal，作为W_Mission中任务分支信息SubGoalInfoVerticalBox的子控件；<br><img src='https://img-blog.csdnimg.cn/20201105072242910.png'><img src='https://img-blog.csdnimg.cn/20201105072311908.png'></li>
<li>创建函数Update，用于更新SubGoalText的文本内容(这部分蓝图可从W_SubGoal中的Update函数迁移过来)，并根据任务状态设置CurrentImage、SuccessImage、FailedImage的可视性，并在事件开始构造时调用；<img src='https://img-blog.csdnimg.cn/20201105072948473.png'></li>
</ol>
<h2 id="任务列表项W-QuestBorder"><a href="#任务列表项W-QuestBorder" class="headerlink" title="任务列表项W_QuestBorder"></a>任务列表项W_QuestBorder</h2><ol>
<li>打开S_QuestInfo，添加属性SuggestedLevel(Integer)；</li>
<li>打开W_QuestBorder，创建函数[void] Update()，用于绑定W_QuestBorder相关任务数据，包括QuestName、Frame、RegionText、LevelText、QuestTypeIcon等控件的文本、颜色、图标等，并且对QuestName控件的文本进行长度检测（任务名过长时缩略显示）；<img src='https://img-blog.csdnimg.cn/20201104232620180.png'></li>
<li>创建自定义事件UpdateSuggestedLevelColor(PlayerLevel)并绑定至事件调度UpdateLevelQuest。每当角色升级时，调用此事件，更新任务推荐等级的文本颜色，为游戏玩家提供更好的视觉效果（具体方法与Enemy的头衔颜色更新类似，通过PlayerLevel/Suggested的值设置Alpha的值，从而设置颜色过渡）。最后调用Update函数，完成任务列表所有数据项的显示更新;<img src='https://img-blog.csdnimg.cn/20201104233806488.png'></li>
</ol>
<h2 id="任务系统主界面W-Mission"><a href="#任务系统主界面W-Mission" class="headerlink" title="任务系统主界面W_Mission"></a>任务系统主界面W_Mission</h2><ol>
<li>打开W_QuestBorder，为AnimBorder创建划入(AddQuestBorder)和划出(RemoveQuestBorder)动画；<img src='https://img-blog.csdnimg.cn/20201104234440454.png'><img src='https://img-blog.csdnimg.cn/20201104234537409.png'></li>
<li>创建宏ShowQuestBorder(Visible)，用于根据当前控件的可视性播放划入或划出动画；<img src='https://img-blog.csdnimg.cn/20201104234832171.png'></li>
<li>为CurrentQuestButton、CompletedQuestButton、FailedQuestButton、HasQuestButton添加绑定事件：以CurrentQuestButton为例，当点击按钮时，隐藏CompletedScrollBox、FailedScrollBox、HasQuestScrollBox三个滚动框，并显示CurrentScrollBox（其余三个按钮同理）；<img src='https://img-blog.csdnimg.cn/2020110423525363.png'></li>
<li>创建自定义事件UpdateSuggestedLevel(PlayerLevel)，用于设置任务详情中推荐等级的文本颜色（设置方法同上）,并将此自定义事件绑定至事件调度UpdateLevelForQuest；<img src='https://img-blog.csdnimg.cn/2020110500005662.png'><img src='https://img-blog.csdnimg.cn/20201105000436852.png'></li>
<li>创建函数UpdateDescription，用于更新任务的具体描述，相关控件为DescriptionText，这里需要注意文本换行符的转义方式;<img src='https://img-blog.csdnimg.cn/2020110500113572.png'></li>
<li>创建函数UpdateDetailWindow，用于绑定W_Mission任务详情的相关任务数据，包括QuestName、TypeText、QuestTypeImage、RegionText、SuggestedLevel、MoneyText、ExpText、PrestigeText等控件的文本、颜色和图标等，数据源为SelectedQuest(BP_MasterQuest，所有Quest的父类)中的QuestInfo，并调用函数UpdateSuggestedLevel(PlayerLevel)，UpdateDescription，GenerateSubGoals；<img src='https://img-blog.csdnimg.cn/20201105064907715.png'><img src='https://img-blog.csdnimg.cn/20201105065000665.png'><img src='https://img-blog.csdnimg.cn/20201105065053167.png'><img src='https://img-blog.csdnimg.cn/2020110506512638.png'></li>
<li>创建函数GenerateSubGoals，用于更新SubGoalVerticalBox控件，绑定任务分支信息的相关数据，数据源为SelectedQuest(BP_MasterQuest)中的CompleteSubGoalInfo和CurrentSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201105071813592.png'></li>
<li>创建枚举E_QuestState；<img src='https://img-blog.csdnimg.cn/20201105073933672.png'></li>
<li>创建函数AddQuestBorder(Quest)，用于任务列表项W_QuestBorder(CurrentScrollBox等滚动框的子控件)的添加；<img src='https://img-blog.csdnimg.cn/20201105073719617.png'></li>
<li>创建自定义事件OnQuestBorderClicked(QuestBorder)，绑定至W_QuestBorder中的按钮QuestBorderButton。当任务列表项被点击时，禁用该列表项按钮，并调用函数UpdateDetailWindow，完成任务详情的更新；<img src='https://img-blog.csdnimg.cn/20201105074414237.png'><img src='https://img-blog.csdnimg.cn/20201105074646874.png'></li>
</ol>
<h2 id="任务组件QuestManager"><a href="#任务组件QuestManager" class="headerlink" title="任务组件QuestManager"></a>任务组件QuestManager</h2><ol>
<li>创建结构体S_CompletedSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201105065535758.png'></li>
<li>创建枚举E_SubGoalState；<img src='https://img-blog.csdnimg.cn/20201105065701141.png'></li>
</ol>
<h2 id="任务父类BP-MasterQuest"><a href="#任务父类BP-MasterQuest" class="headerlink" title="任务父类BP_MasterQuest"></a>任务父类BP_MasterQuest</h2><ol>
<li>打开BP_MasterQuest，重新设置CompletedSubGoalsInfo变量类型为S_CompletedSubGoalInfo（原来为S_SubGoalInfo，即扩展SubGoalIndex、Succesful两个引脚);</li>
<li>函数功能扩展：函数CompleteSubGoal(SubGoalIndex)变更为CompleteSubGoal(SubGoalIndex,Success?)，传入任务是否成功完成的参数，以便于CompletedSubGoalsInfo变量的更新;</li>
<li>函数功能扩展：函数SetupStartingSubGoals新增Description的数据更新，数据源为QuestInfo;</li>
<li>函数功能扩展：函数AddQuest(QuestClass)变更为AddQuest(QuestClass,DirectlyStart)，根据当前任务数量和DirectlyStart的布尔值判断是否自动接取任务。若自动接取任务，则播放动画PlayQuest和PlaySubGoal(来着W_Quest)；</li>
<li>关联事件修改：打开事件图表，修改自定义事件UpdateCompletedSubGoal；</li>
</ol>
<h2 id="任务实例设置"><a href="#任务实例设置" class="headerlink" title="任务实例设置"></a>任务实例设置</h2><h3 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080724734.png'></p>
<h3 id="支线任务"><a href="#支线任务" class="headerlink" title="支线任务"></a>支线任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080758220.png'></p>
<h3 id="副本任务"><a href="#副本任务" class="headerlink" title="副本任务"></a>副本任务</h3><p><img src='https://img-blog.csdnimg.cn/20201105080823342.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201105082833827.png'><img src='https://img-blog.csdnimg.cn/20201105082916789.png'><img src='https://img-blog.csdnimg.cn/20201105083011449.png'><img src='https://img-blog.csdnimg.cn/20201105082938769.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十五)</title>
    <url>/2020/11/07/RPG-Dev-Log-15/</url>
    <content><![CDATA[<p>涉及内容：大任务系统续，任务分支完成互动。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="W-PC-Main相关"><a href="#W-PC-Main相关" class="headerlink" title="W_PC_Main相关"></a>W_PC_Main相关</h2><ol>
<li><p>创建动画HideAll，用于隐藏主界面的所有用户自定义控件；<img src='https://img-blog.csdnimg.cn/20201108003424947.png'></p>
</li>
<li><p>创建函数[Float] PlayHideAll(Boolean)，用于控制HideAll动画的播放；<img src='https://img-blog.csdnimg.cn/20201108004704213.png'></p>
</li>
</ol>
<h2 id="W-Mission相关"><a href="#W-Mission相关" class="headerlink" title="W_Mission相关"></a>W_Mission相关</h2><ol>
<li>界面优化：打开W_Mission，为任务列表栏和任务详情栏添加边框(Image/Border);<img src='https://img-blog.csdnimg.cn/20201108002312944.png'></li>
<li>控件添加：添加返回按钮，取消勾选Interaction&gt;IsFocusable，并创建OnClick事件：点击按钮时隐藏任务系统界面并显示主界面；<img src='https://img-blog.csdnimg.cn/20201108004137729.png'><img src='https://img-blog.csdnimg.cn/20201108012623353.png'></li>
<li>动画添加：为SelectedBorder和CancelBorder添加ButtonPlay和ButtonCancel动画（两个动画除绑定对象不同外，其余都相同），并分别创建OnClick事件：点击SelectButton时播放ButtonPlay动画，调用SelectNewQuest事件，并隐藏SelectButton所在的HorizantalBox（使其无法再次被选择）。点击ButtonCancel时播放ButtonCancel动画。最后修改函数UpdateDetailWindow，比较SelectedQuest是否为CurrentQuest，若为真则隐藏SelectedHorizantalBox，否则显示SelectedHorizantalBox；<img src='https://img-blog.csdnimg.cn/20201108012156563.png'><img src='https://img-blog.csdnimg.cn/20201108014256728.png'><img src='https://img-blog.csdnimg.cn/2020110801435634.png'></li>
<li>函数修改：修改函数GenertateSubGoals，将参数HuntIndex传入W_MissionSubGoal；<img src='https://img-blog.csdnimg.cn/20201108231031870.png'></li>
</ol>
<h2 id="W-MissionSubGoal相关"><a href="#W-MissionSubGoal相关" class="headerlink" title="W_MissionSubGoal相关"></a>W_MissionSubGoal相关</h2><ol>
<li>修改函数Update，更新Hunt类型分支任务的信息；<img src='https://img-blog.csdnimg.cn/20201108024335447.png'></li>
</ol>
<h2 id="W-Quest相关"><a href="#W-Quest相关" class="headerlink" title="W_Quest相关"></a>W_Quest相关</h2><ol>
<li>修改函数[void]SelectSubGoal(W_SubGoal)，当SelectedSubGoal与传入的SubGoal不同时，更新SelectedSubGoal;<img src='https://img-blog.csdnimg.cn/20201108021956595.png'></li>
</ol>
<h2 id="W-SubGoal相关"><a href="#W-SubGoal相关" class="headerlink" title="W_SubGoal相关"></a>W_SubGoal相关</h2><ol>
<li>控件添加：添加FailedImage，对应SuccessImage;<img src='https://img-blog.csdnimg.cn/20201108020420640.png'></li>
<li>函数功能扩展：修改函数[void]DisableButton()为[void]DisableButton(Success?)，当任务完成时显示SuccessImage，任务失败时显示FailedImage;<img src='https://img-blog.csdnimg.cn/2020110916482665.png'></li>
<li>函数功能扩展：修改函数Update，添加CurrentSubGoal索引查询，并设置为HuntedIndex。添加SubGoalState，并对其作一个Select，以更新SubGoal信息（注意，如果此处不作select，SubGoal当前击杀/寻找数会循环0,1,2）;<img src='https://img-blog.csdnimg.cn/20201108023744297.png'><img src='https://img-blog.csdnimg.cn/20201109164737918.png'></li>
</ol>
<h2 id="BP-MasterQuest相关"><a href="#BP-MasterQuest相关" class="headerlink" title="BP_MasterQuest相关"></a>BP_MasterQuest相关</h2><ol>
<li>创建函数[Boolean]SelectInMission()，用于判断SelectedQuest是否为CurrentQuest；<img src='https://img-blog.csdnimg.cn/20201108014943318.png'></li>
<li>修改函数SetupStartingSubGoals，根据StartSubGoalIndices的数组长度对CurrentHuntedAmount数组进行Resize;<img src='https://img-blog.csdnimg.cn/20201108015344389.png'></li>
<li>修改函数[void]CompleteSubGoal(SubGoalIndex，Success?)，将传入参数Success提升为本地变量，并传入函数DisableButton(Success?)；<img src='https://img-blog.csdnimg.cn/20201109165028882.png'><img src='https://img-blog.csdnimg.cn/20201109165053562.png'><img src='https://img-blog.csdnimg.cn/20201109165133515.png'><img src='https://img-blog.csdnimg.cn/20201109165224466.png'></li>
<li>修改自定义事件UpdateCompletedSubGoal，初始化CurrentHuntedAmout数组为0，修改SubGoal的延迟更新条件;<img src='https://img-blog.csdnimg.cn/2020110802323032.png'><img src='https://img-blog.csdnimg.cn/20201108023250768.png'></li>
</ol>
<h2 id="BP-Enemy相关"><a href="#BP-Enemy相关" class="headerlink" title="BP_Enemy相关"></a>BP_Enemy相关</h2><ol>
<li>打开事件图表，修改自定义事件OnDeath，调用QuestManager自定义事件OnEnemyKilled；<img src='https://img-blog.csdnimg.cn/20201108031744839.png'></li>
</ol>
<h2 id="BP-QuestTest相关"><a href="#BP-QuestTest相关" class="headerlink" title="BP_QuestTest相关"></a>BP_QuestTest相关</h2><ol>
<li>打开测试专用Quest，创建Hunt型分支任务，猎杀目标为Enemy_Grunting;<img src='https://img-blog.csdnimg.cn/20201108031950863.png'></li>
</ol>
<h2 id="BP-TargetObject及其相关子类"><a href="#BP-TargetObject及其相关子类" class="headerlink" title="BP_TargetObject及其相关子类"></a>BP_TargetObject及其相关子类</h2><ol>
<li><p>BP_TargetObject组件面板修改如下（StaticMesh已被删除）；</p>
<p><img src='https://img-blog.csdnimg.cn/20201108033013777.png'></p>
</li>
<li><p>为Object_Treasure单独添加StaticMesh组件；</p>
</li>
<li><p>创建新的子类Object_Grain，并添加StaticMesh组件，将谷物袋子模型导入，设置Name和Interact文本初始值。添加接口EventOnInteractWith（Character)，调用OnObjectFound事件；<img src='https://img-blog.csdnimg.cn/20201108033817418.png'></p>
</li>
</ol>
<h2 id="QuestManager相关"><a href="#QuestManager相关" class="headerlink" title="QuestManager相关"></a>QuestManager相关</h2><ol>
<li>函数模块化：打开函数[void] AddQuest(QuestClass,DirectlyStart)，将Branch之后有关Quest和SubGoal动画播放的蓝图迁移至自定义事件SelectNewQuest(NewQuest)，当CurrentQuest为NULL时更新Quest并播放动画，不为NULL时检测SubGoal首项是否有效（若无效则更新Quest，否则延迟更新直至SubGoal首项无效）。在AddQuest中被调用;<img src='https://img-blog.csdnimg.cn/20201108011601891.png'></li>
<li>创建自定义事件OnEnemyKilled(Class)，锁定类型为Hunt的分支任务的Index，并根据击杀的敌人类型判断是否为有效击杀，若为有效击杀则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若击杀数大于需求数，则调用CompleteSubGoal。<img src='https://img-blog.csdnimg.cn/20201108030332689.png'><img src='https://img-blog.csdnimg.cn/20201108031407189.png'></li>
<li>创建自定义事件OnObjectFound(Class)，锁定类型为Search的分支任务的Index，并根据找到的物品类型判断是否为有效寻找，若为有效寻找则将CurrentHuntedAmount[Index]+1。若SelectedQuest为CurrentQuest，则调用GenerateSubGoals生成分支任务。若找到的数量大于需求数，则调用CompleteSubGoal。（相关蓝图与OnEnemyKilled(Class)类似）</li>
</ol>
<h2 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h2><ol>
<li>打开事件图表，修改Tab事件，打开任务系统界面时暂停游戏；<img src='https://img-blog.csdnimg.cn/2020110800393081.png'></li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="【子任务】狩猎小鬼完成效果"><a href="#【子任务】狩猎小鬼完成效果" class="headerlink" title="【子任务】狩猎小鬼完成效果"></a>【子任务】狩猎小鬼完成效果</h2><p><img src='https://img-blog.csdnimg.cn/20201109160208908.png'><img src='https://img-blog.csdnimg.cn/202011091641213.png'></p>
<h2 id="【子任务】寻找小麦完成效果"><a href="#【子任务】寻找小麦完成效果" class="headerlink" title="【子任务】寻找小麦完成效果"></a>【子任务】寻找小麦完成效果</h2><p><img src='https://img-blog.csdnimg.cn/20201108230246514.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201108230310157.png'></p>
<h2 id="【子任务】完成前后对比"><a href="#【子任务】完成前后对比" class="headerlink" title="【子任务】完成前后对比"></a>【子任务】完成前后对比</h2><p><img src='https://img-blog.csdnimg.cn/20201108230013575.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201108230045246.png'></p>
<p><img src='https://img-blog.csdnimg.cn/2020110916421358.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201109164242272.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十六)</title>
    <url>/2020/11/10/RPG-Dev-Log-16/</url>
    <content><![CDATA[<p>涉及内容：创建Npc对话系统（开篇），编辑剧本。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>创建枚举E_TalkType，代表当前对话选项对应的查看内容；<img src='https://img-blog.csdnimg.cn/20201110195932647.png'></li>
<li>创建枚举E_SelectSubGoalType，代表对话时分支选项的类型；<img src='https://img-blog.csdnimg.cn/2020111020024350.png'></li>
<li>创建结构体S_SelectSubGoalInfo，包含对话分支选项文本内容以及类型；<img src='https://img-blog.csdnimg.cn/2020111020054178.png'></li>
<li>创建结构体S_SpeechContent，包含Player与NPC对话的名字、内容、延迟(默认为4s)、是否有分支选项、分支选项内容；<img src='https://img-blog.csdnimg.cn/20201110200855293.png'></li>
<li>创建结构体S_Conversation，包含对话内容、对话信息、任务类、对话类型、指定任务是否已完成、推荐等级信息；<img src='https://img-blog.csdnimg.cn/20201110201213956.png'></li>
</ol>
<h2 id="创建BP-FindGrain"><a href="#创建BP-FindGrain" class="headerlink" title="创建BP_FindGrain"></a>创建BP_FindGrain</h2><p><img src='https://img-blog.csdnimg.cn/20201110220053550.png'></p>
<h2 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h2><h3 id="创建对话选项条W-TalkInfo"><a href="#创建对话选项条W-TalkInfo" class="headerlink" title="创建对话选项条W_TalkInfo"></a>创建对话选项条W_TalkInfo</h3><ol>
<li>层级面板和预览效果;<img src='https://img-blog.csdnimg.cn/20201110210022230.png'></li>
<li>打开事件图表，创建函数Update，用于根据TalkType更新TalkInfoImage、HotKeyText（选项数字）、SelectTalkInfo(按钮文本)，并在事件构造时调用;<img src='https://img-blog.csdnimg.cn/20201110210336891.png'></li>
<li>为SelectButton添加点击事件，根据SubGoalType判断相应的是OnClickedTalkTypeInfo事件（直接对话选项条）还是ContinueSelect事件（分支对话选项条）；<img src='https://img-blog.csdnimg.cn/2020111021555746.png'></li>
</ol>
<h3 id="创建对话信息盒W-TalKBorder"><a href="#创建对话信息盒W-TalKBorder" class="headerlink" title="创建对话信息盒W_TalKBorder"></a>创建对话信息盒W_TalKBorder</h3><ol>
<li>层级面板和预览效果(<strong>注意：将WrapperPolicy由默认模式更改为AllowPerCharacterWrapping，否则无法启用按长度换行功能</strong>)；<img src='https://img-blog.csdnimg.cn/20201110210623158.png'></li>
<li>打开事件图表，创建自定义事件ShowTalkInfo(Name,TalkInfo)和Hide()，用于显示和隐藏对话信息（实现一问一答的效果）；<img src='https://img-blog.csdnimg.cn/20201110211146795.png'></li>
</ol>
<h3 id="在W-PC-Main中添加对话选项盒和对话信息盒"><a href="#在W-PC-Main中添加对话选项盒和对话信息盒" class="headerlink" title="在W_PC_Main中添加对话选项盒和对话信息盒"></a>在W_PC_Main中添加对话选项盒和对话信息盒</h3><ol>
<li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211446980.png'></li>
</ol>
<h3 id="在W-Interaction中添加TalkInfoText"><a href="#在W-Interaction中添加TalkInfoText" class="headerlink" title="在W_Interaction中添加TalkInfoText"></a>在W_Interaction中添加TalkInfoText</h3><ol>
<li>层级面板和预览效果；<img src='https://img-blog.csdnimg.cn/20201110211642270.png'></li>
<li>打开事件图表，创建自定义事件ShowTalkInfo(Text)，用于Player靠近NPC时，显示和隐藏NPC头上的信息；<img src='https://img-blog.csdnimg.cn/20201110211814747.png'></li>
</ol>
<h2 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h2><h3 id="将NPC互动更改为蓝图接口模式"><a href="#将NPC互动更改为蓝图接口模式" class="headerlink" title="将NPC互动更改为蓝图接口模式"></a>将NPC互动更改为蓝图接口模式</h3><ol>
<li>删除绑定事件OnInteract;</li>
<li>在ClassSettings中添加蓝图接口I_Interaction;</li>
<li>打开BP_RPG_NPC，在事件开始时将ConversationData(DataTable)添加至TalkInfo(S_Conversation);<img src='https://img-blog.csdnimg.cn/20201110204835322.png'></li>
<li>将Overlap事件更改为调用蓝图接口函数EventBeginOverlapTargetObject和EventEndOverlapTargetObject;<img src='https://img-blog.csdnimg.cn/20201110205210283.png'></li>
<li>删除OnInteract事件，更改为蓝图接口函数EventOnInteractWith，主要功能为：NPC头顶信息的显示与隐藏，对话选项盒的UI构建;<img src='https://img-blog.csdnimg.cn/20201110212312661.png'><img src='https://img-blog.csdnimg.cn/20201110212357282.png'><img src='https://img-blog.csdnimg.cn/20201110212443312.png'></li>
</ol>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ol>
<li><p>修改UpdateQuest，改为仅设置PlayLevel;<img src='https://img-blog.csdnimg.cn/20201110205805908.png'></p>
</li>
<li><p>创建事件OnClickedTalkTypeInfo，根据直接对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110213025561.png'></p>
</li>
<li><p>创建事件ContinueSelect，根据分支对话选项条类型，点击时响应不同事件；<img src='https://img-blog.csdnimg.cn/20201110215727110.png'></p>
</li>
<li><p>[E_TalkType]枚举事件：</p>
<ul>
<li><p>创建事件OnClickedQuestInfo，当点击类型为QuestInfo的对话选项条时，播放对话剧本，并展示对话分支选项，并根据分支选项判断是否接取Quest；</p>
</li>
<li><p>创建事件OnClickedEndTalk，结束对话并清空UI;</p>
</li>
<li>创建事件OnClickedElseInfo(尚未实装)</li>
<li>创建事件OnClickedGoodsStore(尚未实装)</li>
<li>创建事件OnClickedWeaponStore(尚未实装)</li>
<li>创建事件OnClickedEquipStore(尚未实装)</li>
<li>创建事件OnClickedDrugStore(尚未实装)</li>
<li>创建事件OnClickedFoodStore(尚未实装)</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20201110213742981.png'><img src='https://img-blog.csdnimg.cn/20201110213844323.png'></p>
</li>
<li><p>[E_SelectSubGoalType]枚举事件：</p>
<ul>
<li>创建事件OnClickedContinue</li>
<li>创建事件OnClickedBack</li>
<li>创建事件OnClickedAddQuest</li>
<li>创建事件OnClickedQuit</li>
</ul>
</li>
</ol>
<h3 id="实例设置-NPC皮特"><a href="#实例设置-NPC皮特" class="headerlink" title="实例设置(NPC皮特)"></a>实例设置(NPC皮特)</h3><p><img src='https://img-blog.csdnimg.cn/20201110220234754.png'></p>
<h2 id="剧本编辑"><a href="#剧本编辑" class="headerlink" title="剧本编辑"></a>剧本编辑</h2><h3 id="创建Data-Table"><a href="#创建Data-Table" class="headerlink" title="创建Data Table"></a>创建Data Table</h3><ol>
<li>创建D_NPC_Conversation；<img src='https://img-blog.csdnimg.cn/20201110202006809.png'></li>
</ol>
<h3 id="编辑对话选项内容（含分支选项）"><a href="#编辑对话选项内容（含分支选项）" class="headerlink" title="编辑对话选项内容（含分支选项）"></a>编辑对话选项内容（含分支选项）</h3><ol>
<li><p>[QuestInfo]任务接取向——接取FindGrain任务：</p>
<p><img src='https://img-blog.csdnimg.cn/20201110203722362.png'></p>
</li>
<li><p>[ElseInfo]剧情介绍向——与NPC闲聊；<img src='https://img-blog.csdnimg.cn/20201110202040377.png'></p>
</li>
<li><p>[GoodsStore]市场交易向——杂货店：<img src='https://img-blog.csdnimg.cn/20201110202215835.png'></p>
</li>
<li><p>[WeaponStore]市场交易向——武器商店：<img src='https://img-blog.csdnimg.cn/20201110202303511.png'></p>
</li>
<li><p>[DrugStore]市场交易向——药品商店：<img src='https://img-blog.csdnimg.cn/20201110202358802.png'></p>
</li>
<li><p>[FoodStore]市场交易向——食物商店：<img src='https://img-blog.csdnimg.cn/20201110202638264.png'></p>
</li>
<li><p>[EquipStore]市场交易向——防具商店：<img src='https://img-blog.csdnimg.cn/20201110202659579.png'></p>
</li>
<li><p>[End]结束对话：<img src='https://img-blog.csdnimg.cn/2020111020280739.png'></p>
</li>
</ol>
<h3 id="编辑对话剧本"><a href="#编辑对话剧本" class="headerlink" title="编辑对话剧本"></a>编辑对话剧本</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">TalkerName</th>
<th style="text-align:center">SpeechInfo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Shinbi</td>
<td style="text-align:center">嗨，大叔，你知道如何才能进入峡谷吗？</td>
</tr>
<tr>
<td style="text-align:center">皮特</td>
<td style="text-align:center">大叔？小哥年方十八！</td>
</tr>
<tr>
<td style="text-align:center">Shibi</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">皮特</td>
<td style="text-align:center">咳咳。。。峡谷常年迷雾，又有猛兽出没，凶险万分，姑娘切莫深入。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi</td>
<td style="text-align:center">大叔放心，小女子十八般武艺样样精通，拳打南山猛虎，脚踢北海蛟龙，正好顺道为名除害！</td>
</tr>
<tr>
<td style="text-align:center">皮特</td>
<td style="text-align:center">。。。大叔。。的确，看姑娘的着装并非普通女子，非富即贵，只是。。。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi</td>
<td style="text-align:center">哈哈…就是，小女子才貌双全，大叔有何难处尽管直言！</td>
</tr>
<tr>
<td style="text-align:center">皮特</td>
<td style="text-align:center">呃。。这个，最近天降大雪，家中缺粮，我这不出来寻粮了吗，如果姑娘能带来一袋小麦，我将带你进入峡谷的入口。。。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi(分支1-1)</td>
<td style="text-align:center">哈哈，小事情，交给我吧！不过这荒天雪地的能不能折现？？</td>
</tr>
<tr>
<td style="text-align:center">Shinbi(分支1-2)</td>
<td style="text-align:center">这荒天雪地的上哪去找一袋小麦。。</td>
</tr>
<tr>
<td style="text-align:center">皮特</td>
<td style="text-align:center">这个、、、多谢女侠，折合成市价30硬币。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi(分支2-1)</td>
<td style="text-align:center">给与30硬币。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi(分支2-2)</td>
<td style="text-align:center">给与一袋小麦。</td>
</tr>
<tr>
<td style="text-align:center">Shinbi(分支2-3)</td>
<td style="text-align:center">我再想想。。</td>
</tr>
</tbody>
</table>
</div>
<p><img src='https://img-blog.csdnimg.cn/20201110203809964.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201110203838787.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201110194837692.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201110194928442.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201110195002450.png'></p>
<p><img src='https://img-blog.csdnimg.cn/2020111019504116.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201110195118759.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201110195145659.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十七)</title>
    <url>/2020/11/14/RPG-Dev-Log-17/</url>
    <content><![CDATA[<p>涉及内容：Npc对话系统续，创建背包。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="NPC对话系统（续篇）"><a href="#NPC对话系统（续篇）" class="headerlink" title="NPC对话系统（续篇）"></a>NPC对话系统（续篇）</h2><ol>
<li>打开枚举E_SelectSubGoalType，添加两个新的枚举BackToLastQuest和FinishQuest;</li>
<li>打开结构体S_Conversation，添加两个新的成员RecieveTalkTypeInfo(Text)和RecieveQuestTalkInfo(S_SpeechContent[]);</li>
<li>打开BP_RPG_NPC，完善自定义事件OnClickBack，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114161008148.png'></li>
<li>修改自定义事件EventOnInteractWith,对TalkInfo做一次Select。交互NPC时将根据玩家是否已经接取任务，显示不同的对话信息条；<img src='https://img-blog.csdnimg.cn/20201114161616981.png'></li>
<li>修改自定义事件OnClickedQuestInfo，分别对SpeechContent和TalkInfo做一次Select。点击类型为QuestInfo的对话信息条时，将根据玩家是否已经接取任务，显示不同的下级对话信息条和对话信息盒内容；<img src='https://img-blog.csdnimg.cn/20201114161932684.png'></li>
<li>创建自定义事件SkipTalkInfo，用于跳过对话信息；<img src='https://img-blog.csdnimg.cn/20201114162118327.png'></li>
<li>打开W_TalkBorder，为HorizatontalBox添加一个SkipButton，并添加绑定事件SkipTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114162351432.png'><img src='https://img-blog.csdnimg.cn/20201114162420284.png'></li>
<li>创建函数UpdateQuestInfo(HasRecievedQuest?)，用于接取任务时更新对应的对话信息条，在OnClickAddQuest自定义事件中调用；<img src='https://img-blog.csdnimg.cn/20201114164749817.png'></li>
<li>创建自定义事件OnBackToLastSelect，返回对话上一级时清空对话信息条并隐藏对话信息盒；<img src='https://img-blog.csdnimg.cn/20201114164037125.png'></li>
<li>创建自定义事件OnFinishQuest，完成任务时根据当前索引移除对应的对话信息条,并返回上一级对话；<img src='https://img-blog.csdnimg.cn/20201114164220856.png'></li>
<li>更新自定义事件ContinueSelect，添加事件OnBackToLastSelect和OnFinishQuest的调用；<img src='https://img-blog.csdnimg.cn/20201114165003579.png'></li>
<li>打开D_NPC_Conversation，将TalkInfo[7].SelectSubGoalInfo[1].SelectSubGoalType改为Back，将TalkInfo[8].SelectSubGoalInfo[2].SelectSubGoalType改为BackToLastSelect;<img src='https://img-blog.csdnimg.cn/20201114163211314.png'></li>
<li>设置新增成员RecieveTalkTypeInfo和RecieveQuestTalkInfo;<img src='https://img-blog.csdnimg.cn/20201114163638476.png'></li>
</ol>
<h2 id="创建背包"><a href="#创建背包" class="headerlink" title="创建背包"></a>创建背包</h2><blockquote>
<p>Spacer：留白占位控件</p>
<p>WrapBox：流布局控件，其子控件可以根据WrapBox的大小自动换行s</p>
</blockquote>
<ol>
<li>创建控件W_Window，用作背包窗口；<img src='https://img-blog.csdnimg.cn/20201114171504794.png'></li>
<li>将变量Name绑定至NameForWindow文本控件;</li>
<li>为CloseButton添加OnClicked绑定事件，添加节点RemoveFromParent；<blockquote>
<p>当前鼠标的本地位置（LocalPosition）由当前鼠标的绝对位置（AbsolutePosition）经过窗体几何变换得到。</p>
<p>Canvas Panel Slot插槽位置 = 拖拽终点鼠标的本地位置 - 拖拽起点鼠标的本地位置</p>
</blockquote>
</li>
<li>为DraggableBorder控件添加OnMouseButtonDown事件绑定<strong>（DraggableBorder的所有父控件可视性必须设置为Self Hit Test Invisible,否则无法响应事件）</strong>，判断鼠标是否按在DraggableBorder上，并获取鼠标拖拽后的位置，最后返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172104549.png'></li>
<li>创建重载函数OnMouseMove，更新拖拽后OutterVerticalBox的位置；<img src='https://img-blog.csdnimg.cn/20201114172158989.png'></li>
<li>创建重载函数OnMouseButtonUP，当鼠标抬起时结束DraggingWindow可拖拽判定，并返回Event Reply；<img src='https://img-blog.csdnimg.cn/20201114172238741.png'></li>
<li>打开RPG_PlayerController，在EventBeginPlay中设置InputGameModeAndUI;<img src='https://img-blog.csdnimg.cn/20201114172545263.png'></li>
<li>创建Key I键盘输入事件，控制背包的显示和隐藏；<img src='https://img-blog.csdnimg.cn/20201114172647259.png'></li>
<li>创建控件W_Inventory，用作背包物品的图表和数量显示；<img src='https://img-blog.csdnimg.cn/20201114173149429.png'></li>
<li>打开事件图表，创建函数GenerateInventorySlot，用于测试背包物品的生成，在事件开始构造时调用;<img src='https://img-blog.csdnimg.cn/20201114173457586.png'></li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="接取NPC任务"><a href="#接取NPC任务" class="headerlink" title="接取NPC任务"></a>接取NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165442401.png'><img src='https://img-blog.csdnimg.cn/20201114170429745.png'></p>
<h2 id="提交NPC任务"><a href="#提交NPC任务" class="headerlink" title="提交NPC任务"></a>提交NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165550957.png'><img src='https://img-blog.csdnimg.cn/20201114170513599.png'></p>
<h2 id="完成NPC任务"><a href="#完成NPC任务" class="headerlink" title="完成NPC任务"></a>完成NPC任务</h2><p><img src='https://img-blog.csdnimg.cn/20201114165629575.png'></p>
<h2 id="背包效果"><a href="#背包效果" class="headerlink" title="背包效果"></a>背包效果</h2><p><img src='https://img-blog.csdnimg.cn/20201114155859633.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十八)</title>
    <url>/2020/11/16/RPG-Dev-Log-18/</url>
    <content><![CDATA[<p>涉及内容：脚部IK制作。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="脚部IK制作"><a href="#脚部IK制作" class="headerlink" title="脚部IK制作"></a>脚部IK制作</h2><h3 id="事件图表"><a href="#事件图表" class="headerlink" title="事件图表"></a>事件图表</h3><h4 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h4><ol>
<li><p>创建宏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Start(Vector),End(Vector)]TraceStart&#x2F;End(X(Float),Y(Float),Z(Float))</span><br></pre></td></tr></table></figure>
<p>用于计算射线检测的起点和终点位置;<img src='https://img-blog.csdnimg.cn/20201116155309202.png'></p>
</li>
<li><p>创建宏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ClampedOffset(Vector)]ClampOffset(Roll(Float),Pitch(Float),Z(Float))</span><br></pre></td></tr></table></figure>
<p>用于限制X,Y,Z轴的偏移距离；<img src='https://img-blog.csdnimg.cn/20201116161451526.png'></p>
</li>
<li><p>创建宏</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Return(Vector)]InterpOffsets(Current(Vector),Target(Vector))</span><br></pre></td></tr></table></figure>
<p>用于从Current到Target插值计算X,Y,Z轴偏移量;<img src='https://img-blog.csdnimg.cn/20201116164750110.png'></p>
<blockquote>
<p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/Vector2DInterpTo/index.html">Vector2DInterpTo</a></strong></p>
<p>Interpolate vector2D from Current to Target.</p>
<p><strong><a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FMath/FInterpTo/index.html">FInterpTo</a></strong></p>
<p>Interpolate float from Current to Target.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CORE_API <span class="keyword">float</span> <span class="title">FMath::FInterpTo</span><span class="params">( <span class="keyword">float</span> Current, <span class="keyword">float</span> Target, <span class="keyword">float</span> DeltaTime, <span class="keyword">float</span> InterpSpeed )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If no interp speed, jump to target value</span></span><br><span class="line">    <span class="keyword">if</span>( InterpSpeed &lt;= <span class="number">0.f</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distance to reach</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> Dist = Target - Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If distance is too small, just set the desired location</span></span><br><span class="line">    <span class="keyword">if</span>( FMath::Square(Dist) &lt; SMALL_NUMBER )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delta Move, Clamp so we do not over shoot.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> DeltaMove = Dist * FMath::Clamp&lt;<span class="keyword">float</span>&gt;(DeltaTime * InterpSpeed, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Current + DeltaMove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ol>
<li><p>折叠函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[OutHit_bBlockingHit(Boolean),ClampedOffset(Vector)]TraceFootIK(A_Z(Float),B_X(Float),B_Y(Float))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/Collision/LineTraceByChannel/index.html">LineTraceByChannel</a></strong></p>
<p>Does a collision trace along the given line and returns the first blocking hit encountered. This trace finds the objects that RESPONDS to the given TraceChannel</p>
</blockquote>
<p>调用宏TraceStart/End和函数LineTraceByChannel，计算脚部Roll,Pitch轴的Rotation偏移量和Z轴偏移量，并调用宏ClampOffset，限制偏移范围。具体计算方式为：</p>
<p>Roll = arctan(OutHitNormal.y/OutHitNormal.z)</p>
<p>Pitch = arctan(OutHitNormal.x/OutHitNormal.z)</p>
<p>z = WorldLoaction.z - OutHitLocation.z；<img src='https://img-blog.csdnimg.cn/20201116163019606.png'></p>
</li>
<li><p>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[void]FootIK()</span><br></pre></td></tr></table></figure>
<p>脚部IK数值计算汇总（此函数在EventBlueprintUpdateAnimation中调用）：当角色不在跳跃状态时，获取foot_l和foot_r的骨骼位置，调用函数TraceFootIK，根据Hit布尔值设置LeftFootOffsetsTarget的值(ClampedOffset or Zero)。循环调用宏InterpOffsets实现脚部偏移过渡效果，并设置Pelvis.z=Min(LeftFootOffset.z,RightFootOffset.z);</p>
<p><img src='https://img-blog.csdnimg.cn/2020111617001856.png'></p>
<p><img src='https://img-blog.csdnimg.cn/2020111616594744.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201116165832569.png'></p>
</li>
</ol>
<h3 id="动画图表"><a href="#动画图表" class="headerlink" title="动画图表"></a>动画图表</h3><ol>
<li>现有Pose：Base—&gt;UpBody—&gt;LocalPose;<img src='https://img-blog.csdnimg.cn/20201116170745543.png'></li>
<li>打开骨骼树，添加虚拟骨骼VB thigh_l_calf_l和VB thigh_r_calf_r；<img src='https://img-blog.csdnimg.cn/20201116171006740.png'></li>
<li>添加Pose：LocalPose—&gt;FootIKPose</li>
</ol>
<ul>
<li><p>pelvis</p>
<p><img src='https://img-blog.csdnimg.cn/20201116172111319.png'></p>
</li>
<li><p>ik_foot_l &amp; VB thigh_l_calf_l</p>
<p><img src='https://img-blog.csdnimg.cn/20201116172150724.png'><img src='https://img-blog.csdnimg.cn/20201116172216387.png'></p>
</li>
<li><p>ik_foot_r &amp; VB thigh_r_calf_r</p>
<p><img src='https://img-blog.csdnimg.cn/20201116172256840.png'><img src='https://img-blog.csdnimg.cn/2020111617232282.png'></p>
</li>
</ul>
<p><img src='https://img-blog.csdnimg.cn/20201116172648890.png'></p>
<ol>
<li>最后按布尔输出混合姿势<br><img src='https://img-blog.csdnimg.cn/20201116172617594.png'>  </li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="添加前Shinbi右脚悬空"><a href="#添加前Shinbi右脚悬空" class="headerlink" title="添加前Shinbi右脚悬空"></a>添加前Shinbi右脚悬空</h2><p><img src='https://img-blog.csdnimg.cn/20201116152721533.png'></p>
<h2 id="添加后Shinbi右脚落地"><a href="#添加后Shinbi右脚落地" class="headerlink" title="添加后Shinbi右脚落地"></a>添加后Shinbi右脚落地</h2><p><img src='https://img-blog.csdnimg.cn/20201116160346496.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(十九)</title>
    <url>/2020/11/17/RPG-Dev-Log-19/</url>
    <content><![CDATA[<p>涉及内容：背包系统数据绑定，服务端客户端初讲，RPC。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="背包系统数据绑定"><a href="#背包系统数据绑定" class="headerlink" title="背包系统数据绑定"></a>背包系统数据绑定</h2><h3 id="相关枚举"><a href="#相关枚举" class="headerlink" title="相关枚举"></a>相关枚举</h3><ol>
<li>创建枚举E_ItemType [其他物品,武器装备,消耗物品,任务物品]，用于设置物品类别；</li>
<li>创建枚举E_QualityType [Poor,Common,Uncommon,Rare,Epic,Legendary]，用于设置物品品级；</li>
</ol>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ol>
<li><p>创建结构体S_InventoryItem，用于设置物品的ID、图标、名字、描述、品级、类别、数量、价值、是否可堆叠、堆叠上限、是否可拖拽等信息；<img src='https://img-blog.csdnimg.cn/2020111716025619.png'></p>
</li>
<li><p>创建结构体S_InventoryID，用于设置物品ID等从服务端发送过来的简单字符串；<img src='https://img-blog.csdnimg.cn/20201117171747606.png'></p>
</li>
<li><p>创建结构体S_QualityColor，用于设置不同品级的物品颜色；<img src='https://img-blog.csdnimg.cn/20201117181151413.png'></p>
</li>
</ol>
<h3 id="创建数据表ItemList"><a href="#创建数据表ItemList" class="headerlink" title="创建数据表ItemList"></a>创建数据表ItemList</h3><ol>
<li>选择S_InventoryItem，创建数据表ItemList;<img src='https://img-blog.csdnimg.cn/20201117161557370.png'><img src='https://img-blog.csdnimg.cn/20201117161720162.png'></li>
<li>创建任务物品Food_Grain；<img src='https://img-blog.csdnimg.cn/20201117161014212.png'></li>
<li>创建其他物品Rock；<img src='https://img-blog.csdnimg.cn/20201117161122363.png'></li>
<li>创建消耗物品Food_Cupcake;<img src='https://img-blog.csdnimg.cn/2020111716124483.png'></li>
<li>创建消耗物品Bush;<img src='https://img-blog.csdnimg.cn/20201117161320380.png'></li>
</ol>
<h3 id="创建组件C-Inventory"><a href="#创建组件C-Inventory" class="headerlink" title="创建组件C_Inventory"></a>创建组件C_Inventory</h3><ol>
<li>创建函数[Success(Boolean)] InitializeInventory(InventorySize(Integer))，用于初始化Inventory(S_InventoryItem[])数组;<img src='https://img-blog.csdnimg.cn/20201117162452567.png'></li>
<li>创建函数[Inventory(S_InventoryItem[])] GetInventoryItem()，用于获取Inventory数组；<img src='https://img-blog.csdnimg.cn/20201117163625345.png'></li>
<li>创建函数[Success(Boolean)] SetInventoryItem(Index(Integer),Item(S_InventoryItem))，用于设置Inventory[Index]物品属性；<img src='https://img-blog.csdnimg.cn/20201117162831113.png'></li>
<li>创建函数[Success(Boolean)]LoadInventoryItem (InventorySize(Integer),TargetArray(S_InventoryItem[]))，调用函数InitializeInventory和SetInventoryItem，加载所有物品属性；<img src='https://img-blog.csdnimg.cn/20201117164028913.png'></li>
</ol>
<h3 id="创建组件C-InventoryManager"><a href="#创建组件C-InventoryManager" class="headerlink" title="创建组件C_InventoryManager"></a>创建组件C_InventoryManager</h3><ol>
<li>创建函数[Void]Initialize_UI_PC_Main()，用于初始化PC_Main(W_PC_Main)；<img src='https://img-blog.csdnimg.cn/20201117172454711.png'></li>
<li>创建函数[Void]InitializePlayerInventoryComponent，用于初始化PlayerInventory(C_Inventory)；<img src='https://img-blog.csdnimg.cn/20201117172848864.png'></li>
<li>创建函数[Void]LoadInventory(),用于根据背包物品属性创建W_InventorySlot实例，并添加到W_InventoryWindow内的InventorySlotWrapBox内，创建的实例个数由InventorySize决定。最后调用服务端事件Server_RefreshInventory；<img src='https://img-blog.csdnimg.cn/20201117174722222.png'></li>
<li>创建函数[Void]ClearInventorySlotItem()，用于初始化W_InventorySlot中的变量ItemInformation；<img src='https://img-blog.csdnimg.cn/20201117180831721.png'></li>
<li>创建函数[Void]SetInventorySlotItem()，用于设置InventorySlot[SlotIndex]的ItemInformation属性;<img src='https://img-blog.csdnimg.cn/20201117182259271.png'></li>
<li>创建函数[Void]RefreshInventorySlots()，调用客户端事件Client_SetInventorySlotItem和Client_SetInventorySlotItem，刷新背包数据并更新Slot；<img src='https://img-blog.csdnimg.cn/20201117182927647.png'><img src='https://img-blog.csdnimg.cn/20201117182532491.png'></li>
<li>创建函数[Void]OpenInventoryWindow()，用于显示背包窗口；<img src='https://img-blog.csdnimg.cn/20201117183626422.png'></li>
<li>创建函数[Void]CloseInventoryWindow()，用于隐藏背包窗口；<img src='https://img-blog.csdnimg.cn/20201117183710298.png'></li>
</ol>
<h3 id="W-InventorySlot属性绑定"><a href="#W-InventorySlot属性绑定" class="headerlink" title="W_InventorySlot属性绑定"></a>W_InventorySlot属性绑定</h3><ol>
<li>物品边框BrushColor属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181452720.png'></li>
<li>物品图表BrushImage属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181717696.png'></li>
<li>物品数量Text属性绑定；<img src='https://img-blog.csdnimg.cn/20201117181817509.png'></li>
</ol>
<h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="RPG-PlayerController"><a href="#RPG-PlayerController" class="headerlink" title="RPG_PlayerController"></a>RPG_PlayerController</h3><ol>
<li><p>添加组件C_Inventory和C_InventoryManager；</p>
</li>
<li><p>勾选Replication&gt;Replicates，将自身复制到服务端；</p>
</li>
<li><p>创建函数Server_LoadPlayerItem，限制事件执行位置位于服务端，本地创建InventoryID数组模拟解包后的数据（此处省略了服务端向客户端发送数据包的过程）。根据从服务器获取的InventoryID，从本地ItemList加载物品属性，并存入本地变量LocalInventory。添加完成后，调用C_Inventory的函数LoadInventoryItem加载背包物品，传入的参数InventorySize来自C_InventoryManager的变量InventorySlot(Replicated)；</p>
<p><img src='https://img-blog.csdnimg.cn/20201117171957372.png'><img src='https://img-blog.csdnimg.cn/20201117171456274.png'></p>
</li>
<li><p>在EventBeginPlay中调用函数InitializePlayerInventoryComponent初始化C_Inventory，随后调用ServerLoadPlayerItem从服务端加载（简单）数据，然后调用函数Initialize_UI_PC_Main初始化W_PC_Main，最后调用事件Client_LoadInventory，从客户端加载（更为详细的）数据;<img src='https://img-blog.csdnimg.cn/2020111717564280.png'></p>
</li>
<li><p>删除BP_Player中的热键I事件，更改为在RPG_PlayerController中调用，根据InventoryManager中的IsInventoryOpen布尔值，判断是调用客户端事件Client_OpenInventory，还是调用Client_ClosenInventory；<img src='https://img-blog.csdnimg.cn/2020111718430680.png'></p>
</li>
</ol>
<h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-InitializeInventory"><a href="#Server-InitializeInventory" class="headerlink" title="Server_InitializeInventory"></a>Server_InitializeInventory</h4><p>在C_Inventory事件图表中创建，调用函数InitializeInventory；<img src='https://img-blog.csdnimg.cn/20201117164840990.png'></p>
<h4 id="Server-RefreshInventory"><a href="#Server-RefreshInventory" class="headerlink" title="Server_RefreshInventory"></a>Server_RefreshInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数RefreshInventorySlots；<img src='https://img-blog.csdnimg.cn/20201117180225333.png'></p>
<h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-LoadInventory"><a href="#Client-LoadInventory" class="headerlink" title="Client_LoadInventory"></a>Client_LoadInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数LoadInventory;<img src='https://img-blog.csdnimg.cn/20201117173447637.png'></p>
<h4 id="Client-ClearInventorySlotItem"><a href="#Client-ClearInventorySlotItem" class="headerlink" title="Client_ClearInventorySlotItem"></a>Client_ClearInventorySlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearInventorySlotItem;<img src='https://img-blog.csdnimg.cn/2020111718045423.png'></p>
<h4 id="Client-SetInventorySlotItem"><a href="#Client-SetInventorySlotItem" class="headerlink" title="Client_SetInventorySlotItem"></a>Client_SetInventorySlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SetInventorySlotItem;<img src='https://img-blog.csdnimg.cn/20201117182358410.png'></p>
<h4 id="Client-OpenInventory"><a href="#Client-OpenInventory" class="headerlink" title="Client_OpenInventory"></a>Client_OpenInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数OpenInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201117183848642.png'></p>
<h4 id="Client-CloseInventory"><a href="#Client-CloseInventory" class="headerlink" title="Client_CloseInventory"></a>Client_CloseInventory</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201117183911582.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201117155229532.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(二)</title>
    <url>/2020/10/12/RPG-Dev-Log-2/</url>
    <content><![CDATA[<p>涉及内容：UI血条创建；绑定角色属性等。<br><a id="more"></a></p>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="UI血条创建"><a href="#UI血条创建" class="headerlink" title="UI血条创建"></a>UI血条创建</h2><p>UI素材来源：虚幻商城[User Interface Kit]</p>
<h3 id="材质球制作"><a href="#材质球制作" class="headerlink" title="材质球制作"></a>材质球制作</h3><ol>
<li>创建Material [M_GlassBall]，将gb（T5,include frame,gloss,over) 拖拽进材质球蓝图;</li>
<li>创建Material Function [MF_Vertical]，用于处理血球垂直方向的颜色线性渐变，此处Clamp限制Alpha(0~1)，减少性能消耗；<img src='https://img-blog.csdnimg.cn/20201012182956977.png'></li>
<li>打开[M_GlassBall]，完成第一部分蓝图，涉及UV平衡器（Panner）、图像混合模式（Blend Overlay)、插值计算等,完成Fill (V3)参数传递<img src='https://img-blog.csdnimg.cn/20201012183538901.png'></li>
<li>完成第二部分蓝图，MF_Vertical—&gt;M_GlassBall，这部分主要设计血球的框架和形状，Ceil用于向上取整<img src='https://img-blog.csdnimg.cn/20201012184100410.png'></li>
<li>创建材质实例Inst_GlassBall,设置Color、Intensity（强度）、Percentage（血量百分比）等参数</li>
</ol>
<h3 id="控件蓝图设计"><a href="#控件蓝图设计" class="headerlink" title="控件蓝图设计"></a>控件蓝图设计</h3><ol>
<li>创建Widget Blueprint [W_ActionBar]，删除默认的canvas panel，设置为custom模式，添加Scale Box,组件结构如下<img src='https://img-blog.csdnimg.cn/20201012181046997.png'>Textures涉及:actionbar frame(T3,include L ,R,Center);</li>
<li>创建Widget Blueprint [W_GlassBall]，同上，从User Created分类下，在Scale Box内添加预设的Inst_GlassBall，添加Event Construct事件，用于设置血球颜色以便于灵力球的添加和血量动态颜色；<img src='https://img-blog.csdnimg.cn/20201012185331871.png'></li>
<li>创建Widget Blueprint [W_PC_Main]，添加预设的Action Bar以及Glass Ball，并调整anchors,Size,Alignment,etc;</li>
<li>打开Char_Shibi人物蓝图，在Event Graph添加W_PC_Main控件即可。</li>
</ol>
<h2 id="绑定角色属性"><a href="#绑定角色属性" class="headerlink" title="绑定角色属性"></a>绑定角色属性</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol>
<li>准备工作：创建枚举[E_Attribute]=[None,Health,Mana,Stamain],创建结构体[S_Attribute]=[CurrentValue(Float),MinValue(Float),MaxValue(Float),ClassBallWidget(W Glass Ball)];</li>
<li>核心数据结构：E_Attribute 到 S_Attribute Map 映射关系；</li>
<li>函数[S_Attribute] GetAttribute(E_Attribute),用于根据键值对获取某一属性的相关值；</li>
<li>函数[void] SetAttribute(E_Attribute,S_Attribute),用于添加新的属性键值对；</li>
<li>函数[void] SetupAttributeBars()，实装Health&amp;Mana等属性绑定；</li>
<li>函数[S_Attribute] UpdateAttribute(E_Attribute),用于计算和更新血球百分比，动态颜色；</li>
<li>函数[void] ModifyAttribute(E_Attribute,Float),用于伤害显示，同时调用4、6。</li>
</ol>
<h3 id="受伤-回血实装"><a href="#受伤-回血实装" class="headerlink" title="受伤/回血实装"></a>受伤/回血实装</h3><ol>
<li>GetAttribute<img src='https://img-blog.csdnimg.cn/20201012195017253.png'></li>
<li>SetAttribute<img src='https://img-blog.csdnimg.cn/20201012195137455.png'></li>
<li>SetupAttributeBars<img src='https://img-blog.csdnimg.cn/20201012195223773.png'></li>
<li>UpdateAttribute<img src='https://img-blog.csdnimg.cn/20201012195331529.png'></li>
<li>ModiftAttribute<img src='https://img-blog.csdnimg.cn/20201012195518275.png'></li>
</ol>
<h3 id="受伤-回血数字显示"><a href="#受伤-回血数字显示" class="headerlink" title="受伤/回血数字显示"></a>受伤/回血数字显示</h3><ol>
<li>创建Widget [W_DamageText]，添加FadeOut动画，用于伤害数字浮动显示并消失；<img src='https://img-blog.csdnimg.cn/2020101219394440.png'></li>
<li>打开W_DamageText 事件图表，事件开始构造时播放1s的Fadeout动画,添加自定义事件UpdateValue，用于受伤/回血时不同的文字内容&amp;颜色显示；</li>
<li>创建Widget Component [WC_OnDamaged],创建自定义事件SetDamageText,内部调用UpdateValue事件；</li>
<li>打开函数ModifyAttribute，在Health值被修改前将WC_OnDamaged控件调出,并调用自定义事件SetDamageText，将会自动播放FadeOut动画。</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201012175955500.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201012180028750.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(二十)</title>
    <url>/2020/11/18/RPG-Dev-Log-20/</url>
    <content><![CDATA[<p>涉及内容：ToolTip，拖拽功能，RPC。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="修复W-Window关闭按钮"><a href="#修复W-Window关闭按钮" class="headerlink" title="修复W_Window关闭按钮"></a>修复W_Window关闭按钮</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>创建蓝图接口BPI_HUDInterface;</li>
<li>创建接口函数[Void]UICloseInventoryWindow();</li>
</ol>
<h3 id="W-Window相关"><a href="#W-Window相关" class="headerlink" title="W_Window相关"></a>W_Window相关</h3><ol>
<li>修改CloseButton点击事件，更改为调用RPG_PlayerController中的接口事件UICloseInventoryWindow;<img src='https://img-blog.csdnimg.cn/20201118172800898.png'></li>
</ol>
<h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol>
<li>实现接口函数事件EventUICloseInventoryWindow，调用服务端事件Client_CloseInventory；<img src='https://img-blog.csdnimg.cn/20201118172537733.png'></li>
</ol>
<h2 id="使用ToolTip添加物品描述"><a href="#使用ToolTip添加物品描述" class="headerlink" title="使用ToolTip添加物品描述"></a>使用ToolTip添加物品描述</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>创建结构体E_UseType [Health,Mana,HealthAndMana]；</li>
<li>打开结构体S_InventoryItem，新增Health、Mana、Duration、UseType物品属性；<img src='https://img-blog.csdnimg.cn/20201118153607658.png'></li>
<li>打开蓝图接口BPI_HUDInterface创建接口函数，[InventoryInformation(S_InventoryItem)]GetToolTip(ID(Name));</li>
<li>打开ItemList，新增物品Health_Red和Mana_Blue，用于测试ToolTip；<img src='https://img-blog.csdnimg.cn/20201118155809237.png'><img src='https://img-blog.csdnimg.cn/20201118155834342.png'></li>
</ol>
<h3 id="W-ToolTip相关"><a href="#W-ToolTip相关" class="headerlink" title="W_ToolTip相关"></a>W_ToolTip相关</h3><ol>
<li>创建控件W_ToolTip，添加物品名称、类别、使用信息、描述信息、价格；<img src='https://img-blog.csdnimg.cn/2020111815241557.png'></li>
<li>对NameText控件添加文本内容和颜色的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118152520842.png'><img src='https://img-blog.csdnimg.cn/20201118153029489.png'></li>
<li>对ItemType控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118153142211.png'></li>
<li>对UseInfo控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118153928751.png'></li>
<li>对Description控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/2020111815414278.png'></li>
<li>对ValueText控件添加文本内容的绑定函数；<img src='https://img-blog.csdnimg.cn/20201118154310493.png'></li>
</ol>
<h3 id="W-InventorySlot相关"><a href="#W-InventorySlot相关" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol>
<li>为SizeBox的ToolTipWidget添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118155639966.png'></li>
</ol>
<h3 id="RPG-PlayerController相关-1"><a href="#RPG-PlayerController相关-1" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol>
<li>点击ClassSettings，将蓝图接口BPI_HUDInterface添加进来；</li>
<li>实现接口函数GetToolTip，根据物品ID从ItemList中获取物品信息；<img src='https://img-blog.csdnimg.cn/20201118155108526.png'></li>
<li>修改变量InventoryID，将新增的物品Health_Red和Mana_Blue添加进来；<img src='https://img-blog.csdnimg.cn/20201118160116361.png'></li>
</ol>
<h2 id="拖拽功能"><a href="#拖拽功能" class="headerlink" title="拖拽功能"></a>拖拽功能</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>打开蓝图接口BPI_HUDInterface，创建接口函数[Void]UIMoveInventoryItem(FromInventoryIndex(Integer),ToInventoryIndex(Integer));</li>
</ol>
<h3 id="W-DragItem相关"><a href="#W-DragItem相关" class="headerlink" title="W_DragItem相关"></a>W_DragItem相关</h3><ol>
<li>创建控件W_DragItem，用于拖拽物品时生成的图标；<img src='https://img-blog.csdnimg.cn/20201118160913939.png'></li>
<li>对Icon控件的BurshImage添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118161148857.png'></li>
<li>对Text控件的文本内容添加绑定函数；<img src='https://img-blog.csdnimg.cn/20201118161259306.png'></li>
</ol>
<h3 id="W-InventorySlot相关-1"><a href="#W-InventorySlot相关-1" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol>
<li>为UseButton内的Border添加OnMouseButtonDown绑定事件，监控鼠标左键；<img src='https://img-blog.csdnimg.cn/20201118160454867.png'></li>
<li>创建蓝图BP_DragDrop，选取父类为DragDropOperation，并创建变量InventoryItem(S_InventoryItem)和InventoryIndex(Integer)；</li>
<li>创建重载函数OnDragDetected，当鼠标左键拖拽物品时生成相应的拖拽图标(W_DragItem)实例，并创建拖拽Operation实例(BP_DragDrop)，将物品信息和物品索引保存在BP_DragDrop中；<img src='https://img-blog.csdnimg.cn/20201118162311682.png'></li>
<li>创建重载函数OnDrop，当拖拽后鼠标左键释放后，从BP_DragDrop中获取InventoryIndex(FromInventoryIndex)和InventorySlotIndex(ToInventoryIndex)，并调用接口函数UIMoveInventoryItem；<img src='https://img-blog.csdnimg.cn/2020111816420391.png'></li>
</ol>
<h3 id="C-Inventory相关"><a href="#C-Inventory相关" class="headerlink" title="C_Inventory相关"></a>C_Inventory相关</h3><ol>
<li>创建函数[Output(S_InventoryItem)]GetInventoryItem(InventoryIndex(Integer))，根据物品索引获取物品信息；<img src='https://img-blog.csdnimg.cn/2020111816541335.png'></li>
</ol>
<h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol>
<li>创建函数[Void]ClearInventoryIndexItem(ToInventoryIndex(Integer))，用于根据索引删除对应插槽处的物品；<img src='https://img-blog.csdnimg.cn/20201118170944877.png'></li>
<li>创建函数[Void]AddItem(Inventory(C_Inventory),ToInventoryIndex(Integer),InventoryItem(S_InventoryItem))，调用客户端事件Client_SetInventorySlotItem；<img src='https://img-blog.csdnimg.cn/20201118170440602.png'></li>
<li>创建函数[Void]RemoveItem(Inventory(C_Inventory),FromInventoryIndex(Integer))，调用客户端事件Client_ClearInventoryIndexItem；<img src='https://img-blog.csdnimg.cn/20201118171358351.png'></li>
<li>创建函数[Void]MoveItem(FromInventoryIndex(Integer),ToInventoryIndex(Integer))，调用C_Inventory的GetInventoryItem获取From和To插槽处的物品信息（可能为空）。若为空，则调用AddItem和RemoveItem函数，实现物品拖拽后背包UI更新；<img src='https://img-blog.csdnimg.cn/20201118165913588.png'><img src='https://img-blog.csdnimg.cn/20201118165939535.png'></li>
</ol>
<h3 id="RPG-PlayerController相关-2"><a href="#RPG-PlayerController相关-2" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol>
<li>实现接口函数事件EventUIMoveInventoryItem，调用服务端事件Server_MoveInventoryItem；<img src='https://img-blog.csdnimg.cn/20201118172144413.png'></li>
</ol>
<h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-MoveInventoryItem"><a href="#Server-MoveInventoryItem" class="headerlink" title="Server_MoveInventoryItem"></a>Server_MoveInventoryItem</h4><p>在C_InventoryManager事件图表中创建，调用函数MoveItem；<img src='https://img-blog.csdnimg.cn/20201118164516806.png'></p>
<h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-ClearInventoryIndexItem"><a href="#Client-ClearInventoryIndexItem" class="headerlink" title="Client_ClearInventoryIndexItem"></a>Client_ClearInventoryIndexItem</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearInventoryIndexItem；<img src='https://img-blog.csdnimg.cn/20201118170841858.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><h2 id="物品描述"><a href="#物品描述" class="headerlink" title="物品描述"></a>物品描述</h2><p><img src='https://img-blog.csdnimg.cn/20201118151239939.png'></p>
<h2 id="拖拽效果"><a href="#拖拽效果" class="headerlink" title="拖拽效果"></a>拖拽效果</h2><p><img src='https://img-blog.csdnimg.cn/20201118151448629.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(二十一)</title>
    <url>/2020/11/21/RPG-Dev-Log-21/</url>
    <content><![CDATA[<p>涉及内容：创建NPC交易窗口，RPC。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="创建NPC交易窗口"><a href="#创建NPC交易窗口" class="headerlink" title="创建NPC交易窗口"></a>创建NPC交易窗口</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>打开E_ItemType，新增枚举[恢复物品]；</li>
<li>打开ItemList，将Mana_Blue和Health_Red的ItemType更改为恢复物品；</li>
<li>创建结构体S_ActorContainerInfo，包含商店名字和商店格子数信息；<img src='https://img-blog.csdnimg.cn/20201121180731205.png'></li>
</ol>
<h3 id="BPI-InventoryInterface相关"><a href="#BPI-InventoryInterface相关" class="headerlink" title="BPI_InventoryInterface相关"></a>BPI_InventoryInterface相关</h3><ol>
<li>创建接口函数[Name(Text),InventorySize(Integer)]GetContainerProperties()；</li>
<li>创建接口函数[InventoryComponent(C_Inventory)]GetContainerInventory()：</li>
</ol>
<h3 id="BPI-HUDInterface相关"><a href="#BPI-HUDInterface相关" class="headerlink" title="BPI_HUDInterface相关"></a>BPI_HUDInterface相关</h3><ol>
<li>新增接口函数[void]UIOpenDrugStore(NPCActor(Actor))；</li>
</ol>
<h3 id="W-TransactionWindow相关"><a href="#W-TransactionWindow相关" class="headerlink" title="W_TransactionWindow相关"></a>W_TransactionWindow相关</h3><ol>
<li>创建控件W_TransActionWindow，作为玩家与NPC交易的窗口；<img src='https://img-blog.csdnimg.cn/20201121190422457.png'></li>
</ol>
<h3 id="W-Window相关"><a href="#W-Window相关" class="headerlink" title="W_Window相关"></a>W_Window相关</h3><ol>
<li>创建函数[void]InitializeWindow()，用于初始化窗口大小，并根据是否为玩家背包设置与背包有关的UI控件的可视性。此函数在EventPreConstruct中调用；<img src='https://img-blog.csdnimg.cn/20201121182921756.png'></li>
</ol>
<h3 id="W-PC-Main相关"><a href="#W-PC-Main相关" class="headerlink" title="W_PC_Main相关"></a>W_PC_Main相关</h3><ol>
<li>复制W_InventoryWindow并重命名为W_StoreWindow，作为商店窗口，并修改默认属性；</li>
</ol>
<h3 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h3><ol>
<li>添加组件C_Inventory，初始化构造函数中调用服务端事件ServerInitializeInventory，初始化商店格数InventorySize为40；<img src='https://img-blog.csdnimg.cn/20201121165624322.png'></li>
<li>创建函数[LocalInventoryItems(S_InventoryItem[])]GetDrugStoreList()，用于返回ItemList中类型为恢复物品的物品；<img src='https://img-blog.csdnimg.cn/20201121170545847.png'></li>
<li>创建函数[Success(Boolean)]LoadingInventoryItems(InventorySize(Integer),InventoryItems(S_InventoryItem[]))，调用C_Inventory中的LoadInventoryItem，将InventoryItems中的物品信息加载到C_Inventory；<img src='https://img-blog.csdnimg.cn/20201121171623894.png'></li>
<li>创建函数[Success(Boolean)]InitializeInventory()，调用函数GetDrugStoreList和LoadingInventoryItems完成药品商店初始化。此函数在事件图表EventBeginPlay中调用；<img src='https://img-blog.csdnimg.cn/202011211719312.png'></li>
<li>打开ClassSettings，将蓝图接口BPI_InventoryInterface添加进来，并实现接口函数GetContainerProperties和GetContainerInventory；<img src='https://img-blog.csdnimg.cn/20201121173006831.png'><img src='https://img-blog.csdnimg.cn/20201121173047376.png'></li>
<li>实现自定义事件OnClickedDrugStore，调用接口函数UIOpenDrugStore，并调用OnClickedEndTalk，打开商店窗口时结束对话；<img src='https://img-blog.csdnimg.cn/2020112118591311.png'></li>
</ol>
<h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol>
<li>创建函数[void]ClearActorContainerSize()，用于初始化W_Window中的变量AcotrContainerSlots并清空InventorySlotWrapBox中的子控件；<img src='https://img-blog.csdnimg.cn/20201121183836481.png'></li>
<li>创建函数[void]CreateContainerSize(ContainerSize(Interger))，调用函数ClearActorContainerSize，并根据AcotrContainerSlots创建W_InventorySlot的控件实例，并添加至InventorySlotWrapBox中；<img src='https://img-blog.csdnimg.cn/20201121184312962.png'></li>
<li>创建函数[void]SetStoreInventorySlot(StoreContainerIndex(Integer),ItemInformation(S_InventoryItem))，根据商店物品索引从ActorContainerSlots中获取ItemInformation；<img src='https://img-blog.csdnimg.cn/20201121184626593.png'></li>
<li>创建函数[void]OpenStoreContainerWindow()和[void]CloseStoreContainerWindow()，控制商店的显示和隐藏；<img src='https://img-blog.csdnimg.cn/20201121185413105.png'><img src='https://img-blog.csdnimg.cn/20201121185439139.png'></li>
<li>创建函数[void]LocalContainerSlots(ItemInformation(S_InventoryItem),ActorContainerProperties(S_ActorContainerInfo))，调用函数CreateContainerSize和SetStoreInventorySlot，循环添加商店物品，循环结束调用函数OpenStoreContainerWindow，打开商店窗口；<img src='https://img-blog.csdnimg.cn/20201121181311172.png'></li>
<li>创建函数[void]OpenContainer(ActorContainer(Actor))，调用接口函数GetContainerProperties和GetContainerInventory，并调用客户端事件Client_OpenContainer;<img src='https://img-blog.csdnimg.cn/2020112118024116.png'></li>
<li>创建函数[void]UseContainer(ActorContainer(Actor))，调用函数OpenContainer；<img src='https://img-blog.csdnimg.cn/20201121175646264.png'></li>
</ol>
<h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol>
<li>调用蓝图接口事件EventUIOpenDrugStore，调用服务端事件ServerUseContainer和ClientOpenInventory；<img src='https://img-blog.csdnimg.cn/20201121174630228.png'></li>
</ol>
<h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-UseContainer"><a href="#Server-UseContainer" class="headerlink" title="Server_UseContainer"></a>Server_UseContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数UseContainer；<img src='https://img-blog.csdnimg.cn/20201121175304205.png'></p>
<h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-OpenContainer"><a href="#Client-OpenContainer" class="headerlink" title="Client_OpenContainer"></a>Client_OpenContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数LocalContainerSlots；<img src='https://img-blog.csdnimg.cn/20201122145956711.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p>(Bug尚未解决，后续补上)</p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(二十二)</title>
    <url>/2020/11/22/RPG-Dev-Log-22/</url>
    <content><![CDATA[<p>涉及内容：联网测试交易物品，RPC。</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>说明：</p>
<p>为了描述方便，定义<strong>SWAP_SLOT_INFO</strong> =(FromInventoryIndex(Integer),ToInventoryIndex(Integer),FromInventorySlotType(E_InventorySlotType),ToInventoryType(E_InventorySlotType)）</p>
<h2 id="联网测试交易物品"><a href="#联网测试交易物品" class="headerlink" title="联网测试交易物品"></a>联网测试交易物品</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="相关枚举及结构体"><a href="#相关枚举及结构体" class="headerlink" title="相关枚举及结构体"></a>相关枚举及结构体</h4><ol>
<li>创建枚举E_InventorySlotType[PlayerInventory,DrugStore]；</li>
<li>打开S_ActorContainerInfo，新增成员InventorySlotType(E_InventorySlotType)；</li>
</ol>
<h4 id="相关蓝图接口"><a href="#相关蓝图接口" class="headerlink" title="相关蓝图接口"></a>相关蓝图接口</h4><h5 id="BPI-InventoryInterface相关"><a href="#BPI-InventoryInterface相关" class="headerlink" title="BPI_InventoryInterface相关"></a>BPI_InventoryInterface相关</h5><ol>
<li>接口函数功能扩展：将GetContainerProperties返回值[Name,InventorySize]扩展至[Name,InventorySize,InventorySlotType]；</li>
<li>创建接口函数[PlayersViewing(PlayerState[])GetPlayersViewing();</li>
</ol>
<h5 id="BPI-HUDInterface相关"><a href="#BPI-HUDInterface相关" class="headerlink" title="BPI_HUDInterface相关"></a>BPI_HUDInterface相关</h5><ol>
<li>创建接口函数[void]UIOpenTransactionWindow(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))；</li>
<li>创建接口函数[Level(Integer),Moneny(Integer)]GetPlayerStatus()；</li>
<li>创建接口函数[void]AddMoney(Money)；</li>
<li>创建接口函数[void]UISplitInventoryItem(<strong>SWAP_SLOT_INFO</strong>,Amount(Integer));</li>
</ol>
<h5 id="BPI-UsableActorContainer相关"><a href="#BPI-UsableActorContainer相关" class="headerlink" title="BPI_UsableActorContainer相关"></a>BPI_UsableActorContainer相关</h5><ol>
<li>创建接口函数[Success(Boolean)]OnActorUsed(Controller(PlayerController))；</li>
</ol>
<h3 id="BP-DragDrop相关"><a href="#BP-DragDrop相关" class="headerlink" title="BP_DragDrop相关"></a>BP_DragDrop相关</h3><ol>
<li>新增变量InventorySlotType(E_InventorySlotType)；</li>
</ol>
<h3 id="W-InventorySlot相关"><a href="#W-InventorySlot相关" class="headerlink" title="W_InventorySlot相关"></a>W_InventorySlot相关</h3><ol>
<li>函数功能扩展：对拽取物品的来源和去向InventorySlotType类型进行判断。若相同=&gt;若为玩家背包，则可直接拖拽；否则不执行任何动作。若不相同=&gt;调用蓝图接口事件UIOpenTransactionWindow，完成物品交易；<img src='https://img-blog.csdnimg.cn/2020112414060153.png'></li>
</ol>
<h3 id="W-TransactionWindow相关"><a href="#W-TransactionWindow相关" class="headerlink" title="W_TransactionWindow相关"></a>W_TransactionWindow相关</h3><ol>
<li>创建函数[void]Update(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))，完成交易物品信息的更新；<img src='https://img-blog.csdnimg.cn/20201124142235157.png'></li>
<li>创建函数[Value(Integer),Success(Boolean)]CheckMoneyforShopping()，调用蓝图接口函数GetPlayerStatus获取玩家Money信息，用于检查玩家是否有足够的金额完成物品交易；<img src='https://img-blog.csdnimg.cn/20201124144439936.png'></li>
<li>为标题Text文本内容绑定函数；<img src='https://img-blog.csdnimg.cn/20201124142437710.png'></li>
<li>为交易物品Text文本内容及文本颜色绑定函数；<img src='https://img-blog.csdnimg.cn/20201124142522849.png'><img src='https://img-blog.csdnimg.cn/20201124142703490.png'></li>
<li>为交易数量EditableTextBox文本输入内容绑定函数，并添加OnTextCommitted事件；<img src='https://img-blog.csdnimg.cn/20201124142703490.png'><img src='https://img-blog.csdnimg.cn/20201124143142740.png'></li>
<li>为交易金额Text文本内容绑定函数。买入是全额，卖出将收取40%税收；<img src='https://img-blog.csdnimg.cn/20201124143451360.png'></li>
<li>为TextToolTip添加文本内容和文本颜色绑定函数；<img src='https://img-blog.csdnimg.cn/2020112419420578.png'><img src='https://img-blog.csdnimg.cn/20201124194330426.png'></li>
<li>为Minus和Plus按钮添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194820238.png'></li>
<li>为Min和Max按钮添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194928322.png'></li>
<li>为CancelButton和ConfirmButton添加绑定事件；<img src='https://img-blog.csdnimg.cn/20201124194629484.png'></li>
</ol>
<h3 id="C-Inventory相关"><a href="#C-Inventory相关" class="headerlink" title="C_Inventory相关"></a>C_Inventory相关</h3><ol>
<li>创建函数[Index(Integer),Success(Boolean)]GetEmptyInventorySpace()，用于背包空闲slot的寻找；<img src='https://img-blog.csdnimg.cn/20201124182952573.png'></li>
</ol>
<h3 id="C-InventoryManager相关"><a href="#C-InventoryManager相关" class="headerlink" title="C_InventoryManager相关"></a>C_InventoryManager相关</h3><ol>
<li>创建函数[void]OpenTransactionWindow(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))，调用函数[void]Update(<strong>SWAP_SLOT_INFO</strong>,ItemInformation(S_InventoryItem))；<img src='https://img-blog.csdnimg.cn/20201124144935982.png'></li>
<li>创建函数[void]CountMoney()，将BP_Player中的CountMoney函数迁移过来；<img src='https://img-blog.csdnimg.cn/20201124145309889.png'></li>
<li>创建函数[StructOut(S_InventoryItem)]AddToItemAmount(ItemInformation(S_InventoryItem),AmountToAdd(Integer))，将修改后的ItemInformation导出；<img src='https://img-blog.csdnimg.cn/20201124163958914.png'></li>
<li>创建函数[void]SetActorContainerSlotItem(ActorContainerIndex)；<img src='https://img-blog.csdnimg.cn/20201124181438471.png'></li>
<li>创建函数[void]SetViewersActorContainerSlot(ActorContainerSlot(Integer),ItemInformation(S_InventoryItem))，，调用客户端事件ClientSetActorContainerSlotItem，用于同步客户端交易信息；<img src='https://img-blog.csdnimg.cn/20201124180507375.png'></li>
<li>函数功能扩展：为函数AddItem添加Inventory判断，若为PlayerInventory则正常移动，否则调用函数SetViewersActorContainerSlot;<img src='https://img-blog.csdnimg.cn/20201124164936346.png'></li>
<li>创建函数[RemainingAmount(Integer)]AddItemToStack(InventoryComponent(C_Inventory),InventoryIndex(Integer),Amount(Integer))，根据叠加上限MaxStackSize减去叠加数目Amount计算出剩余生成数量RemainingAmount，调用函数AddToItemAmount完成InventoryItem信息修改，并返回RemainingAmount；<img src='https://img-blog.csdnimg.cn/20201124164315887.png'><img src='https://img-blog.csdnimg.cn/2020112416440786.png'><img src='https://img-blog.csdnimg.cn/20201124164435782.png'></li>
<li>创建函数[Struct(S_InventoryItem)]SetItemAmount(InventoryItem(S_InventoryItem),Amount(Integer))，用于物品数量的修改；<img src='https://img-blog.csdnimg.cn/20201124182550508.png'></li>
<li>创建函数[Output_Get(Integer),WasFullAmountRemove(Boolean),StructOut(S_InventoryItem)]RemoveFromItemAmount(InventoryItem(S_InventoryItem),AmountToRemove(Integer))；<img src='https://img-blog.csdnimg.cn/20201124191915761.png'></li>
<li><p>函数功能扩展：为函数MoveItem添加两个新的传入参数FromInventoryComponent和ToComponent</p>
<ul>
<li><p>判断是否为有效移动，若为有效移动，将传入参数创建为本地变量<img src='https://img-blog.csdnimg.cn/20201124184819754.png'></p>
</li>
<li><p>判断移动到另一物品上还是空白位置<img src='https://img-blog.csdnimg.cn/20201124184927617.png'></p>
<ul>
<li><p>移动到空白位置<img src='https://img-blog.csdnimg.cn/20201124185055331.png'></p>
</li>
<li><p>移动到另一物品上，判断是否为相同物品<img src='https://img-blog.csdnimg.cn/2020112418501065.png'></p>
<ul>
<li>为相同物品，判断是否超出堆叠上限<img src='https://img-blog.csdnimg.cn/20201124185330475.png'><ul>
<li>未超出，直接进行叠加<img src='https://img-blog.csdnimg.cn/20201124185413385.png'></li>
<li>超出，需要寻找空白位置并额外创建物品<img src='https://img-blog.csdnimg.cn/20201124185603858.png'></li>
</ul>
</li>
<li>不是相同物品，判断是否为玩家背包<img src='https://img-blog.csdnimg.cn/20201124185747664.png'><ul>
<li>若为玩家背包，直接进行物品对调<img src='https://img-blog.csdnimg.cn/20201124185836885.png'></li>
<li>若为商店背包<img src='https://img-blog.csdnimg.cn/20201124195641468.png'></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创建函数[void]SplitItem(FromInventory(C_Inventory),ToInventory(C_Inventory),FromInventoryIndex(Integer),ToInventoryIndex(Integer),Amount(Integer))，具体思路同MoveItem函数；<img src='https://img-blog.csdnimg.cn/20201124193737972.png'></li>
<li>创建函数[void]CloseActorContainer()，调用接口函数GetPlayersViewing和客户端事件Client_CloseActorContainer；<img src='https://img-blog.csdnimg.cn/20201124172748143.png'></li>
<li>创建函数[void]ClearContainerSlotItem(ContainerSlot(Integer))；<img src='https://img-blog.csdnimg.cn/20201124200200108.png'></li>
<li>创建函数[void]ClearViewersActorContainer(ActorContainerSlot(Integer))，调用客户端事件Client_ClearActorContainerSlotItems；<img src='https://img-blog.csdnimg.cn/2020112420035559.png'></li>
</ol>
<h3 id="BP-RPG-NPC相关"><a href="#BP-RPG-NPC相关" class="headerlink" title="BP_RPG_NPC相关"></a>BP_RPG_NPC相关</h3><ol>
<li>实现接口函数GetPlayersViewing，将PlayerState信息导出；<img src='https://img-blog.csdnimg.cn/20201124165756372.png'></li>
<li>将蓝图接口BPI_UsableActorContainer添加进来，并实现接口函数OnActorUsed，调用服务端事件ServerUseContainer；<img src='https://img-blog.csdnimg.cn/20201124170731704.png'></li>
</ol>
<h3 id="RPG-PlayerController相关"><a href="#RPG-PlayerController相关" class="headerlink" title="RPG_PlayerController相关"></a>RPG_PlayerController相关</h3><ol>
<li><p>实现蓝图接口事件EventUIOpenTransactionWindow，调用客户端事件Client_OpenTransactionWindow；<img src='https://img-blog.csdnimg.cn/20201124141309624.png'></p>
</li>
<li><p>实现蓝图接口事件EventAddMoney，调用客户端事件Client_AddMoney；<img src='https://img-blog.csdnimg.cn/20201124152053403.png'></p>
</li>
<li><p>实现蓝图接口事件EventUISplitInventoryItem，调用客户端事件ServerSplitInventoryItem；<img src='https://img-blog.csdnimg.cn/2020112415291059.png'></p>
</li>
<li><p>实现接口函数[Level(Integer),Moneny(Integer)]GetPlayerStatus()，将服务端Replicated到客户端的变量Level和Money信息导出；<img src='https://img-blog.csdnimg.cn/20201124150829781.png'></p>
</li>
<li><p>创建函数[HitActor(Actor)]GetUsableActor()，HitActor在BP_Player中完成设置；</p>
<p><img src='https://img-blog.csdnimg.cn/20201124171800115.png'><img src='https://img-blog.csdnimg.cn/202011241715382.png'></p>
</li>
<li><p>创建函数[void]OnActorUsed()，调用函数GetUsableActor和接口函数OnActorUsed；<img src='https://img-blog.csdnimg.cn/20201124172200596.png'></p>
</li>
</ol>
<h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><h3 id="Run-on-Server-Reliable"><a href="#Run-on-Server-Reliable" class="headerlink" title="Run on Server(Reliable)"></a>Run on Server(Reliable)</h3><h4 id="Server-SplitInventoryItem"><a href="#Server-SplitInventoryItem" class="headerlink" title="Server_SplitInventoryItem"></a>Server_SplitInventoryItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SplitItem；<img src='https://img-blog.csdnimg.cn/20201124153530678.png'></p>
<h4 id="Server-OnActorUsed"><a href="#Server-OnActorUsed" class="headerlink" title="Server_OnActorUsed"></a>Server_OnActorUsed</h4><p>在RPG_PlayerController事件图表中创建，调用函数OnActorUsed和客户端事件Client_OpenInventory；<img src='https://img-blog.csdnimg.cn/20201124171333609.png'></p>
<h4 id="Server-CloseActorContainer"><a href="#Server-CloseActorContainer" class="headerlink" title="Server_CloseActorContainer"></a>Server_CloseActorContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseActorContainer；<img src='https://img-blog.csdnimg.cn/20201124195158920.png'></p>
<h4 id="Server-TransactionItem"><a href="#Server-TransactionItem" class="headerlink" title="Server_TransactionItem"></a>Server_TransactionItem</h4><p>在W_TransactionWindow事件图表中创建；<img src='https://img-blog.csdnimg.cn/20201124195108141.png'></p>
<h3 id="Run-on-owning-Client-Reliable"><a href="#Run-on-owning-Client-Reliable" class="headerlink" title="Run on owning Client(Reliable)"></a>Run on owning Client(Reliable)</h3><h4 id="Client-OpenTransactionWindow"><a href="#Client-OpenTransactionWindow" class="headerlink" title="Client_OpenTransactionWindow"></a>Client_OpenTransactionWindow</h4><p>在C_InventoryManager事件图表中创建，调用函数OpenTransactionWindow；<img src='https://img-blog.csdnimg.cn/20201124140959167.png'></p>
<h4 id="Client-AddMoney"><a href="#Client-AddMoney" class="headerlink" title="Client_AddMoney"></a>Client_AddMoney</h4><p>在C_InventoryManager事件图表中创建，将BP_Player中的自定义事件GetMoney迁移过来；<img src='https://img-blog.csdnimg.cn/20201124145658353.png'></p>
<h4 id="Client-CloseActorContainer"><a href="#Client-CloseActorContainer" class="headerlink" title="Client_CloseActorContainer"></a>Client_CloseActorContainer</h4><p>在C_InventoryManager事件图表中创建，调用函数CloseActorContainerWindow;<img src='https://img-blog.csdnimg.cn/20201124173309109.png'></p>
<h4 id="Client-SetActorContainerSlotItem"><a href="#Client-SetActorContainerSlotItem" class="headerlink" title="Client_SetActorContainerSlotItem"></a>Client_SetActorContainerSlotItem</h4><p>在C_InventoryManager事件图表中创建，调用函数SetActorContainerSlotItem;<img src='https://img-blog.csdnimg.cn/20201124181051489.png'></p>
<h4 id="Client-ClearActorContainerSlotItems"><a href="#Client-ClearActorContainerSlotItems" class="headerlink" title="Client_ClearActorContainerSlotItems"></a>Client_ClearActorContainerSlotItems</h4><p>在C_InventoryManager事件图表中创建，调用函数ClearContainerSlotItem;<img src='https://img-blog.csdnimg.cn/20201124195950691.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p>(Bug尚未解决，后续补上)</p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(三)</title>
    <url>/2020/10/13/RPG-Dev-Log-3/</url>
    <content><![CDATA[<p>涉及内容：人物等级属性绑定，经验条动画效果等。<br><a id="more"></a></p>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>UI素材来源：</p>
<p>虚幻商城[Advanced Mission And Notification System]</p>
<p><a href="http://www.aigei.com/">爱给网</a> [SlicedImages]</p>
<h2 id="经验条动画效果"><a href="#经验条动画效果" class="headerlink" title="经验条动画效果"></a>经验条动画效果</h2><ol>
<li><p>创建Widget [W_Level]，涉及素材资源：进度条和经验徽章边框,</p>
<p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201013221953333.png'></p>
<p>最终效果,<img src='https://img-blog.csdnimg.cn/20201013222300719.png'></p>
</li>
<li><p>创建HideXPBar动画(0.5s，第一帧X轴缩放为0，最后一帧为1);<img src='https://img-blog.csdnimg.cn/20201013222531735.png'></p>
</li>
<li><p>打开Event Graph，事件构造时绑定Character Level 至Level Text;</p>
</li>
<li><p>创建宏 [Exec] PlayAnimation(Exec,Boolean)，用于经验条动画循环播放以及播放模式设置；<img src='https://img-blog.csdnimg.cn/20201013223428875.png'></p>
</li>
<li><p>创建函数 [void] IncreaseXP()，用于更新level经验条百分比，此处利用Handle可以在任意位置暂停和恢复运行经验条动画；<img src='https://img-blog.csdnimg.cn/20201013223800968.png'></p>
</li>
<li><p>在StarterContent资源包中搜索P_Explosion粒子特效，删除FireBall、Sparks、fire_Light、Smoke效果，更改shockwave参数，达到以下效果；<img src='https://img-blog.csdnimg.cn/20201013225153345.png'></p>
</li>
<li><p>搜索Shibi角色升级的相关动画，在合适位置添加粒子特效动画和音效，并以此为基础创建AnimMontage;<img src='https://img-blog.csdnimg.cn/2020101322552387.png'></p>
</li>
<li><p>打开控件蓝图W_PC_Main，关联Shibi和W_Level，以便获取character movement;</p>
</li>
<li><p>创建自定义事件 void GetXP(Float)，调用PlayAnimation和IncreaseXP，完成经验的增加，等级的更新，经验条上限更改，以及升级时添加动画蒙太奇（蓝图较复杂，不再展示）；</p>
</li>
<li><p>打开人物蓝图Char_Shibi，添加Key F键盘事件，调用自定义事件GetXP。</p>
</li>
</ol>
<h2 id="任务等级属性绑定"><a href="#任务等级属性绑定" class="headerlink" title="任务等级属性绑定"></a>任务等级属性绑定</h2><h3 id="血条-蓝条材质球创建"><a href="#血条-蓝条材质球创建" class="headerlink" title="血条/蓝条材质球创建"></a>血条/蓝条材质球创建</h3><ol>
<li><p>创建Material，Material Domain设置为User Interface，Blend Mode设置为Masked,导入uf_fill_green（填充效果图），相关蓝图如下；<img src='https://img-blog.csdnimg.cn/20201013230852397.png'> <img src='https://img-blog.csdnimg.cn/20201013230948299.png'></p>
</li>
<li><p>创建材质实例Inst_HealthBar和HealthRemove，修改公开变量Texture 、Scaler(PercentLeft、PercentRight)、Vector(Color)；</p>
</li>
<li><p>用同样的方法复制创建Inst_ManaBar和Inst_ManaRemove;</p>
</li>
</ol>
<h3 id="血条-蓝条-角色Border控件蓝图创建"><a href="#血条-蓝条-角色Border控件蓝图创建" class="headerlink" title="血条/蓝条/角色Border控件蓝图创建"></a>血条/蓝条/角色Border控件蓝图创建</h3><ol>
<li><p>创建Widget [W_HealthBar]，</p>
<p>层级面板如下，<img src='https://img-blog.csdnimg.cn/2020101323190811.png'></p>
<p>最终效果；<img src='https://img-blog.csdnimg.cn/20201013232000940.png'></p>
</li>
<li><p>用同样的方法复制一份，修改参数命名为W_ManaBar;</p>
</li>
<li><p>创建Widget [W_CharacterBorder]，整合frame、HealthBar、ManaBar、StaminaBar、LevelText&amp;Border、Figure&amp;Border、BuffBox，</p>
<p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201013232626224.png'></p>
<p>最终效果；<img src='https://img-blog.csdnimg.cn/20201013232731899.png'></p>
</li>
</ol>
<h3 id="Shibi人物蓝图修改"><a href="#Shibi人物蓝图修改" class="headerlink" title="Shibi人物蓝图修改"></a>Shibi人物蓝图修改</h3><ol>
<li>修改[S_Attribute] UpdateAttribute(E_Attribute)为[void] UpdateAttribute(E_Attribute)，扩展函数功能（由原先的计算和更新血球百分比，动态颜色，扩展至Mana、Stamina，函数核心逻辑不变；<img src='https://img-blog.csdnimg.cn/20201013233125525.png'></li>
<li>修改[void] SetupAttributeBars()，扩展函数功能（由原先的Health、Mana扩展至Stamina);<img src='https://img-blog.csdnimg.cn/20201013233517102.png'></li>
<li>修改Num-/+ 键盘事件，测试扩展至Mana、Stamina;<img src='https://img-blog.csdnimg.cn/20201013233813393.png'></li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201013220531552.gif'></p>
<p><img src='https://img-blog.csdnimg.cn/20201013220800638.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(四)</title>
    <url>/2020/10/14/RPG-Dev-Log-4/</url>
    <content><![CDATA[<p>涉及内容：自动回复系统，迷你小地图制作，IceLands场景导入等。<br><a id="more"></a></p>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>UI素材来源：</p>
<p>虚幻商城[Infinity Blade IceLands]</p>
<p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：目标]</p>
<h2 id="自动回复系统"><a href="#自动回复系统" class="headerlink" title="自动回复系统"></a>自动回复系统</h2><ol>
<li>打开W_Level，创建Event Dispatchers(事件调度器) UpdateLevel(Integer)，并在CharacterLevel更新后调用;</li>
<li>打开人物蓝图Char_Shibi，创建自定义事件[void] UpLevel(Integer),用于升级后更新血量/蓝条/耐力值上限,并将W_Level中有关升级粒子动画特效的蓝图迁移整合；<img src='https://img-blog.csdnimg.cn/20201014174148886.png'></li>
<li>修改[void] ModifyAttribute(E_Attribute,Float)为[void] ModifyAttribute(E_Attribute,Float,Float),扩展函数功能，第三个参数MaxValue用于更新升级后的血量/蓝条/耐力值上限，思路与ModifyValue类似；</li>
<li>在Event BeginPlay事件末尾绑定事件调度器UpdateLevel至自定义事件UpLevel;<img src='https://img-blog.csdnimg.cn/20201014174040200.png'></li>
<li>打开W_Level事件图表，将GetXP事件后的结点折叠至图表LoopLevel;</li>
<li>打开W_PC_Main事件图表，删除Event Construct后有关获取W_Level等自定义组件的节点；</li>
<li>打开S_Attribute，添加RegenInterval[Float]（回复间隔）、MaxRegenTime[Float]（最大回复时间）、RegenFunctionName[String]（回复回调函数名）、RegenTimerHandle[TimerHandle]（回复TimerHandle);</li>
<li>打开Char_Shibi，设置Attributes，单次回复量=MaxValue*(RegenInterval/MaxRegenTime)，按照公式，设置数值，使得单次回复量耐力值&gt;血量&gt;灵力；</li>
<li>创建回调函数[void]HealthRegenTick()、[void]ManaRegenTick()、[void]StaminaRegenTick()回调函数，用于脱战状态和战斗状态回复数值计算，三个函数仅参数不同；<img src='https://img-blog.csdnimg.cn/20201027161819931.png'></li>
<li>创建函数[void] HandleRegeneration(E_Attribute)，当状态回满时，使用TimerHandle中断回调函数;<img src='https://img-blog.csdnimg.cn/20201027214351835.png'></li>
<li>创建自定义事件Regenerations,在Event BeginPlay调用，用于循环更新Health/Mana/Stamina相关值，事件末尾调用HandleRegeneration，启用和中止相关tick函数；<img src='https://img-blog.csdnimg.cn/20201014180647554.png'></li>
<li>函数ModifyAttribute末尾也添加HandleRegeneration的调用，每次修改后都进行一次TimerHandle核对；</li>
</ol>
<h2 id="迷你小地图制作"><a href="#迷你小地图制作" class="headerlink" title="迷你小地图制作"></a>迷你小地图制作</h2><ol>
<li>创建Render Target [MiniMap],右键创建Material [M_MiniMap_Mat]，设置Material Domain=User Interface,Blend Mode=Translucent，编辑蓝图如下;<img src='https://img-blog.csdnimg.cn/2020101423132354.png'></li>
<li>创建材质实例[Inst_MiniMap_Mat];</li>
<li>选取父类为SceneCapture2D创建蓝图MiniCapture,将TextureTarget设置为[MiniMap],并取消勾选天气、光线、特效的ShowFlags；</li>
<li>打开人物蓝图BP_RPG_Character，添加SpringArm、ChildActor,调整SpringArm的Rotation和Arm Length；</li>
<li>导入direction图标，修改Compression Settings=UserInterface2D(RGBA)，Texture Group=UI，右键创建sprite；</li>
<li>返回BP_RPG_Character，添加PaperSprite，将刚创建的direction_sprite添加进来，调整rotation，修改颜色，并将碰撞预设设为NoCollision,并勾选Render&gt;Owner No See;</li>
<li>创建Widget [W_MiniMap]，将Inst_MiniMap_Mat以及相关minimap frame添加进来，并调整zOder顺序，根据[W_MiniMap]中的效果修改Inst_MiniMap_Mat中Density和Radius的值；</li>
<li>在W_MiniMap中添加Plus和Minus按钮，用于缩放地图，设计思路为：获取Actor[MiniCapture]的拷贝，并通过它获取Capture Component 2D,修改FOV Angle;<img src='https://img-blog.csdnimg.cn/20201014232845269.png'></li>
</ol>
<h2 id="IceLands场景导入"><a href="#IceLands场景导入" class="headerlink" title="IceLands场景导入"></a>IceLands场景导入</h2><ol>
<li>将Map [FrozenCove]导入并构建，打开World Settings，设置Game Mode 为RPG_GameMode;</li>
<li>完成光源的简单布置，光源大小、颜色、数量等，将部分PointLight由Stationary改为Static；</li>
<li>完成场景地面的延伸扩展，Nav Mesh Bounds的延伸扩展（需勾选Can ever Affect Navigation),为扩展的地面添加Default碰撞预设；</li>
<li>修改玩家出生点至平台。</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201014171750989.gif'></p>
<p><img src='https://img-blog.csdnimg.cn/2020101417191758.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(五)</title>
    <url>/2020/10/18/RPG-Dev-Log-5/</url>
    <content><![CDATA[<p>涉及内容：跳跃动作制作，创建任务系统（开篇）</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>虚幻商城[Advanced Mission And Notification System]</p>
<h2 id="跳跃动作制作"><a href="#跳跃动作制作" class="headerlink" title="跳跃动作制作"></a>跳跃动作制作</h2><ol>
<li>打开ABP_Shibi事件图表，将Is Falling返回值保存至变量IsInAir;</li>
<li>进入状态机，添加Idle_Move&lt;=&gt;Jump状态过渡，并将过渡规则与IsInAir关联；</li>
<li>进入Jump状态，新建状态机Jump，点击进入，设置Entry-&gt;JumpStart=&gt;Loop=&gt;JumpEnd状态过渡，并将过渡规则设置为自动；</li>
<li>为JumpStart、Loop、JumpEnd添加Jump_Start、Jump_Apex、Jump_Land,并调整播放速率；</li>
<li>打开Char_Shibi事件图表，添加Space Bar键盘事件，使得角色获得二段跳能力；<img src='https://img-blog.csdnimg.cn/20201018130500837.png'></li>
<li>打开CharacterMovement细节面板，设置Character Movement:Jump/Falling，Jump Z Velocity=620，Air Control=0.5;</li>
</ol>
<h2 id="创建任务系统（开篇）"><a href="#创建任务系统（开篇）" class="headerlink" title="创建任务系统（开篇）"></a>创建任务系统（开篇）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>创建枚举E_QuestCategories = {主线任务，支线任务，副本任务}；</li>
<li>创建枚举E_Regions = {冰岛，洞穴，香格里拉}；</li>
<li>创建枚举E_SubGoalType = {Custom,Hunt,Search,Talk};</li>
<li>创建结构体S_QuestReward = {Money(Integer),Experience(Integer),Prestige(Integer)};</li>
<li>创建结构体S_TargetLocation = {HasLocation?(Boolean),Location(Vector)};</li>
<li>创建结构体S_SubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018132339967.png'></li>
<li>创建结构体S_QuestInfo;<img src='https://img-blog.csdnimg.cn/20201018132440276.png'></li>
</ol>
<h3 id="创建任务实例的父类"><a href="#创建任务实例的父类" class="headerlink" title="创建任务实例的父类"></a>创建任务实例的父类</h3><h4 id="变量创建"><a href="#变量创建" class="headerlink" title="变量创建"></a>变量创建</h4><ol>
<li>创建Actor BP_MasterQuest,作为创建任务实例的父类；</li>
<li>创建变量QuestInfo(S_QuestInfo)，用于记录所有<strong>Quest</strong>信息；</li>
<li>创建变量StartSubGoalIndices(Integer [])，用于记录开始<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li>
<li>创建变量CurrentSubGoalIndices(Integer [])，用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>索引；</li>
<li>创建变量CurrentHuntedAmount(Integer[])，用于记录当前猎杀数量；</li>
<li>创建变量CurrentSubGoalInfo(S_SubGoalInfo []),用于记录当前<strong>Quest</strong>所有<strong>SubGoal</strong>信息；</li>
<li>创建变量SelectedSubGoalIndex(Integer)，用于记录当前选择的<strong>SubGoal</strong>索引；</li>
</ol>
<h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><ol>
<li>创建函数void UpdateSubGoalInfo(),用于根据CurrentSubGoalIndices，更新CurrentSubGoalInfo；<img src='https://img-blog.csdnimg.cn/20201018135432102.png'></li>
<li>创建函数void SetopStartingSubGoals()，用于设置CurrentSubGoalIndices,并调用UpdateSubGoalInfo;<img src='https://img-blog.csdnimg.cn/20201018135750624.png'></li>
<li>创建函数Boolean GoToNextSubGoal()，用于判断当前Quest是否还有SubGoal，若有，则将NextIndex保存至CurrentSubGoalIndices，并返回true;<img src='https://img-blog.csdnimg.cn/20201018140354801.png'></li>
</ol>
<h3 id="创建UI"><a href="#创建UI" class="headerlink" title="创建UI"></a>创建UI</h3><h4 id="创建W-SubGoal"><a href="#创建W-SubGoal" class="headerlink" title="创建W_SubGoal"></a>创建W_SubGoal</h4><ol>
<li><p>创建Widget [W_SubGoal],</p>
<p>层级面板如下<img src='https://img-blog.csdnimg.cn/20201018141429316.png'>,</p>
<p>最终效果<img src='https://img-blog.csdnimg.cn/20201018141521486.png'>;</p>
</li>
<li><p>打开事件图表</p>
<p><strong>创建变量</strong></p>
<p>W_Quest_SubGoalInfo(S_SubGoalInfo)，</p>
<p>W_Quest_AssignedQuest(BP_MasterQuest),</p>
<p>W_Quest(W_Quest),</p>
<p>SubGoalIndex(Integer),</p>
<p>SubGoalInfo(Text);</p>
<p><strong>创建函数</strong></p>
<p>void Update(),用于根据W_Quest_SubGoalInfo从W_Quest_AssignedQuest中获取QuestInfo，并更新Text;<img src='https://img-blog.csdnimg.cn/20201018143047970.png'></p>
<p><strong>函数调用</strong></p>
<p>事件开始构造时调用Update()，点击SelectedButton时调用W_Quest中的SelectSubGoal()；</p>
</li>
</ol>
<h4 id="创建W-Quest"><a href="#创建W-Quest" class="headerlink" title="创建W_Quest"></a>创建W_Quest</h4><ol>
<li><p>创建Widget [W_Quest]，</p>
<p>层级面板如下,<img src='https://img-blog.csdnimg.cn/20201018144005433.png'></p>
<p>最终效果<img src='https://img-blog.csdnimg.cn/20201018144100772.png'>;</p>
</li>
<li><p>打开事件图表</p>
<p><strong>创建变量</strong></p>
<p>SubGoalWidgets(W_SubGoal),</p>
<p>AssignedQuest(BP_MasterQuest),</p>
<p>SelectedSubGoal(W_SubGoal);</p>
<p><strong>创建函数</strong></p>
<ol>
<li><p>void GenerateSubGoal(),用于清空SubGolaVerticalBox，并从AssignedQuest中获取CurrentSubGoalInfo,循环添加至SubGolaVerticalBox;<img src='https://img-blog.csdnimg.cn/20201018145035536.png'></p>
</li>
<li><p>void UpdateCurrentSubGoal(),用于更新SubGoalIcon、SubGoalType、SubGoalInfo等控件信息；<img src='https://img-blog.csdnimg.cn/20201018152129831.png'></p>
</li>
<li><p>void SelectSubGoal(W_SubGoal)，用于激活SelectedButton,并调用UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/202010181515354.png'></p>
</li>
<li><p>void UpdateQuest(Quest),用于从AssignedQuest中获取CurrentSubGoalInfo，根据任务Categories设置文本和任务图标样式，并调用GenerateSubGoal和UpdateCurrentSubGoal;<img src='https://img-blog.csdnimg.cn/20201018151930868.png'></p>
</li>
</ol>
</li>
</ol>
<h3 id="创建QuestManager"><a href="#创建QuestManager" class="headerlink" title="创建QuestManager"></a>创建QuestManager</h3><ol>
<li><p>创建Actor Componet [QuestManager]，并添加至Char_Shibi;</p>
</li>
<li><p>创建变量</p>
<p>CurrentQuest(BP_MasterQuest),</p>
<p>AllQuests(BP_MasterQuest[] Object reference),</p>
<p>AllQuestClasses(BP_MasterQuest[] class reference),</p>
<p>Shibi(Char_Shibi);</p>
</li>
<li><p>创建函数void AddQuest(BP_MasterQuest),用于从所有Quest class中添加、生成Quest Actor实例,并调用BP_MasterQuest.SetupStartingSubGoals和W_Quest.UpdateQuest;<img src='https://img-blog.csdnimg.cn/20201018153733195.png'></p>
</li>
</ol>
<h3 id="绑定Q键盘事件"><a href="#绑定Q键盘事件" class="headerlink" title="绑定Q键盘事件"></a>绑定Q键盘事件</h3><p><img src='https://img-blog.csdnimg.cn/20201018154325823.png'></p>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201018123029836.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201018123051461.png'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(六)</title>
    <url>/2020/10/20/RPG-Dev-Log-6/</url>
    <content><![CDATA[<p>涉及内容：创建NPC，骨骼重定向，任务互动发放等；</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p>
<p>虚幻商城[Generic NPC Anim Pack]</p>
<p>虚幻商城[Infinity Blade:Warriors]</p>
<p>虚幻商城[Advanced Locomotion System]</p>
<p>内置Package[Mannequin]添加组件S</p>
<p>Adobe官网<a href="https://www.mixamo.com/">Mixamo</a></p>
<p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：圆、问号]</p>
<h2 id="创建NPC"><a href="#创建NPC" class="headerlink" title="创建NPC"></a>创建NPC</h2><ol>
<li>打开BP_RPG_Character，删除组件MapArm及其附属组件ChildActor;</li>
<li>以BP_RPG_Character为父类，创建蓝图BP_RPG_NPC;</li>
<li>下载地图指示图标，右键Apply Paper2D Texture Settings,并Create Sprite。将圆形图标添加到NPC的PaperSprite；</li>
<li>为BP_RPG_NPC添加组件SpringArm及其附属组件ChildActor,ChildActor Class选取MiniCapture;</li>
<li>打开PaperSprite，取消勾选Owner No See。并打开事件图表，添加隐藏PaperSprite的相关蓝图；<img src='https://img-blog.csdnimg.cn/20201020140456848.png'></li>
<li>以BP_RPG_NPC为父类，创建蓝图BP_NPC_Warriors,将SK_CharM_Pit导入进来；</li>
</ol>
<h2 id="NPC骨骼重定向"><a href="#NPC骨骼重定向" class="headerlink" title="NPC骨骼重定向"></a>NPC骨骼重定向</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ol>
<li>打开SK_CharM_Pit的Retarget Manager,在SetupRig项目选择引擎默认的Humanoid人形骨骼；</li>
<li>点击AutoMap，自动匹配和建立骨骼映射，ShowBase/ShowAdvanced可用于查看基本骨骼和精细骨骼映射关系；</li>
<li>打开UE4_Mannequin_Skeleton，同样选取rig为Humanoid人形骨骼，自动建立骨骼映射，在ManageRetargetSource项目Add重定向源SK_Mannequin;</li>
<li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为SK_Mannequin_Skeleton，并确保base pose一致（Here is Apos)；<img src='https://img-blog.csdnimg.cn/20201020143635944.png'></li>
<li>将重定向后生成的动画添加至NPC蓝图即可；</li>
</ol>
<h3 id="进阶篇（Mixamo"><a href="#进阶篇（Mixamo" class="headerlink" title="进阶篇（Mixamo)"></a>进阶篇（Mixamo)</h3><ol>
<li>进入虚幻商城[Advanced Locomotion System]，可下载Tpos模型[ALS_Mannequin_T_Pose]；</li>
<li>打开ALS_Mannequin_T_Pose，选取CurrentPose创建PoseAssets[UE4_PoseAsset];</li>
<li>打开Apos的小白人骨骼模型，在Manage Retarget Base Pose项目，点击Modify,选择UE4_PoseAsset为当前pose,并import进来；</li>
<li>打开Mixamo官网下载的模型，手动建立骨骼映射；</li>
<li>右键ThirdPerson_AnimBP,点击Retarget Anim Blueprints，Source为UE4_Mannequin_Skeleton，Target为maria_j_j_ong_Skeleton，并确保base pose一致（Here is Tpos)；<img src='https://img-blog.csdnimg.cn/20201020150458513.png'></li>
</ol>
<h2 id="任务互动发放"><a href="#任务互动发放" class="headerlink" title="任务互动发放"></a>任务互动发放</h2><ol>
<li><p>创建Widget[W_NameForNPC]，</p>
<p>层级面板<img src='https://img-blog.csdnimg.cn/2020102015102250.png'>,</p>
<p>预览效果<img src='https://img-blog.csdnimg.cn/20201020151116574.png'></p>
</li>
<li><p>打开父类BP_RPG_Character，添加组件Widget，并在子类BP_RPG_NPC中添加Widget Class为W_NameForNPC，设置Space=Screen;</p>
</li>
<li><p>添加Sphere碰撞组件，设置碰撞预设;<img src='https://img-blog.csdnimg.cn/20201020151809375.png'></p>
</li>
<li><p>添加NPC互动效果蓝图 <img src='https://img-blog.csdnimg.cn/20201020152018538.png'></p>
</li>
<li>打开Char_Shibi,创建事件调度OnInteract，将与E键盘事件关联；</li>
<li>打开BP_RPG_NPC,创建自定义事件OnInteract，用于判断角色与NPC交互时，NPC身上是否有未分发的任务<img src='https://img-blog.csdnimg.cn/20201020152724167.png'></li>
<li>打开Char_Shibi，创建事件调度UpdateLevelForQuest(Integer),在UpLevel之后调用；</li>
<li>打开BP_RPG_NPC,创建变量QuestInLevel(Map)，将Level映射到Quest类。创建自定义事件UpdateQuest(Integer),用于在角色升级后，判断NPC身上是否产生新的任务；<img src='https://img-blog.csdnimg.cn/20201020153139435.png'></li>
<li>复制BP_MasterQuest两份，命名为BP_FirstEventQuest和BP_FirstSideQuest，并修改任务信息；</li>
</ol>
<h2 id="UI动画添加"><a href="#UI动画添加" class="headerlink" title="UI动画添加"></a>UI动画添加</h2><ol>
<li>打开W_Quest，为Border创建HideAll动画；<img src='https://img-blog.csdnimg.cn/20201020154300252.png'></li>
<li>为Text创建Text动画；<img src='https://img-blog.csdnimg.cn/20201020154331675.png'></li>
<li>打开W_SubGoal，为Border创建Show动画；<img src='https://img-blog.csdnimg.cn/20201020154514839.png'></li>
<li>打开W_Quest事件蓝图，添加宏[Exec] PlayHideAll(Exec,Boolean)，组织和关联HideAll、Text、Show动画执行时机<img src='https://img-blog.csdnimg.cn/20201020154615593.png'></li>
<li>创建自定义事件PlayQuest调用PlayHideAll，并在UpdateQuest末尾添加调用;</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201020134241578.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(七)</title>
    <url>/2020/10/20/RPG-Dev-Log-7/</url>
    <content><![CDATA[<p>涉及内容：AI初讲，BehaviorTree—Patrol等;</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><h2 id="角色边界跳跃"><a href="#角色边界跳跃" class="headerlink" title="角色边界跳跃"></a>角色边界跳跃</h2><ol>
<li>在场景中添加NavLinkProxy，设置PointLink[0].Left和PointLinks[0].Right在场景中的位置；</li>
<li>打开细节面板，按照实际情况将Simple Link和Smart Link Direction都设置为Right to Left，将Area Class都设置为NavArea_Default;<img src='https://img-blog.csdnimg.cn/20201020213951911.png'></li>
</ol>
<h2 id="AI行为树初讲"><a href="#AI行为树初讲" class="headerlink" title="AI行为树初讲"></a>AI行为树初讲</h2><h3 id="PatrolPath"><a href="#PatrolPath" class="headerlink" title="PatrolPath"></a>PatrolPath</h3><ol>
<li>清除场景中的所有Block Volume;</li>
<li>创建Actor [BP_PatrolPath],添加组件Scene、Billboard、Spine;</li>
<li>进入事件图表，创建变量CloseLoop（Boolean),在构造函数中设置ClosedLoop;<img src='https://img-blog.csdnimg.cn/20201020215735408.png'></li>
<li>CloseLoop可用于设置AI巡逻路线是否闭环；<img src='https://img-blog.csdnimg.cn/20201020220053700.png'></li>
<li>在场景中添加BP_PatrolPath，并自定义路线；<img src='https://img-blog.csdnimg.cn/20201020220243597.png'></li>
</ol>
<h3 id="PatrolComponent"><a href="#PatrolComponent" class="headerlink" title="PatrolComponent"></a>PatrolComponent</h3><ol>
<li>创建Component [PatrolComponent],添加变量PatrolPath(BP_PatrolPath)、PatrolIndex(Integer)、RevereDirection(Boolean);</li>
<li>创建纯函数[Vector] GetSpinePointLocation(Integer)，用于获取巡逻路线各个节点在世界坐标系中的位置；<img src='https://img-blog.csdnimg.cn/20201020220912376.png'></li>
<li>创建函数[void] UpdatePatrolIndex()，用于实时更新PatrolIndex；当ColoseLoop=true时，实现闭环寻路；当CloseLoop=false时，实现来回寻路；<img src='https://img-blog.csdnimg.cn/20201020221021193.png'></li>
<li>为BP_RPG_Character添加组件PatrolComponent;</li>
<li>点击场景中的巡逻NPC，将场景中的PatrolPath指定给NPC;</li>
</ol>
<h3 id="BehaviorTree—Patrol"><a href="#BehaviorTree—Patrol" class="headerlink" title="BehaviorTree—Patrol"></a>BehaviorTree—Patrol</h3><ol>
<li><p>创建Enum [Behaviors] = {Idle,Patrol,Hit,Ability};</p>
</li>
<li><p>创建BehaviorTree [BT_NPC]；</p>
</li>
<li><p>创建BlackBoard [BB_Base],新建Keys [Behaviors],类型为Enum Behaviors;</p>
</li>
<li><p>新建Service [BTS_UpdateBehaviorTree],添加变量BehaviorKey(Blackboard Key),添加宏[Exec] SetBehavior(Behaviors,Exec),将BehaviorKey设置为枚举值；<img src='https://img-blog.csdnimg.cn/20201020222511510.png'></p>
</li>
<li><p>在Event Receive Tick AI中调用SetBehavior，选择枚举类型为Patrol;<img src='https://img-blog.csdnimg.cn/20201020222734181.png'></p>
</li>
<li><p>新建Task [BTTask_Patrol],添加事件Event Receive Execute AI和Event Receive Abort AI,用于AI行为的执行和中断；<img src='https://img-blog.csdnimg.cn/20201020223107766.png'></p>
</li>
<li><p>打开BT_NPC，建立Root——Selector(Service)——Sequence(Decorator)——Leaf(Task);</p>
<blockquote>
<p>行为树节点</p>
<p>一、Composite组合节点：</p>
<p>1、Selector</p>
<p>　　要求比较低：只要有一个子节点成功就可以了。</p>
<p>　　只要子节点有一个返回true，则停止执行其它子节点，并且Selector返回true。如果所有子节点都返回false，则Selector返回false。</p>
<p>2、Sequence</p>
<p>　　要求比较高：期望所有子节点都成功。</p>
<p>　　只要有一个子节点返回false，则停止执行其它子节点，并且Sequence返回false。如果所有子节点都返回true，则Sequence返回true。</p>
<p>二、Task叶子：</p>
<p>　　实际执行操作，不含输出链接。</p>
<p>三、Decorator装饰节点</p>
<p>　　依附于其它节点，条件节点：如果返回true则执行位于“Decorator”下面的节点，否则就不执行。</p>
<p>四、Services服务节点</p>
<p>　　只能附加在Composite组合节点上，只要其附加的节点被执行，Services节点就会被执行，通常用来检查和更新黑板。</p>
</blockquote>
<p><img src='https://img-blog.csdnimg.cn/20201020223938437.png'></p>
</li>
<li><p>选取父类AIController，创建蓝图AIC_NPCController,进入蓝图，在EventBeginPlay添加BlackBoard [BB_Base]和BehaviorTree [BT_NPC];<img src='https://img-blog.csdnimg.cn/20201020214613446.png'></p>
</li>
<li><p>选择场景中的NPC，设置</p>
<p>Animation Mode=Use Animaion Blueprint;</p>
<p>Pawn&gt;Auto Possess AI = Placed in World or Spawned,AI Controller Class = AIC_NPCController;</p>
</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102021303566.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(八)</title>
    <url>/2020/10/21/RPG-Dev-Log-8/</url>
    <content><![CDATA[<p>涉及内容：任务坐标，Money互动等;</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p>
<p>虚幻商城[Content Examples]</p>
<p><a href="https://www.iconfont.cn/">阿里巴巴矢量图表库</a> [关键词：脚印、钱包]</p>
<h2 id="创建搜寻目标"><a href="#创建搜寻目标" class="headerlink" title="创建搜寻目标"></a>创建搜寻目标</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>创建Interface [I_Interaction],添加函数BeginOverlapTargetObject、EndOverlapTargetObject、OnInteractWith(Char_Shibi);</p>
</li>
<li><p>创建Actor [BP_TargetObject]，添加组件StaticMesh、Widget、PaperSprite，并在事件开始时隐藏PaperSprite;</p>
</li>
<li><p>将I_Interaction蓝图接口添加至BP_TargetObject;</p>
</li>
<li><p>打开S_SubGoalInfo，添加属性TargetClass(Actor)、TargetClassID(Integer);</p>
</li>
<li><p>打开Char_Shibi,添加Box碰撞体，并添加碰撞事件，调用I_Interaction接口函数；<img src='https://img-blog.csdnimg.cn/20201021171021322.png'></p>
</li>
<li><p>为E键盘事件扩展功能，使其借助蓝图接口实现互动；<img src='https://img-blog.csdnimg.cn/20201021171350706.png'></p>
</li>
<li><p>重命名W_NameForNPC为W_Interaction，并添加到BP_TargetObject的Widget上，在事件开始运行时设置W_Interaction的Name和Interact的文本；<img src='https://img-blog.csdnimg.cn/20201021171832273.png'></p>
</li>
<li><p>打开BP_TargetObject事件蓝图，实现蓝图接口中三个接口函数;<img src='https://img-blog.csdnimg.cn/20201021172214999.png'></p>
</li>
</ol>
<h3 id="创建目标实例-藏宝箱"><a href="#创建目标实例-藏宝箱" class="headerlink" title="创建目标实例(藏宝箱)"></a>创建目标实例(藏宝箱)</h3><ol>
<li>以BP_TargetObject为父类，创建子类Object_Treasure；</li>
<li>将[Content Examples]资源包中的StaticMesh [SM_Chest_Bottom、SM_Chest_Lid、SM_Coin_Small]添加进来，调整Transform;</li>
<li>实现蓝图接口I_Interaction中的接口函数OnInteractWith，使用TimeLine实现宝箱打开、金币弹出并旋转的交互动画;<img src='https://img-blog.csdnimg.cn/20201021173246323.png'><img src='https://img-blog.csdnimg.cn/20201021173324992.png'></li>
</ol>
<h3 id="创建目标小地图指示"><a href="#创建目标小地图指示" class="headerlink" title="创建目标小地图指示"></a>创建目标小地图指示</h3><ol>
<li><p>打开W_MiniMap，扩展Widget显示内容，注意<strong>TargetDirection</strong>属性<strong>Pivot</strong>的设置，需要根据Angle作调整,使其无论如何旋转，都能正确显示位置，层级面板作如下修改<img src='https://img-blog.csdnimg.cn/20201021173858989.png'>预览效果<img src='https://img-blog.csdnimg.cn/20201021174021728.png'></p>
</li>
<li><p>打开QuestManager，创建纯函数[void] DistanceToTarget(Integer),用于计算角色到目标的空间距离；<img src='https://img-blog.csdnimg.cn/20201021174336258.png'></p>
</li>
<li><p>创建函数[void] UpdateTargetDirection()，用于更新目标相对于角色的所在方位；<img src='https://img-blog.csdnimg.cn/2020102117461731.png'></p>
</li>
<li><p>打开函数AddQuest,在末尾设置CurrentQuest=LocalQuest;</p>
</li>
<li><p>创建自定义事件OnSwitchSubGoalInfo，用于点击子任务列表时，根据当前选择的子任务（是否为Search任务），显示和隐藏目标距离和方位；<img src='https://img-blog.csdnimg.cn/20201021175129176.png'><img src='https://img-blog.csdnimg.cn/20201021175154953.png'></p>
</li>
<li><p>创建自定义事件OnPlayerMove，用于角色移动时更新搜寻目标距离和方位信息；<img src='https://img-blog.csdnimg.cn/202010211755540.png'></p>
</li>
<li><p>打开RPG_PlayerController，在移动事件末尾添加OnPlayerMove事件的调用；</p>
</li>
</ol>
<h2 id="Money互动"><a href="#Money互动" class="headerlink" title="Money互动"></a>Money互动</h2><ol>
<li>打开W_CharacterBorder，添加一个Horizatal Box，添加Money图标和文本；</li>
<li>打开Char_Shibi，创建函数[void]CountMoney()，用于更新Money文本；<img src='https://img-blog.csdnimg.cn/20201021213916456.png'></li>
<li>创建自定义事件[void] GetMoney(Integer)，使用TimerHandle控制CountMoney函数的循环调用；<img src='https://img-blog.csdnimg.cn/20201021214258222.png'></li>
<li>打开Object_Treasure事件图表，在Event OnInteractWith末尾添加GetMoney事件的调用，可实现宝箱打开金币旋转动画结束后，自动增加Money的值；</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/20201021165022723.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>RPG Game开发日志(九)</title>
    <url>/2020/10/23/RPG-Dev-Log-9/</url>
    <content><![CDATA[<p>涉及内容：任务完成的互动，混合骨骼动画，普通攻击三连制作等；</p>
<a id="more"></a>
<h1 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h1><p>素材来源：</p>
<p>虚幻商城[Infinity Blade:Adversaries]</p>
<p>虚幻商城[Infinity Blade:Effects]</p>
<h2 id="优化开箱互动"><a href="#优化开箱互动" class="headerlink" title="优化开箱互动"></a>优化开箱互动</h2><ol>
<li>打开Object_Treasure事件图表，创建TimeLine [MoveToPlayer]，创建Float Track，作为金币移动至人物身上的Alpha通道（类指数曲线）;<img src='https://img-blog.csdnimg.cn/20201023182304187.png'></li>
<li>扩展自定义事件Event On Interact With功能，实现金币被角色吸引——产生马里奥金币音效的效果；<img src='https://img-blog.csdnimg.cn/20201023182357341.png'></li>
</ol>
<h2 id="创建移动平台"><a href="#创建移动平台" class="headerlink" title="创建移动平台"></a>创建移动平台</h2><ol>
<li>创建Acotr [BP_MovePlane]，添加一个StaticMesh,添加SM_Env_Ice_Cliffs；</li>
<li>打开事件图表，创建TimeLine[Move]，创建Float Track，作为平台移动的Alpha通道（类正弦曲线）,勾选Loop模式；<img src='https://img-blog.csdnimg.cn/20201023183342627.png'></li>
<li>在Event BeginPlay实现平台相对于自身的偏移移动；<img src='https://img-blog.csdnimg.cn/20201023183559104.png'></li>
</ol>
<h2 id="任务完成的互动"><a href="#任务完成的互动" class="headerlink" title="任务完成的互动"></a>任务完成的互动</h2><ol>
<li><p>打开S_SubGoalInfo，添加成员HasFollowingIndex?(Boolean);</p>
</li>
<li><p>打开W_SubGoal，创建函数DisableButton，用于SelectButton按钮的disable,Done图标和SubGoalText文本的高亮显示；<img src='https://img-blog.csdnimg.cn/20201023184922881.png'></p>
</li>
<li><p>打开W_Quest,创建宏AnimateSubGoalWidget(Exec，Boolean)，将宏PlayHideAll中有关SubGoal的显示动画（Show/Text）整合进来，并扩展功能，使其在Quest完成时播放隐藏动画；<img src='https://img-blog.csdnimg.cn/20201023190840946.png'><img src='https://img-blog.csdnimg.cn/20201023190652645.png'></p>
</li>
<li><p>打开EvenGraph，添加自定义事件PlaySubGoal(Boolean)，调用宏AnimateSubGoalWidget(Boolean)，修改自定义事件PlayQuest()为PlayQuest(Boolean)，调用宏PlayHideAll(Boolean);<img src='https://img-blog.csdnimg.cn/20201023191105631.png'></p>
</li>
<li><p>打开函数GenerateSubGoal，当SubGoal循环添加完成时,调用自定义事件PlaySubGoal，播放相关动画；</p>
</li>
<li><p>打开BP_MasterQuest，创建自定义事件UpdateCompleteSubGoal,创建变量CompletedSubGoalsInfo(S_SubGoalInfo)、CompletedSubGoalIndex(Integer),用于记录已完成的SubGoal信息和索引。当所有<strong>已显示</strong>的SubGoal都被标记为完成时，执行PlaySubGoal(false)动画，并判断是否仍有FollowingIndex。若有，则延迟1.5s后调用函数GenrateSubGoal和SelectSubGoal，再生SubGoal；<img src='https://img-blog.csdnimg.cn/20201023193814396.png'></p>
</li>
<li><p>创建函数CompletedSubGoal(Integer)，用于记录已完成的SubGoal信息和索引更新，并同步UI更新（调用函数DisableButton和自定义事件UpdateCompleteSubGoal)；<img src='https://img-blog.csdnimg.cn/20201023194332860.png'><img src='https://img-blog.csdnimg.cn/20201023194354363.png'></p>
</li>
<li><p>复制一份BP_FirstQuest，命名为BP_FirstQuestTest，修改index=3的SubGoal,勾选HasFollowingIndex?,添加FollowingSubGoalIndices;<img src='https://img-blog.csdnimg.cn/20201023195017556.png'></p>
</li>
<li><p>打开BP_Shibi事件图表，创建J键盘事件，测试任务完成时的互动效果；<img src='https://img-blog.csdnimg.cn/20201023194602440.png'></p>
</li>
</ol>
<h2 id="普通攻击三连制作"><a href="#普通攻击三连制作" class="headerlink" title="普通攻击三连制作"></a>普通攻击三连制作</h2><ol>
<li>导入Shibi角色MeleeAttack动画（Air/B/C/D)，创建Montage，命名为Air_Melee、Melee_B、Melee_C、Melee_D；</li>
<li>导入Shibi角色Attack音效（1/2/3/4）,创建Cue，命名为Shinbi_Effect_Attack，编辑蓝图实现4种攻击音效随机播放的效果；<img src='https://img-blog.csdnimg.cn/20201024173918860.png'></li>
<li>打开Montage[Air_Melee],添加Notify [Play Sound]、Skeleton Notify [Reset]；<img src='https://img-blog.csdnimg.cn/2020102417450352.png'></li>
<li>打开Montage[Melee_B],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174714903.png'></li>
<li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174753486.png'></li>
<li>打开Montage[Melee_C],添加Notify [Play Sound]、Skeleton Notify [Save] [Reset],添加Curves [Body]；<img src='https://img-blog.csdnimg.cn/20201024174837728.png'></li>
<li>打开BP_Shibi，创建自定义事件MeleeAttack、SaveAttack、ResetComb;</li>
<li>打开ABP_Shibi事件图表，AnimNotify_Save调用SaveAttack事件，AnimNotify_Reset调用ResetComb事件；<img src='https://img-blog.csdnimg.cn/20201024175438930.png'></li>
<li>返回BP_Shibi，完成自定义事件MeleeAttack、SaveAttack、ResetComb，SavaAttack用于记录当前普通攻击归属第几段，当角色停止普通攻击时，ResetComb将初始化Attack信息;<img src='https://img-blog.csdnimg.cn/20201024175625435.png'></li>
<li>创建Q键盘事件，关联普通攻击，调用MeleeAttack事件，并根据角色是否滞空播放相应的蒙太奇动画；<img src='https://img-blog.csdnimg.cn/20201024175856577.png'></li>
</ol>
<h2 id="混合骨骼动画"><a href="#混合骨骼动画" class="headerlink" title="混合骨骼动画"></a>混合骨骼动画</h2><ol>
<li><p>打开ABP_Shibi事件图表，完善动画更新事件，判断角色是否处于加速状态或FullBody状态；<img src='https://img-blog.csdnimg.cn/20201024180437185.png'></p>
</li>
<li><p>打开ABP_Shibi动画图表，添加按骨骼分层混合，以及按布尔值混合姿势。当角色处于加速状态并且Body Curve返回值为0时，输出按骨骼分层混合姿势，否则输出UpBody姿势；<img src='https://img-blog.csdnimg.cn/20201024181347328.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201024180639713.png'></p>
</li>
</ol>
<h1 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h1><p><img src='https://img-blog.csdnimg.cn/2020102417301295.gif'></p>
<p><img src='https://img-blog.csdnimg.cn/20201024173043229.gif'></p>
]]></content>
      <categories>
        <category>Logs</category>
      </categories>
      <tags>
        <tag>UE_4.22</tag>
      </tags>
  </entry>
  <entry>
    <title>Graphic-Drawing-System</title>
    <url>/2020/11/27/Graphic-Drawing-System/</url>
    <content><![CDATA[<p>图形绘制系统的内容包括Modeling(建模)、Geometric processing(几何处理)、Rasterization(光栅化)、Fragment processing(片元处理)、Frame buffer(帧缓存)。其中四个主要任务为：Clip(裁剪)、Rasterization(光栅化)、Hidden surface(隐藏面消除)、Anti-aliasing technology(反走样技术)。</p>
<a id="more"></a>
<h1 id="Modeling-建模"><a href="#Modeling-建模" class="headerlink" title="Modeling(建模)"></a>Modeling(建模)</h1><h1 id="Geometric-processing-几何处理"><a href="#Geometric-processing-几何处理" class="headerlink" title="Geometric processing(几何处理)"></a>Geometric processing(几何处理)</h1><p><img src='https://img-blog.csdnimg.cn/20201127213955149.png'></p>
<blockquote>
<ul>
<li><p>完整的图形绘制管道</p>
<ol>
<li>通过给P添加分量1将其扩展为齐次4元组；</li>
<li>用这个4元组乘上矩阵modelview，得到视点坐标系下的4元组；</li>
<li>再将点乘上投影矩阵，得到裁剪坐标下的4元组；</li>
<li>对以此点为端点的边实施裁剪操作；</li>
<li>执行透视除法，得到一个3元组（规范化的设备坐标）；</li>
<li>在视区变换过程中3元组被乘上一个矩阵：得到的结果被用于绘制和深度计算（窗口坐标）。</li>
</ol>
</li>
<li><p>从三维空间到二维平面，就如同用相机拍照一样，通常都要经历以下几个步骤（括号内表示的是相应的图形学概念） </p>
<ol>
<li><p>将相机置于三角架上，让它对准三维景物（视点变换，Viewing Transformation）； </p>
</li>
<li><p>将三维物体放在适当的位置（模型变换，Modeling Transformation ）； </p>
</li>
<li><p>选择相机镜头并调焦，使三维物体投影在二维胶片上（投影变换，Projection Transformation ）;</p>
</li>
<li><p>决定二维像片的大小（视口变换，Viewport Transformation ）。 </p>
</li>
</ol>
<p>这样，一个三维空间里的物体就可以用相应的二维平面物体表示了，也就能在二维的计算机屏幕上正确显示了。</p>
</li>
</ul>
</blockquote>
<h2 id="Viewing-amp-Modeling-Transformation-视点-amp-模型变换"><a href="#Viewing-amp-Modeling-Transformation-视点-amp-模型变换" class="headerlink" title="Viewing &amp; Modeling  Transformation(视点&amp;模型变换)"></a>Viewing &amp; Modeling  Transformation(视点&amp;模型变换)</h2><h3 id="摄像机的定位和定向"><a href="#摄像机的定位和定向" class="headerlink" title="摄像机的定位和定向"></a>摄像机的定位和定向</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src='https://img-blog.csdnimg.cn/20201128001507408.png'></p>
<p>给定eye、look和up，我们得到：</p>
<p><img src='https://img-blog.csdnimg.cn/20201128002206685.png'></p>
<h4 id="Modelview-matrix-模型视点矩阵"><a href="#Modelview-matrix-模型视点矩阵" class="headerlink" title="Modelview matrix(模型视点矩阵)"></a>Modelview matrix(模型视点矩阵)</h4><p><img src='https://img-blog.csdnimg.cn/20201128013208174.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201128013227487.png'></p>
<p>模型视点矩阵的作用是把世界坐标系转换成摄像机坐标系。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>考虑一个摄像机，其eye=(4,4,4)，look=(0,1,0)，up为(0,1,0)，求出u，v，n。</p>
<p>n=(4,4,4)-(0,1,0)=(4,3,4)</p>
<script type="math/tex; mode=display">
\left[
 \begin{matrix}
   i & j & k \\
   0 & 1 & 0 \\
   4 & 3 & 4
  \end{matrix}
  \right]</script><p>u=(0,1,0)×(4,3,4)=(4,0,-4)</p>
<script type="math/tex; mode=display">
\left[
 \begin{matrix}
   i & j & k \\
   4 & 3 & 4 \\
   4 & 0 & -4
  \end{matrix}
  \right]</script><p>v=(4,3,4)×(4,0,-4)=(-12,32,-12)</p>
</blockquote>
<h4 id="OpenGL视点变换API"><a href="#OpenGL视点变换API" class="headerlink" title="OpenGL视点变换API"></a>OpenGL视点变换API</h4><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glulookat">gluLookAt(GLdouble eyex,   GLdouble eyey,   GLdouble eyez,   GLdouble centerx,   GLdouble centery,   GLdouble centerz,   GLdouble upx,   GLdouble upy,   GLdouble upz)</a></li>
</ul>
<h2 id="Projection-Transformation-投影变换"><a href="#Projection-Transformation-投影变换" class="headerlink" title="Projection Transformation(投影变换)"></a>Projection Transformation(投影变换)</h2><h3 id="平行投影-正交投影"><a href="#平行投影-正交投影" class="headerlink" title="平行投影(正交投影)"></a>平行投影(正交投影)</h3><h4 id="平行投影矩阵"><a href="#平行投影矩阵" class="headerlink" title="平行投影矩阵"></a>平行投影矩阵</h4><p><img src='https://img-blog.csdnimg.cn/20201128020858774.png'></p>
<p><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">推导过程</a></p>
<h4 id="OpenGL平行投影API"><a href="#OpenGL平行投影API" class="headerlink" title="OpenGL平行投影API"></a>OpenGL平行投影API</h4><ul>
<li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glortho">glOrtho(GLdouble left,   GLdouble right,   GLdouble bottom,   GLdouble top,   GLdouble zNear,   GLdouble zFar)</a></p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gluortho2d">gluOrtho2D(GLdouble left,   GLdouble right,   GLdouble top,   GLdouble bottom)</a></p>
</li>
</ul>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><h4 id="透视除法"><a href="#透视除法" class="headerlink" title="透视除法"></a>透视除法</h4><p><img src='https://img-blog.csdnimg.cn/20201128020312218.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201128020336728.png'></p>
<p>在Eye coordinates(观察坐标）被Projection matrix相乘后，得到的Clip coordinates(裁剪坐标)仍然是homogeneous coordinates(齐次坐标)。最终它需要除以Clip coordinates的w分量，才能变成Normalized device coordinates(规范化设备坐标NDC)。因此，我们可以把裁剪坐标的Wc分量设置为-Ze，则投影矩阵第4行变为(0, 0, -1, 0)。</p>
<h4 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h4><p><img src='https://img-blog.csdnimg.cn/20201128020621398.png'></p>
<p><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">推导过程</a></p>
<h4 id="OpenGL透视投影API"><a href="#OpenGL透视投影API" class="headerlink" title="OpenGL透视投影API"></a>OpenGL透视投影API</h4><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glfrustum">glFrustum(GLdouble left,   GLdouble right,   GLdouble bottom,   GLdouble top,   GLdouble zNear,   GLdouble zFar)</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gluperspective">gluPerspective(GLdouble fovy,   GLdouble aspect,   GLdouble zNear,   GLdouble zFar)</a></li>
</ul>
<h2 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a>Viewport Transformation(视口变换)</h2><p><img src='https://img-blog.csdnimg.cn/20201127214343608.png'></p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>仿射变换可以很容易地对物体实施缩放、旋转和平移操作</li>
<li>一系列仿射变换可以组合成一个单一的仿射变换</li>
<li>仿射变换可以使用一个紧凑的矩阵形式表示</li>
</ol>
<h4 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h4><ul>
<li>平移<img src='https://img-blog.csdnimg.cn/2020112723281810.png'></li>
<li>缩放<img src='https://img-blog.csdnimg.cn/20201127232917795.png'></li>
<li>旋转<img src='https://img-blog.csdnimg.cn/20201127234421587.png'><img src='https://img-blog.csdnimg.cn/20201127234441934.png'></li>
</ul>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>假设裁剪矩形的左下角坐标为（wxl=10,wyb=10），右上角坐标为（wxr=50，wyt=50）。</p>
<p>设备坐标系中视口的左下角坐标为（vxl=10,vyb=30），右上角坐标为（vxr=50,vyt=90）。</p>
<p>已知在窗口内有一点p(20,30)，要将点p映射到视区内的点p’，请问p’点在设备坐标系中的坐标是多少？</p>
<ol>
<li><p>将窗口坐标系（window coordinates）左下角（10,10）平移至观察坐标系的坐标原点（0,0），平移矢量为（-10，-10）。</p>
</li>
<li><p>针对坐标原点进行比例变换，使窗口大小和视区相等，比例因子为 Sx=(50-10)/(50-10)=1， Sy=(90-30)/(50-10)=1.5。</p>
</li>
<li><p>将窗口内的点映射到设备坐标系（device coordinates）的视区中，再进行反平移，将视区的左下角移回到设备坐标系中的位置（10,30），平移矢量为（10,30）。</p>
</li>
<li><p>计算得到变换矩阵T。<br><img src='https://img-blog.csdnimg.cn/20201127225018489.png'><br><img src='https://img-blog.csdnimg.cn/20201127225157233.png'></p>
</li>
<li><p>将变换矩阵T左乘p点齐次坐标得到p’齐次坐标。</p>
<p><img src='https://img-blog.csdnimg.cn/20201127234649217.png'></p>
</li>
</ol>
</blockquote>
<h3 id="OpenGL视口变换API"><a href="#OpenGL视口变换API" class="headerlink" title="OpenGL视口变换API"></a>OpenGL视口变换API</h3><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glviewport">glViewport(GLint x, GLint y , GLsizei width , GLsizei height)</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gldepthrange">glDepthRange(GLclampd zNear, GLclampd zFar )</a></li>
</ul>
<h2 id="Clip-裁剪"><a href="#Clip-裁剪" class="headerlink" title="Clip(裁剪)"></a>Clip(裁剪)</h2><h3 id="直线裁剪算法"><a href="#直线裁剪算法" class="headerlink" title="直线裁剪算法"></a>直线裁剪算法</h3><h4 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h4><h5 id="建立区域码"><a href="#建立区域码" class="headerlink" title="建立区域码"></a>建立区域码</h5><p><img src='https://img-blog.csdnimg.cn/20201128143628195.png'></p>
<p>Cohen-Sutherland直线裁剪算法的核心是把所有直线的端点均分配一个表示其相对位置的4位二进制代码。此代码称为区域码。区域码按照端点与窗口边界的相对位置编码，即区域码的4位分别代表端点位于窗口的上、下、右、左。</p>
<p><img src='https://img-blog.csdnimg.cn/20201128145429326.png'></p>
<p>Cohen-Sutherland算法通常在两种情况下，可以快速的检测。即平凡接受（两个码字都是0000）和平凡拒绝（两个码字在某一位元素上都是1(相与不为0)）。</p>
<p><img src='https://img-blog.csdnimg.cn/2020112815010542.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201128150125553.png'></p>
<p>对于第三种情况，取窗口外的一个端点与窗口边界比较以确定可排除直线的哪一部分，然后，把直线剩下的部分与其他边界比较，这样一直到直线全部被排除或确定直线的哪一部分在窗口之内为止。可按“左、右、下、上”的次序建立检查直线端点与窗口边界关系的算法。</p>
<h5 id="代码实现-C"><a href="#代码实现-C" class="headerlink" title="代码实现(C++)"></a>代码实现(C++)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Implementation of Cohen-Sutherland Algorithm, written by Jocoboy.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">string</span> code;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">ordinaryAccept</span><span class="params">(<span class="keyword">const</span> Point&amp; p1,cont Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.code == <span class="string">&quot;0000&quot;</span> &amp;&amp; p2.code == <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">ordinaryRefused</span><span class="params">(<span class="keyword">const</span> Point&amp; p1,cont Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.code[i]== p2.code[i] &amp;&amp; p,.code[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">     	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RealRect</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftClip</span><span class="params">(Point&amp; p1,Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="keyword">this</span>.left - p1.x;				</span><br><span class="line">        <span class="keyword">int</span> delx = p2.x - p1.x;</span><br><span class="line">        <span class="keyword">int</span> dely = p1.y - p2.y; <span class="comment">// 此处p1和p2顺序无所谓</span></span><br><span class="line">        <span class="keyword">if</span>(dely!=<span class="number">0</span>)&#123;</span><br><span class="line">   			<span class="keyword">int</span> d = e*dely/delx;</span><br><span class="line">            p1.y += -d;	</span><br><span class="line">        &#125;</span><br><span class="line">        p1.x = <span class="keyword">this</span>.left;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rightClip</span><span class="params">(Point&amp; p1,Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = p1.x - <span class="keyword">this</span>.right;				</span><br><span class="line">        <span class="keyword">int</span> delx = p1.x - p2.x;</span><br><span class="line">        <span class="keyword">int</span> dely = p1.y - p2.y; <span class="comment">// 此处p1和p2顺序无所谓</span></span><br><span class="line">        <span class="keyword">if</span>(dely!=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> d = e*dely/delx;</span><br><span class="line">             p1.y += -d;	</span><br><span class="line">        &#125;</span><br><span class="line">        p1.x = <span class="keyword">this</span>.right;		 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bottomClip</span><span class="params">(Point&amp; p1, Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="keyword">this</span>.bottom - p1.y;				</span><br><span class="line">        <span class="keyword">int</span> delx = p2.x - p1.x; <span class="comment">// 此处p1和p2顺序无所谓</span></span><br><span class="line">        <span class="keyword">int</span> dely = p2.y - p1.y;</span><br><span class="line">        <span class="keyword">if</span>(delx!=<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> e = d*delx/dely;</span><br><span class="line">           	  p1.x += -e;	</span><br><span class="line">         &#125;</span><br><span class="line">         p1.y = <span class="keyword">this</span>.bottom;		 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topClip</span><span class="params">(Point&amp; p1，Point&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = p1.y - <span class="keyword">this</span>.top;				</span><br><span class="line">        <span class="keyword">int</span> delx = p2.x - p1.x; <span class="comment">// 此处p1和p2顺序无所谓</span></span><br><span class="line">        <span class="keyword">int</span> dely = p1.y - p2.y;</span><br><span class="line">        <span class="keyword">if</span>(delx!=<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> e = d*delx/dely;</span><br><span class="line">              p1.x += -e;	</span><br><span class="line">        &#125;</span><br><span class="line">        p1.y = <span class="keyword">this</span>.top;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clipSegment</span><span class="params">(Point&amp; p1, Point&amp; p2, RealRect w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">   	<span class="keyword">if</span>(ordinaryAccept(p1,p2)) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// 平凡接受(完全可见)</span></span><br><span class="line">   	<span class="keyword">if</span>(ordinaryRefused(p1,p2)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 平凡拒绝(完全不可见)</span></span><br><span class="line">   	<span class="keyword">if</span>(p2.x&gt;=w.left&amp;&amp;p2.x&lt;=w.right&amp;&amp;p2.y&gt;=w.bottom&amp;&amp;p2.y&lt;=w.top)&#123;<span class="comment">// p1在窗口外面</span></span><br><span class="line">        <span class="keyword">if</span>(p1.x&lt;=w.left)&#123;<span class="comment">// p1在窗口左边,用左边界截断，更新p1； 	    </span></span><br><span class="line">	  		w.leftClip(p1,p2);  </span><br><span class="line">        &#125; 			 </span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p1.x&gt;=w.right)&#123;<span class="comment">// p1在窗口右边,用右边界截断，更新p1；</span></span><br><span class="line">            w.rightClip(p1,p2);		  	   </span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p1.y&lt;=w.bottom)&#123;<span class="comment">// p1 在窗口下面,用下边界截断，更新p1；</span></span><br><span class="line">            w.bottomClip(P1,P2); 				</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p1.y&gt;=w.top)&#123;<span class="comment">// p1 在窗口上面,用上边界截断，更新p1；</span></span><br><span class="line">            w.topClip(p1,p2);			</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;  <span class="comment">// p2 在窗口外面</span></span><br><span class="line">        <span class="keyword">if</span>(p2.x&lt;=w.left)&#123;<span class="comment">// p2在窗口左边,用左边界截断，更新p2；    	    </span></span><br><span class="line">           w.leftClip(p2,p1);   					   </span><br><span class="line">        &#125; 			 </span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p2.x&gt;=w.right)&#123;<span class="comment">// p2在窗口右边,用右边界截断，更新p2；</span></span><br><span class="line">           w.rightClip(p2,p1);	 				  	  </span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p2.y&lt;=w.bottom)&#123;<span class="comment">// p2 在窗口下面,用下边界截断，更新p2；</span></span><br><span class="line">           w.bottomClip(P2,P1);   				</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(p2.y&gt;=w.top)&#123;<span class="comment">// p2 在窗口上面,用上边界截断，更新p2；</span></span><br><span class="line">           w.topClip(p2,p1);	  				</span><br><span class="line">        &#125; </span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Liang-Barsky算法"><a href="#Liang-Barsky算法" class="headerlink" title="Liang-Barsky算法"></a>Liang-Barsky算法</h4><p>一个复杂的画面中可能包含有几千条直线，为了提高算法效率，加快裁剪速度，应当采用计算量较小的算法求直线与窗口边界的交点。</p>
<h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><ol>
<li><p>Liang-Barsky算法又称为参数方程法，以直线的参数方程为基础，对不同情况下的裁剪求得相应的参数值。</p>
</li>
<li><p>首先写出端点及之间连线的参数方程如下：</p>
<script type="math/tex; mode=display">
x = x_1 + (x_2-x_1)u = x_1 + t\Delta x
\\
y = y_1 + (y_2-y_1)u = y_1 + t\Delta y
\\
\Delta x = x_2 - x_1,\Delta y = y_2 - y_1</script><p>  参数u可取0到1之间的值，坐标表示此范围内的u值定义的直线上的一个点。</p>
</li>
<li><p>如果直线上的某点处于(x,y)即(xmin,ymin)以及(xmax,ymax)所定义的窗口之内，则满足以下条件：</p>
</li>
</ol>
<script type="math/tex; mode=display">
x_{wmin} \leqslant x_1 + t\Delta x  \leqslant x_{wmax}
\\
y_{wmin} \leqslant y_1 + t\Delta y  \leqslant y_{wmax}</script><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>输入直线段的两端点坐标以及窗口的四条边界坐标。</p>
</li>
<li><p>若Δx=0，则有</p>
<script type="math/tex; mode=display">
x_{wmin} \leqslant x_1 \leqslant x_{wmax}</script></li>
</ol>
<p>   进一步判断是否满足</p>
<script type="math/tex; mode=display">
   x_1 < x_{wmin}或x_1 > x_{wmax}</script><p>   若满足，则该直线段不在窗口内，转(7)。</p>
<p>   否则，满足</p>
<script type="math/tex; mode=display">
   x_{wmin} \leqslant x_1   \leqslant x_{wmax}</script><p>   则进一步计算ts和te。转(5)。</p>
<ol>
<li><p>若Δy=0，则有</p>
<script type="math/tex; mode=display">
y_{wmin} \leqslant y_1 \leqslant y_{wmax}</script><p>进一步判断是否满足</p>
<script type="math/tex; mode=display">
y_1 < y_{wmin}或y_1 > y_{wmax}</script><p>若满足，则该直线段不在窗口内，转(7)。</p>
<p>否则，满足</p>
<script type="math/tex; mode=display">
y_{wmin} \leqslant y_1   \leqslant y_{wmax}</script><p>则进一步计算ts和te。转(5)。</p>
</li>
<li><p>若上述两条均不满足,则有Δx≠0且Δy≠0。此时计算ts和te。</p>
</li>
<li><p>求得ts和te后进行判断：</p>
<p>若ts&gt;te,则直线段在窗口外,转(7)。</p>
<p>若ts&lt;te,利用直线的参数方程求得直线段在窗口内的两端点坐标。</p>
</li>
<li><p>利用直线的扫描转换算法绘制在窗口内的直线段。</p>
</li>
<li><p>算法结束。</p>
</li>
</ol>
<h3 id="多边形裁剪算法"><a href="#多边形裁剪算法" class="headerlink" title="多边形裁剪算法"></a>多边形裁剪算法</h3><h4 id="Sutherland-Hodgeman算法"><a href="#Sutherland-Hodgeman算法" class="headerlink" title="Sutherland-Hodgeman算法"></a>Sutherland-Hodgeman算法</h4><h5 id="基本思想-分冶"><a href="#基本思想-分冶" class="headerlink" title="基本思想(分冶)"></a>基本思想(分冶)</h5><ol>
<li><p>将多边形的边界作为一个整体，每次用窗口的一条边界对要裁剪的多边形进行裁剪。</p>
</li>
<li><p>窗口的一条边以及延长线构成的裁剪线把平面分为两个区域：包含窗口区域的域称为可见侧，不包含窗口区域的域为不可见侧。</p>
</li>
<li><p>将每条线段的端点S, P与裁剪线比较之后，可以输出0～2个点:</p>
<p>(1) S在不可见一侧，P在可见一侧，输出SP与裁剪线的交点I和顶点P。</p>
<p>(2) S, P都在可见一侧，输出顶点P。</p>
<p>(3) S在可见一侧，P在不可见一侧，输出SP与裁剪线的交点I。</p>
<p>(4) S, P都在不可见一侧，输出0个顶点。</p>
</li>
</ol>
<p><img src='https://img-blog.csdnimg.cn/20201128233030391.png'></p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p><img src='https://img-blog.csdnimg.cn/20201128232040829.png'></p>
<p>(a)用左边界裁剪</p>
<p>​    输入顶点：ABCDEFGH</p>
<p>​    输出顶点：12DEFGHA</p>
<p><img src='https://img-blog.csdnimg.cn/20201128232219190.png'></p>
<p>(b)用下边界裁剪</p>
<p>​    输入顶点：12DEFGHA</p>
<p>​    输出顶点：34D56FFGHA1</p>
<p><img src='https://img-blog.csdnimg.cn/2020112823231526.png'></p>
<p>(c)用右边界裁剪</p>
<p>​    输入顶点：34D56FFGHA1</p>
<p>​    输出顶点：78GHA134D56</p>
<p><img src='https://img-blog.csdnimg.cn/20201128232408110.png'></p>
<p>(d)用上边界裁剪</p>
<p>​    输入顶点：78GHA134D56</p>
<p>​    输出顶点：9IHJK34D5678</p>
<h1 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization(光栅化)"></a>Rasterization(光栅化)</h1><h2 id="线段光栅化"><a href="#线段光栅化" class="headerlink" title="线段光栅化"></a>线段光栅化</h2><h3 id="DDA算法"><a href="#DDA算法" class="headerlink" title="DDA算法"></a>DDA算法</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ol>
<li><p>DDA算法是计算机图形学中最简单的绘制直线算法。其主要思想是由直线公式y = kx + b推导出来的。<br>我们已知直线段两个端点P0(x0,y0)和P1(x1,y1)，就能求出 k 和 b 。</p>
</li>
<li><p>在k，b均求出的条件下，只要知道一个x值，我们就能计算出一个y值。如果x的步进为1（x每次加1，即x = x +1），那么y的步进就为k+b；同样知道一个y值也能计算出x值，此时y的步进为1，x的步进为(1-b)/k。根据计算出的x值和y值，向下取整，得到坐标(x’,y’)，并在(x’,y’)处绘制直线段上的一点。</p>
</li>
<li><p>为进一步简化计算，通常可令b取0，将起点看作(0,0)。设当前点为(xi, yi)则用DDA算法求解(xi+1，yi+1)的计算公式可以概括为：</p>
<script type="math/tex; mode=display">
x_{i+1} = x_i + x_{step}
\\
y_{i+1} = y_i + y_{step}</script></li>
<li><p>我们一般通过计算 Δx 和 Δy 来确定xStep和yStep：</p>
<p>如果 |Δx| &gt; |Δy| ，即k=|Δy/Δx| <1，说明x轴方向为步进的主方向，xStep = 1，yStep = k；
如果 |Δy|> |Δx|，即k=|Δy/Δx| &gt;1，说明y轴方向为步进的主方向，yStep = 1，xStep = 1 / k。</p>
</li>
<li><p>根据这个公式，就能通过(xi，yi)迭代计算出(xi+1,yi+1)，然后在坐标系中绘制计算出的(x,y)坐标点。</p>
</li>
</ol>
<h4 id="代码实现-C-1"><a href="#代码实现-C-1" class="headerlink" title="代码实现(C++)"></a>代码实现(C++)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Implementation of DDA Algorithm, written by Jocoboy.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawDDALine</span><span class="params">(Point p1,Point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = p2.x - p1.x;</span><br><span class="line">    <span class="keyword">float</span> dy = p2.y - p1.y;</span><br><span class="line">    <span class="keyword">float</span> k = dy / dx;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(k) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = p1.x,y = p1.y ; x &lt;= p2.x ; x++,y++)&#123;</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(k) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = p1.x ; x &lt;= p2.x ; x++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = (<span class="keyword">int</span>)((x+<span class="number">1</span>)*k + <span class="number">0.5</span>);</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> y = p1.y ; y &lt;= p2.y ; y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (<span class="keyword">int</span>)((y+<span class="number">1</span>)*k + <span class="number">0.5</span>);</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>画出直线段P0(0,0)-P1(5,2)</p>
<p>由k = Δy/Δx  = 2 / 5 &lt; 1， 可知x轴方向为步进的主方向，xStep = 1，yStep = k</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">yStep</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.8</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1.2</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1.6</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2.0</td>
</tr>
</tbody>
</table>
</div>
<p><img src='https://img-blog.csdnimg.cn/20201130191413305.png'></p>
</blockquote>
<h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><ol>
<li><p>Bresenham算法也是一种计算机图形学中常见的绘制直线的算法，其本质思想也是步进的思想，但由于避免了浮点运算，相当于DDA算法的一种改进算法。</p>
</li>
<li><p>设直线的斜率为k，当|k| &lt;=1时，x方向为主步进方向；当|k| &gt;1时，y方向为主步进方向。现以|k| &lt;1时为例，推导Bresenham算法的原理。</p>
<p><img src='https://img-blog.csdnimg.cn/20201130194214901.png'></p>
</li>
<li><p>图中绘制了一条直线，红色点表示该直线上的点，蓝色和绿色点表示光栅下绘制的点。 当x方向是主要步进方向时，以每一小格的中点为界，如果当前的yi在中点(图中黑色短线)下方，则y取yi; 如果当前的yi在中点上方，则y取yi+1。</p>
</li>
<li><p>现考虑这种方法的误差，因为直线的起始点在像素中心，所以误差项d的初值d0＝0。x下标每增加1，d的值相应递增。直线的斜率值k，即d＝d＋k。一旦d≥1，就把它减去1，这样保证d在[0,1]之间。当d&lt;0.5时，更接近于右方像素(x+1,y）;当d≥0.5时，更接近于当前像素的右上方像素（x+1,y+1）。为方便计算，令e＝d-0.5，e的初值为-0.5，增量为k。当e&lt;0时，取当前像素（xi，yi）右方像素（x+1,y）；当e≥0时，取当前像素（xi，yi）的右上方像素（x+1,y+1），从而可以改用整数以避免除法。</p>
</li>
<li><p>由于算法中只用到误差项的符号，因此可作如下替换：</p>
</li>
</ol>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
e = k - 0.5 \\Δy=kΔx\end
{aligned}
\right.
\\
令e' = 2e*Δx = 2(k-0.5)Δx = 2Δy - Δx</script><h4 id="代码实现-C-2"><a href="#代码实现-C-2" class="headerlink" title="代码实现(C++)"></a>代码实现(C++)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Implementation of Bresenham Algorithm, written by Jocoboy.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawDDALine</span><span class="params">(Point p1,Point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = p2.x - p1.x;</span><br><span class="line">    <span class="keyword">float</span> dy = p2.y - p1.y;</span><br><span class="line">    <span class="keyword">float</span> k = dy / dx;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(k) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = p1.x,y = p1.y ; x &lt;= p2.x ; x++,y++)&#123;</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(k) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> e = -dx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = p1.x ; x &lt;= p2.x ; x++)&#123;</span><br><span class="line">            e += <span class="number">2</span>*dy;</span><br><span class="line">            <span class="keyword">if</span>(e &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                y++;</span><br><span class="line">                e -= <span class="number">2</span>*dx;</span><br><span class="line">            &#125;</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> e = -dy;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> y = p1.y ; y &lt;= p2.y ; y++)&#123;</span><br><span class="line">            e += <span class="number">2</span>*dx;</span><br><span class="line">            <span class="keyword">if</span>(e &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                x++;</span><br><span class="line">                e -= <span class="number">2</span>*dy;</span><br><span class="line">            &#125;</span><br><span class="line">            drawPixel(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多边形光栅化"><a href="#多边形光栅化" class="headerlink" title="多边形光栅化"></a>多边形光栅化</h2><h4 id="内外测试法"><a href="#内外测试法" class="headerlink" title="内外测试法"></a>内外测试法</h4><h5 id="奇偶规则"><a href="#奇偶规则" class="headerlink" title="奇偶规则"></a>奇偶规则</h5><p><img src='https://img-blog.csdnimg.cn/20201201120558130.png'></p>
<ol>
<li>从任意位置p作一条射线（注意不要经过多边形的顶点）；</li>
<li>若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。</li>
</ol>
<h5 id="非零环绕数规则（Nonzero-Winding-Number-Rule）"><a href="#非零环绕数规则（Nonzero-Winding-Number-Rule）" class="headerlink" title="非零环绕数规则（Nonzero Winding Number Rule）"></a>非零环绕数规则（Nonzero Winding Number Rule）</h5><p><img src='https://img-blog.csdnimg.cn/20201201120641458.png'><img src='https://img-blog.csdnimg.cn/20201201120704886.png'></p>
<ol>
<li>从任意位置p作一条射线（注意不要经过多边形的顶点）；</li>
<li>将多边形的边矢量化，当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数；</li>
<li>每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1；</li>
<li>若环绕数为非零，则p为内部点，否则，p是外部点。</li>
</ol>
<h4 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h4><h5 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h5><p>用水平扫描线从上到下（或从下到上）扫描由多条首尾相连的线段构成的多边形，每根扫描线与多边形的某些边产生一系列交点。将这些交点按照x坐标排序，将排序后的点两两成对，作为线段的两个端点，以所填的颜色画水平直线。多边形被扫描完毕后，颜色填充也就完成了。</p>
<h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>求交，计算扫描线与多边形的交点；</p>
</li>
<li><p>交点排序，对第2步得到的交点按照x值从小到大进行排序；</p>
</li>
<li><p>颜色填充，对排序后的交点两两组成一个水平线段，以画线段的方式进行颜色填充；</p>
</li>
<li><p>是否完成多边形扫描？如果是就结束算法，如果不是就改变扫描线，然后转第1步继续处理。</p>
</li>
</ol>
<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p> 整个算法的关键是第1步，需要用尽量少的计算量求出交点，还要考虑交点是线段端点的特殊情况，最后，交点的步进计算最好是整数，便于光栅设备输出显示。对于每一条扫描线，如果每次都按照正常的线段求交算法进行计算，则计算量大，而且效率低下。观察多边形与扫描线的交点情况，可以得到以下两个特点：</p>
<ol>
<li>每次只有相关的几条边可能与扫描线有交点，不必对所有的边进行求交计算；</li>
<li>相邻的扫描线与同一直线段的交点存在步进关系，这个关系与直线段所在直线的斜率有关；</li>
</ol>
<p><img src='https://img-blog.csdnimg.cn/20201201123507744.png'></p>
<p>第一个特点是显而易见的，为了减少计算量，扫描线算法需要维护一张由活动边组成的表，称为活动边表（Active Edge Table，又称有效边表，以下简称AET）。例如扫描线4的AET由P1P2和P3P4两条边组成，而扫描线7的AET由P1P2、P6P1、P5P6和P4P5四条边组成。</p>
<p>  第二个特点可以进一步证明，假设当前扫描线与多边形的某一条边的交点已经通过直线段求交算法计算出来，得到交点的坐标为（x, y），则下一条扫描线与这条边的交点不需要再求交计算，通过步进关系可以直接得到新交点坐标为（x + △x, y + 1）。前面提到过，步进关系△x是个常量，与直线的斜率有关，下面就来推导这个△x。</p>
<p>  假设多边形某条边所在的直线方程是：ax + by + c = 0，扫描线yi和下一条扫描线yi+1与该边的两个交点分别是（xi，yi）和（xi+1，yi+1），则可得到以下两个等式：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
ax_i+by_i+c = 0 \\ax_{i+1}+by_{i+1}+c = 0\end
{aligned}
\right.</script><p>求解xi，xi+1可得：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
x_i = -(by_i+c)/a \\x_{i+1} = -(by_{i+1}+c)/a \end
{aligned}
\right.</script><p>两式相减，可得：</p>
<script type="math/tex; mode=display">
x_{i+1}-x_i=-b(y_{i+1}-y_i)/a</script><p>由于扫描线存在yi+1 = yi + 1的关系，代入上式可得：</p>
<script type="math/tex; mode=display">
x_{i+1}-x_i = -b/a</script><p>即△x = -b / a，是个常量（直线斜率的倒数）。</p>
<p>AET是扫描线填充算法的核心，整个算法都是围绕者这张表进行处理的。要完整的定义AET，需要先定义边的数据结构。每条边都和扫描线有个交点，扫描线填充算法只关注交点的x坐标。每当处理下一条扫描线时，根据△x直接计算出新扫描线与边的交点x坐标，可以避免复杂的求交计算。一条边不会一直待在AET中，当扫描线与之没有交点时，要将其从AET中删除，判断是否有交点的依据就是看扫描线y是否大于这条边两个端点的y坐标值，为此，需要记录边的y坐标的最大值。根据以上分析，边的数据结构可以定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ETNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> xi;</span><br><span class="line">    <span class="keyword">double</span> dx;</span><br><span class="line">    <span class="keyword">int</span> ymax;</span><br><span class="line">    ETNode* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ETNode的定义，扫描线4和扫描线7的AET如下所示：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201130026187.png'></p>
<p><img src='https://img-blog.csdnimg.cn/20201201130053238.png'></p>
<p> 前面提到过，扫描线算法的核心就是围绕AET展开的，为了方便活性边表的建立与更新，我们为每一条扫描线建立一个边表（Edge Table，以下简称ET），存放该扫描线第一次出现的边。当算法处理到某条扫描线时，就将这条扫描线的ET中的所有边逐一插入到AET中。ET通常在算法开始时建立，建立ET的规则就是：如果某条边的较低端点（y坐标较小的那个点）的y坐标与扫描线y相等，则该边就是扫描线y的新边，应该加入扫描线y的ET。上例中各扫描线的ET如下图所示：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201130813624.png'></p>
<h5 id="AET边表算法步骤"><a href="#AET边表算法步骤" class="headerlink" title="AET边表算法步骤"></a>AET边表算法步骤</h5><ol>
<li>初始化：构造边表，AET表置空；</li>
<li>将第一个不空的ET表中的边与AET表合并；</li>
<li>由AET表中取出交点对进行填充。填充之后删除ymax=y的边；</li>
<li>yi+1=yi+1,根据xi+1=xi+1/k计算并修改AET表，同时合并ET表中y=yi+1桶中的边，按次序插入到AET表中，形成新的AET表；</li>
<li>AET表不为空则转(3)，否则结束。</li>
</ol>
<h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><blockquote>
<p>如下图所示多边形，若采用ET边表算法进行填充，试写出该多边形的ET表和当扫描线Y=3时的AET表。</p>
<p><img src='https://img-blog.csdnimg.cn/20201201161023841.png'></p>
<p>边表节点ETNode形式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">X</th>
<th style="text-align:center">Ymax</th>
<th style="text-align:center">1/k</th>
<th style="text-align:center">next</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>ET表：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201162353749.png'></p>
<p>Y = 3时的AET表：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201162419678.png'></p>
</blockquote>
<h4 id="种子填充算法"><a href="#种子填充算法" class="headerlink" title="种子填充算法"></a>种子填充算法</h4><p>种子填充是指从区域内的某一个象素点（种子点）开始，由内向外将填充色扩展到整个区域内的过程。</p>
<p>算法的输入：种子点坐标(x,y)，填充色以及边界颜色。</p>
<p>利用堆栈实现简单的种子填充算法:</p>
<p>​    算法从种子点开始检测相邻位置是否是边界颜色，若不是就用填充色着色，并检测该像素点的相邻位置，直到检测完区域边界颜色范围内的所有像素为止。</p>
<h5 id="区域连通方式"><a href="#区域连通方式" class="headerlink" title="区域连通方式"></a>区域连通方式</h5><ul>
<li><p>4-邻接点和8-邻接点</p>
<p><img src='https://img-blog.csdnimg.cn/20201201173807602.png'></p>
</li>
<li><p>4连通种子填充算法的填充结果</p>
<p><img src='https://img-blog.csdnimg.cn/20201201171635347.png'></p>
</li>
<li><p>8连通种子填充算法的填充结果</p>
<p><img src='https://img-blog.csdnimg.cn/20201201171659172.png'></p>
</li>
</ul>
<p>对于一个区域的内部点而言，如果能够通过4-邻接点完全遍历，也就能够通过8-邻接点完全遍历。</p>
<h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>栈结构实现4-连通种子填充算法的算法步骤为：</p>
<ol>
<li>种子象素入栈；</li>
<li>当栈非空时重复执行如下三步操作：<ul>
<li>栈顶象素出栈；</li>
<li>将出栈象素置成填充色；</li>
<li>检查出栈象素的4-邻接点，若其中某个象素点不是边界色且未置成多边形色，则把该象素入栈。</li>
</ul>
</li>
<li>检查栈是否为空，若栈非空重复执行2，若栈为空则结束。</li>
</ol>
<h4 id="扫描线种子填充算法"><a href="#扫描线种子填充算法" class="headerlink" title="扫描线种子填充算法"></a>扫描线种子填充算法</h4><p>扫描线种子填充算法：</p>
<p>​    扫描线通过在任意不间断扫描线区间中只取一个种子像素的方法使堆栈的尺寸极小化。不间断区间是指在一条扫描线上的一组相邻像素。</p>
<h5 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>算法步骤为：</p>
<ol>
<li>种子象素入栈；</li>
<li>当栈非空时重复执行如下三步操作：<ul>
<li>栈顶象素出栈；</li>
<li>填充出栈像素所在扫描行的连续像素段，从出栈的像素开始沿扫描线向左和向右填充，直到遇到边界像素为止，并且记录下此时扫描线区间的x坐标范围；</li>
<li>分别检查上下扫描线上位于上述x区间内的未被填充的连续水平像素段，将其最右像素取作种子像素压入堆栈。</li>
</ul>
</li>
<li>检查栈是否为空，若栈非空重复执行2，若栈为空则结束。</li>
</ol>
<h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><p><img src='https://img-blog.csdnimg.cn/20201201182357394.png'></p>
<h1 id="Fragment-processing-片元处理"><a href="#Fragment-processing-片元处理" class="headerlink" title="Fragment processing(片元处理)"></a>Fragment processing(片元处理)</h1><h1 id="Frame-buffer-帧缓存"><a href="#Frame-buffer-帧缓存" class="headerlink" title="Frame buffer(帧缓存)"></a>Frame buffer(帧缓存)</h1><h1 id="Hidden-surface-隐藏面消除"><a href="#Hidden-surface-隐藏面消除" class="headerlink" title="Hidden surface(隐藏面消除)"></a>Hidden surface(隐藏面消除)</h1><h2 id="深度缓存方法"><a href="#深度缓存方法" class="headerlink" title="深度缓存方法"></a>深度缓存方法</h2><ol>
<li>对于平面上每个像素P[i][j]，深度缓存一个b比特的量d[i][j]；</li>
<li>P[i][j]保存屏幕上该点目前最近面片的颜色；</li>
<li>d[i][j]保存屏幕上该点目前最近面片的伪深度;</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for（场景中的每一个多边形）</span><br><span class="line">&#123;</span><br><span class="line">      扫描转换该多边形；</span><br><span class="line">      for（多边形所覆盖的每一个像素点(x,y)）</span><br><span class="line">     &#123;</span><br><span class="line">           计算多边形在该像素点的深度值z(x,y)；</span><br><span class="line">           if（z(x,y) &lt; Z-buf中对应此像素点(x,y)的z值）</span><br><span class="line">           &#123;</span><br><span class="line">                 把多边形在(x,y)处的深度值z(x,y)存入Z-buf中的(x,y)处；</span><br><span class="line">                 把多边形在(x,y)处的亮度值存入f-buf中的(x,y)处；</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当所有的多边形都处理完后，帧缓冲器中的内容即为消除隐藏面后的图像。</p>
<h3 id="OpenGL实现隐藏面消除的相关API"><a href="#OpenGL实现隐藏面消除的相关API" class="headerlink" title="OpenGL实现隐藏面消除的相关API"></a>OpenGL实现隐藏面消除的相关API</h3><ul>
<li>初始化显示模式时指明使用深度缓存：glutInitDisplayMode(GLUT_DEPTH|GLUT_RGB);</li>
<li>启用深度测试<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glenable">glEnable(GL_DEPTH_TEST)</a>;</li>
<li>渲染每一幅图像之前要初始化深度缓存：<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glclear">glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)</a>;</li>
<li>关闭深度测试<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gldisable">glDisable(GL_DEPTH_TEST)</a>; </li>
<li>深度测试范围：<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gldepthrange">glDepthRange (zNear, zFar)</a>;</li>
<li>选择比较测试的方法：<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gldepthfunc">glDepthFunc(func)</a>;</li>
</ul>
<h1 id="Anti-aliasing-technology-反走样技术"><a href="#Anti-aliasing-technology-反走样技术" class="headerlink" title="Anti-aliasing technology(反走样技术)"></a>Anti-aliasing technology(反走样技术)</h1><p>用离散量表示连续量引起的失真，就叫做走样（Aliasing）。用于减少或消除这种现象效果的技术，称为反走样（Antialiasing）</p>
<p><img src='https://img-blog.csdnimg.cn/20201201193529109.png'></p>
<p>产生原因：<br>    数学意义上的图形是由无线多个连续的、面积为零的点构成；但在光栅显示器上，用有限多个离散的，具有一定面积的象素来近似地表示他们。</p>
<h2 id="Super-sampling-过取样"><a href="#Super-sampling-过取样" class="headerlink" title="Super sampling(过取样)"></a>Super sampling(过取样)</h2><p>高分辨率计算，低分辨率显示。在高于显示分辨率的较高分辨率下用点取样方法计算，然后对几个象素的属性进行平均得到较低分辨率下的象素属性。</p>
<h3 id="简单过取样"><a href="#简单过取样" class="headerlink" title="简单过取样"></a>简单过取样</h3><p>在x，y方向把分辨率都提高一倍，使每个象素对应4个子象素，然后扫描转换求得各子象素的颜色亮度，再对4个象素的颜色亮度进行平均，得到较低分辨率下的象素颜色亮度。</p>
<p>简单的过取样方式：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201194654625.png'></p>
<h3 id="基于加权模板的过取样"><a href="#基于加权模板的过取样" class="headerlink" title="基于加权模板的过取样"></a>基于加权模板的过取样</h3><p>简单过取样在确定像素的亮度时，仅仅是对所有子像素的亮度进行简单的平均。更常见的做法是给接近像素中心的子像素赋予较大的权值，即对所有子像素的亮度进行加权平均。</p>
<p>常用的加权模板：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201194609603.png'></p>
<h2 id="Area-sampling-区域取样"><a href="#Area-sampling-区域取样" class="headerlink" title="Area sampling(区域取样)"></a>Area sampling(区域取样)</h2><p>在整个像素区域内进行采样，这种技术称为区域取样。像素的亮度是作为一个整体被确定的，不需要划分子像素。</p>
<p>根据相交的面积值决定像素显示的亮度级别：</p>
<p><img src='https://img-blog.csdnimg.cn/20201201194753455.png'></p>
<h2 id="OpenGL反走样技术的相关API"><a href="#OpenGL反走样技术的相关API" class="headerlink" title="OpenGL反走样技术的相关API"></a>OpenGL反走样技术的相关API</h2><ul>
<li><p>启用反走样：<a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glenable">glEnable(primitiveType)</a>;</p>
</li>
<li><p>启用OpenGL颜色混和并指定颜色混合函数： </p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glenable">glEnable(GL_BLEND)</a>;<br><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glblendfunc">glBlendFunc(GL_SCR_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</a>;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Theories</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-CG-API</title>
    <url>/2020/12/16/OpenGL-CG-API/</url>
    <content><![CDATA[<p>基于OpenGL绘制一个简单的三维场景，涉及场景建模、透视投影、光照和材质、纹理映射、*阴影处理、简单动画、鼠标键盘交互等技术内容。<br><a id="more"></a></p>
<h1 id="基于OpenGL绘制三维场景"><a href="#基于OpenGL绘制三维场景" class="headerlink" title="基于OpenGL绘制三维场景"></a>基于OpenGL绘制三维场景</h1><h2 id="Models-建模"><a href="#Models-建模" class="headerlink" title="Models(建模)"></a>Models(建模)</h2><h3 id="glu库中常用的模型生成函数"><a href="#glu库中常用的模型生成函数" class="headerlink" title="glu库中常用的模型生成函数"></a>glu库中常用的模型生成函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluSphere</span><span class="params">(GLUquadricObj* pobj,GLdouble radius,GLint silces,GLint stacks)</span></span>; <span class="comment">// 球</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluCylinder</span><span class="params">(GLUquadricObj* pobj,GLdouble baseRadius,GLdouble topRadius,GLint slices,GLint stacks)</span></span>; <span class="comment">// 圆柱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluDisk</span><span class="params">(GLUquadricObj* pobj,GLdouble innerRadius,GLdouble outerRadius,GLint slices,GLint stacks)</span></span>; <span class="comment">// 圆盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluPartialDisk</span> <span class="params">(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)</span></span>; <span class="comment">// 不完整圆盘</span></span><br></pre></td></tr></table></figure>
<h3 id="glut库中常用的模型生成函数"><a href="#glut库中常用的模型生成函数" class="headerlink" title="glut库中常用的模型生成函数"></a>glut库中常用的模型生成函数</h3><h4 id="实心模型"><a href="#实心模型" class="headerlink" title="实心模型"></a>实心模型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidCube</span><span class="params">(GLdouble size)</span></span>; <span class="comment">// 实心立方体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidSphere</span><span class="params">(GLdouble radius, GLint slices, GLint stacks)</span></span>; <span class="comment">// 实心球</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidCone</span><span class="params">(GLdouble radius, GLdouble height, GLint slices, GLint stacks)</span></span>; <span class="comment">// 实心圆锥体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidTorus</span><span class="params">(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings)</span></span>; <span class="comment">// 实心圆环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidTeapot</span><span class="params">(GLdouble size)</span></span>; <span class="comment">// 实心茶壶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidTetrahedron</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 实心4面体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidOctahedron</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 实心8面体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidDodecahedron</span><span class="params">(GLdouble radius)</span></span>; <span class="comment">// 实心12面体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutSolidIcosahedron</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 实心20面体</span></span><br></pre></td></tr></table></figure>
<h4 id="线框模型"><a href="#线框模型" class="headerlink" title="线框模型"></a>线框模型</h4><p>以glutWire前缀开头，同实心模型。</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><h4 id="注册自适应窗口函数"><a href="#注册自适应窗口函数" class="headerlink" title="注册自适应窗口函数"></a>注册自适应窗口函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glutReshapeFunc(<span class="keyword">void</span>(*func)(<span class="keyword">int</span> w,<span class="keyword">int</span> h));</span><br></pre></td></tr></table></figure>
<h4 id="改变窗口形状函数原型"><a href="#改变窗口形状函数原型" class="headerlink" title="改变窗口形状函数原型"></a>改变窗口形状函数原型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- func   处理改变窗口形状事件的函数名</span></span><br><span class="line"><span class="comment">- w,h	 窗口的宽高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">int</span> w,<span class="keyword">int</span> h);</span><br></pre></td></tr></table></figure>
<h5 id="处理改变窗口形状事件的函数模板"><a href="#处理改变窗口形状事件的函数模板" class="headerlink" title="处理改变窗口形状事件的函数模板"></a>处理改变窗口形状事件的函数模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, (GLsizei)w, (GLsizei)h);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();	<span class="comment">//在进行变换之前需要将当前矩阵转换为单位矩阵才能进行操作</span></span><br><span class="line">    gluPerspective(<span class="number">45</span>, (GLfloat)w / (GLfloat)h, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lights-光照"><a href="#Lights-光照" class="headerlink" title="Lights(光照)"></a>Lights(光照)</h2><h3 id="光源设置函数原型"><a href="#光源设置函数原型" class="headerlink" title="光源设置函数原型"></a>光源设置函数原型</h3><h4 id="glLightf"><a href="#glLightf" class="headerlink" title="glLightf"></a><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gllightf">glLightf</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- light  灯的标识符。可能的指示灯数量取决于实现方式，但至少支持八个指示灯。</span></span><br><span class="line"><span class="comment">		 它们由GL_LIGHTi形式的符号名称标识，其中i是值：0到GL_MAX_LIGHTS-1。</span></span><br><span class="line"><span class="comment">- pname  光源参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_SPOT_EXPONENT、GL_SPOT_CUTOFF、</span></span><br><span class="line"><span class="comment">		 		GL_CONSTANT_ATTENUATION、GL_LINEAR_ATTENUATION、GL_QUADRATIC_ATTENUATION</span></span><br><span class="line"><span class="comment">		 </span></span><br><span class="line"><span class="comment">- params  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glLightf</span><span class="params">(GLenum light,GLenum pname,GLfloat params)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><h6 id="设置光源最大发散角"><a href="#设置光源最大发散角" class="headerlink" title="设置光源最大发散角"></a>设置光源最大发散角</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, <span class="number">30.0</span>);</span><br></pre></td></tr></table></figure>
<h6 id="设置光源的强度分布"><a href="#设置光源的强度分布" class="headerlink" title="设置光源的强度分布"></a>设置光源的强度分布</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, <span class="number">4.0</span>);</span><br></pre></td></tr></table></figure>
<h6 id="设置光源的衰减因子"><a href="#设置光源的衰减因子" class="headerlink" title="设置光源的衰减因子"></a>设置光源的衰减因子</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- [GL_CONSTANT_ATTENUATION] 	the constant factor</span></span><br><span class="line"><span class="comment">- [GL_LINEAR_ATTENUATION]		the linear factor multiplied by the distance between the 								 light and the vertex being lighted</span></span><br><span class="line"><span class="comment">- [GL_QUADRATIC_ATTENUATION]	the quadratic factor multiplied by the square of the same 								  distance</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="glLightfv"><a href="#glLightfv" class="headerlink" title="glLightfv"></a><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gllightfv">glLightfv</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- light  灯的标识符。可能的指示灯数量取决于实现方式，但至少支持八个指示灯。</span></span><br><span class="line"><span class="comment">		 它们由GL_LIGHTi形式的符号名称标识，其中i是值：0到GL_MAX_LIGHTS-1。</span></span><br><span class="line"><span class="comment">- pname  光源参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_AMBIENT、GL_DIFFUSE、GL_SPECULAR、GL_POSITION、</span></span><br><span class="line"><span class="comment">		 		GL_SPOT_DIRECTION、GL_SPOT_EXPONENT、GL_SPOT_CUTOFF、</span></span><br><span class="line"><span class="comment">		 		GL_CONSTANT_ATTENUATION、GL_LINEAR_ATTENUATION、GL_QUADRATIC_ATTENUATION</span></span><br><span class="line"><span class="comment">		 </span></span><br><span class="line"><span class="comment">- params  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glLightfv</span><span class="params">(GLenum light,GLenum pname,<span class="keyword">const</span> GLfloat *params)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><h6 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat light0_ambient[] = &#123; <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);</span><br></pre></td></tr></table></figure>
<h6 id="漫反射光"><a href="#漫反射光" class="headerlink" title="漫反射光"></a>漫反射光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat light0_diffuse[] = &#123; <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);</span><br></pre></td></tr></table></figure>
<h6 id="镜面反射光"><a href="#镜面反射光" class="headerlink" title="镜面反射光"></a>镜面反射光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat light0_specular[] = &#123; <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);</span><br></pre></td></tr></table></figure>
<h6 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat light0_position[] = &#123; <span class="number">-3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, light0_position);</span><br></pre></td></tr></table></figure>
<h6 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat spot_direction[] = &#123; <span class="number">3.0</span>,<span class="number">3.0</span>,<span class="number">-3.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);</span><br></pre></td></tr></table></figure>
<h4 id="glLightModeli"><a href="#glLightModeli" class="headerlink" title="glLightModeli"></a><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gllightmodeli">glLightModeli</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- pname  光源参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_LIGHT_MODEL_LOCAL_VIEWER</span></span><br><span class="line"><span class="comment">				GL_LIGHT_MODEL_TWO_SIDE</span></span><br><span class="line"><span class="comment">		 </span></span><br><span class="line"><span class="comment">- params  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h6 id="设置视点为局部视点"><a href="#设置视点为局部视点" class="headerlink" title="设置视点为局部视点"></a>设置视点为局部视点</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE); </span><br></pre></td></tr></table></figure>
<h6 id="设置多边形着色方式为双面着色"><a href="#设置多边形着色方式为双面着色" class="headerlink" title="设置多边形着色方式为双面着色"></a>设置多边形着色方式为双面着色</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);</span><br></pre></td></tr></table></figure>
<h4 id="glLightModelfv"><a href="#glLightModelfv" class="headerlink" title="glLightModelfv"></a><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/gllightmodelfv">glLightModelfv</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- pname  光源参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_LIGHT_MODEL_AMBIENT</span></span><br><span class="line"><span class="comment">		 		GL_LIGHT_MODEL_LOCAL_VIEWER</span></span><br><span class="line"><span class="comment">				GL_LIGHT_MODEL_TWO_SIDE</span></span><br><span class="line"><span class="comment">		 </span></span><br><span class="line"><span class="comment">- params  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glLightModelfv</span><span class="params">(GLenum pname,<span class="keyword">const</span> GLfloat *params)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="开启全局环境光"><a href="#开启全局环境光" class="headerlink" title="开启全局环境光"></a>开启全局环境光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat amb[] = &#123; <span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.1</span>,<span class="number">1.0</span> &#125;;</span><br><span class="line">glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb);</span><br></pre></td></tr></table></figure>
<h4 id="启用光照"><a href="#启用光照" class="headerlink" title="启用光照"></a>启用光照</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">If enabled, normal vectors specified with glNormal are scaled to unit length after transformation. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glEnable(GL_NORMALIZE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If enabled, use the current lighting parameters to compute the vertex color or index. If disabled, associate the current color or index with each vertex.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glEnable(GL_LIGHTING);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If enabled, include light i in the evaluation of the lighting equation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glEnable(GL_LIGHT0);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If enabled, do depth comparisons and update the depth buffer. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure>
<h2 id="Materials-材质"><a href="#Materials-材质" class="headerlink" title="Materials(材质)"></a>Materials(材质)</h2><h3 id="材质设置函数原型"><a href="#材质设置函数原型" class="headerlink" title="材质设置函数原型"></a>材质设置函数原型</h3><h4 id="glMaterialfv"><a href="#glMaterialfv" class="headerlink" title="glMaterialfv"></a><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glmaterialfv">glMaterialfv</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- face  </span></span><br><span class="line"><span class="comment">		 可选值：GL_FRONT、GL_BACK、GL_FRONT_AND_BACK</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">- pname		材质参数</span></span><br><span class="line"><span class="comment">	 		可选值：GL_AMBIENT、GL_DIFFUSE、GL_SPECULAR</span></span><br><span class="line"><span class="comment">	 				GL_EMISSION、GL_SHININESS、</span></span><br><span class="line"><span class="comment">	 				GL_AMBIENT_AND_DIFFUSE、GL_COLOR_INDEXES	</span></span><br><span class="line"><span class="comment">- params  	根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glMaterialfv</span><span class="params">(GLenum face,GLenum pname,<span class="keyword">const</span> GLfloat *params)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><blockquote>
<p>（1）GL_AMBIENT、GL_DIFFUSE、GL_SPECULAR属性。这三个属性与光源的三个对应属性类似，每一属性都由四个值组成。GL_AMBIENT表示各种光线照射到该材质上，经过很多次反射后最终遗留在环境中的光线强度（颜色）。GL_DIFFUSE表示光线照射到该材质上，经过漫反射后形成的光线强度（颜色）。GL_SPECULAR表示光线照射到该材质上，经过镜面反射后形成的光线强度（颜色）。通常，GL_AMBIENT和GL_DIFFUSE都取相同的值，可以达到比较真实的效果。使用GL_AMBIENT_AND_DIFFUSE可以同时设置GL_AMBIENT和GL_DIFFUSE属性。<br>（2）GL_SHININESS属性。该属性只有一个值，称为“镜面指数”，取值范围是0到128。该值越小，表示材质越粗糙，点光源发射的光线照射到上面，也可以产生较大的亮点。该值越大，表示材质越类似于镜面，光源照射到上面后，产生较小的亮点。<br>（3）GL_EMISSION属性。该属性由四个值组成，表示一种颜色。OpenGL认为该材质本身就微微的向外发射光线，以至于眼睛感觉到它有这样的颜色，但这光线又比较微弱，以至于不会影响到其它物体的颜色。<br>（4）GL_COLOR_INDEXES属性。该属性仅在颜色索引模式下使用，由于颜色索引模式下的光照比RGBA模式要复杂，并且使用范围较小，这里不做讨论。</p>
</blockquote>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><h6 id="遗留环境光"><a href="#遗留环境光" class="headerlink" title="遗留环境光"></a>遗留环境光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat mat_ambient[] = &#123; <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span> &#125;; </span><br><span class="line">glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);</span><br></pre></td></tr></table></figure>
<h6 id="遗留漫反射光"><a href="#遗留漫反射光" class="headerlink" title="遗留漫反射光"></a>遗留漫反射光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat mat_diffuse[] = &#123; <span class="number">0.0</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);</span><br></pre></td></tr></table></figure>
<h6 id="遗留镜面光"><a href="#遗留镜面光" class="headerlink" title="遗留镜面光"></a>遗留镜面光</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat mat_specular[] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.8</span>, <span class="number">1.0</span> &#125;; </span><br><span class="line">glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);</span><br></pre></td></tr></table></figure>
<h6 id="设置镜面指数"><a href="#设置镜面指数" class="headerlink" title="设置镜面指数"></a>设置镜面指数</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat mat_shininess[] = &#123; <span class="number">50.0</span> &#125;;</span><br><span class="line">glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);</span><br></pre></td></tr></table></figure>
<h2 id="Textures-纹理"><a href="#Textures-纹理" class="headerlink" title="Textures(纹理)"></a>Textures(纹理)</h2><h3 id="二维纹理"><a href="#二维纹理" class="headerlink" title="二维纹理"></a>二维纹理</h3><h4 id="指定二维纹理"><a href="#指定二维纹理" class="headerlink" title="指定二维纹理"></a>指定二维纹理</h4><h5 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- target 目标纹理</span></span><br><span class="line"><span class="comment">		 唯一可选值：GL_TEXTURE_2D</span></span><br><span class="line"><span class="comment">- level  表示纹理多分辨率层数，通常取值为0，表示只有一种分辨率</span></span><br><span class="line"><span class="comment">		 可选值：0~n</span></span><br><span class="line"><span class="comment">- internalformat 表示纹理元素中存储的哪些分量（RGBA颜色、深度等）在纹理映射中被使用，</span></span><br><span class="line"><span class="comment">				 1表示使用R颜色分量，2表示使用R和A颜色分量，3表示使用RGB颜色分量，4表示使用RGBA颜色分量</span></span><br><span class="line"><span class="comment">				 可选值：1~4以及多种符号常量(如GL_RGBA)				  </span></span><br><span class="line"><span class="comment">- width,height	纹理图像的宽高</span></span><br><span class="line"><span class="comment">- border 		纹理边框的宽度</span></span><br><span class="line"><span class="comment">				可选值：0,1</span></span><br><span class="line"><span class="comment">- format		指定图像的数据格式</span></span><br><span class="line"><span class="comment">				可选值：GL_COLOR_INDEX、GL_RED、GL_GREEN、GL_BLUE、GL_ALPHA、GL_RGB、GL_RGBA、</span></span><br><span class="line"><span class="comment">				      GL_BGR_EXT、GL_BGRA_EXT、GL_LUMINANCE、GL_LUMINANCE_ALPHA</span></span><br><span class="line"><span class="comment">- type			指定图像的数据类型</span></span><br><span class="line"><span class="comment">				可选值：GL_UNSIGNED_BYTE、GL_BYTE、GL_BITMAP、GL_UNSIGNED_SHORT、</span></span><br><span class="line"><span class="comment">					   GL_SHORT、GL_UNSIGNED_INT、GL_INT、and GL_FLOAT</span></span><br><span class="line"><span class="comment">- pixels	    指向内存中指定的纹理图像数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexImage2D</span><span class="params">(GLenum target,GLint level,GLint internalformat,GLsizei width,</span></span></span><br><span class="line"><span class="function"><span class="params">GLsizei height,GLint border,GLint format,GLenum type,<span class="keyword">const</span> GLvoid *pixels)</span></span>;</span><br></pre></td></tr></table></figure>
<p>启用二维纹理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If enabled, two-dimensional texturing is performed.  */</span></span><br><span class="line">glEnable(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure></p>
<p> 在启用纹理之后，需要建立物体表面上点与纹理空间的对应关系，即在绘制基本图元时，在glVertex函数调用之前调用glTexCoord函数，明确指定当前顶点所对应的纹理坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glBegin(GL_QUADS);  </span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>,<span class="number">0.0</span>);glVertex3f(<span class="number">1.0</span>,<span class="number">2.5</span>,<span class="number">1.5</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>,<span class="number">0.6</span>);glVertex3f(<span class="number">1.0</span>,<span class="number">3.7</span>,<span class="number">1.5</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">0.8</span>,<span class="number">0.6</span>);glVertex3f(<span class="number">2.0</span>,<span class="number">3.7</span>,<span class="number">1.5</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">0.8</span>,<span class="number">0.0</span>);glVertex3f(<span class="number">2.0</span>,<span class="number">2.5</span>,<span class="number">1.5</span>);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure>
<p>其图元内部点的纹理坐标利用顶点处的纹理坐标采用线性插值的方法计算出来。</p>
<h4 id="设置纹理环绕和纹理滤波"><a href="#设置纹理环绕和纹理滤波" class="headerlink" title="设置纹理环绕和纹理滤波"></a>设置纹理环绕和纹理滤波</h4><h5 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- target 目标纹理</span></span><br><span class="line"><span class="comment">		 可选值：GL_TEXTURE_1D、GL_TEXTURE_2D</span></span><br><span class="line"><span class="comment">- pname	 纹理参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_TEXTURE_MIN_FILTER、GL_TEXTURE_MAG_FILTER、</span></span><br><span class="line"><span class="comment">		 		GL_TEXTURE_WRAP_S、GL_TEXTURE_WRAP_T</span></span><br><span class="line"><span class="comment">- param  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexParameterf</span><span class="params">(GLenum target,GLenum pname,GLfloat param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexParameteri</span><span class="params">(GLenum target,GLenum pname,GLfloat param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在OpenGL中，纹理坐标的范围被指定在[0,1]之间，而在使用映射函数进行纹理坐标计算时，有可能得到不在[0,1]之间的坐标。此时OpenGL有两种处理方式，一种是截断，另一种是重复，它们被称为环绕模式:</p>
<ul>
<li>GL_CLAMP    将大于1.0的纹理坐标设置为1.0，将小于0.0的纹理坐标设置为0.0</li>
<li>GL_REPEAT   如果纹理坐标不在[0,1]之间，则将纹理坐标值的整数部分舍弃，只使用小数部分，这样使纹理图像在物体表面重复出现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br></pre></td></tr></table></figure>
<p>在变换和纹理映射后，屏幕上的一个像素可能对应纹理元素的一小部分（放大），也可能对应大量的处理元素（缩小）。在OpenGL中，允许指定多种方式来决定如何完成像素与纹理元素对应的计算方法（滤波）:</p>
<ul>
<li>GL_NEAREST    取比较接近的那个像素</li>
<li>GL_LINEAR       以周围四个像素的加权平均值做为纹理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>
<h4 id="设置纹理调和"><a href="#设置纹理调和" class="headerlink" title="设置纹理调和"></a>设置纹理调和</h4><h5 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- target 目标纹理</span></span><br><span class="line"><span class="comment">		 唯一可选值：GL_TEXTURE_ENV</span></span><br><span class="line"><span class="comment">- pname	 纹理参数</span></span><br><span class="line"><span class="comment">		 唯一可选值：GL_TEXTURE_ENV_MODE</span></span><br><span class="line"><span class="comment">- param  根据pname的值指定确切的参数值</span></span><br><span class="line"><span class="comment">		 可选值：GL_MODULATE、GL_DECAL、GL_BLEND、GL_REPLACE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexEnvf</span><span class="params">(GLenum target,GLenum pname,GLfloat param)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Modulate：把表面的颜色与纹理颜色相乘</li>
<li>Decal：若纹理中包含Alpha值，则用它与表面的颜色进行混合</li>
<li>Replace： 把表面的颜色替换为纹理的颜色</li>
</ul>
<h4 id="使用纹理坐标"><a href="#使用纹理坐标" class="headerlink" title="使用纹理坐标"></a>使用纹理坐标</h4><h5 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- coord 纹理坐标</span></span><br><span class="line"><span class="comment">		 可选值：GL_S、GL_T、GL_R、GL_Q</span></span><br><span class="line"><span class="comment">- pname	 纹理坐标生成函数标识符</span></span><br><span class="line"><span class="comment">		 唯一可选值：GL_TEXTURE_GEN_MODE</span></span><br><span class="line"><span class="comment">- param  纹理生成参数</span></span><br><span class="line"><span class="comment">		 可选值：GL_OBJECT_LINEAR、GL_EYE_LINEAR、GL_SPHERE_MAP</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexGeni</span><span class="params">(GLenum coord,GLenum pname,GLint param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- coord 纹理坐标</span></span><br><span class="line"><span class="comment">		 可选值：GL_S、GL_T、GL_R、GL_Q</span></span><br><span class="line"><span class="comment">- pname	 纹理坐标生成函数标识符</span></span><br><span class="line"><span class="comment">		 可选值：GL_OBJECT_LINEAR、GL_EYE_LINEAR、GL_SPHERE_MAP</span></span><br><span class="line"><span class="comment">- param  包含相应纹理生成函数的浮点数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">glTexGenfv</span><span class="params">(GLenum coord,GLenum pname,<span class="keyword">const</span> GLfloat *params)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat planes[] = &#123; <span class="number">0.5</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.5</span> &#125;;</span><br><span class="line">GLfloat planet[] = &#123; <span class="number">0.0</span>,<span class="number">0.5</span>,<span class="number">0.0</span>,<span class="number">0.5</span> &#125;;</span><br><span class="line">glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);</span><br><span class="line">glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);</span><br><span class="line">glTexGenfv(GL_S, GL_OBJECT_LINEAR, planes);</span><br><span class="line">glTexGenfv(GL_T, GL_OBJECT_LINEAR, planet);</span><br><span class="line">glEnable(GL_TEXTURE_GEN_S);</span><br><span class="line">glEnable(GL_TEXTURE_GEN_T);</span><br></pre></td></tr></table></figure>
<h4 id="纹理导入"><a href="#纹理导入" class="headerlink" title="纹理导入"></a>纹理导入</h4><h5 id="读取bmp位图"><a href="#读取bmp位图" class="headerlink" title="读取bmp位图"></a>读取bmp位图</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AUX_RGBImageRec* <span class="title">LoadBMP</span><span class="params">(CHAR* Filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE* File = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!Filename)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	File = fopen(Filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (File)</span><br><span class="line">	&#123;</span><br><span class="line">		fclose(File);</span><br><span class="line">		<span class="keyword">return</span> auxDIBImageLoadA(Filename);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="从bmp位图加载纹理"><a href="#从bmp位图加载纹理" class="headerlink" title="从bmp位图加载纹理"></a>从bmp位图加载纹理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLuint texture[<span class="number">6</span>];</span><br><span class="line">GLsizei textureSize = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LoadGLTextures</span><span class="params">(CHAR* Filename, GLuint ID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Status = FALSE;</span><br><span class="line">	AUX_RGBImageRec* TextureImage[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(TextureImage, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) * <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (TextureImage[<span class="number">0</span>] = LoadBMP(Filename))</span><br><span class="line">	&#123;</span><br><span class="line">		Status = TRUE;</span><br><span class="line">		glBindTexture(GL_TEXTURE_2D, texture[ID]);</span><br><span class="line">		<span class="comment">/*	glBindTexture(GL_TEXTURE_2D, ID);*/</span></span><br><span class="line">		glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">3</span>, TextureImage[<span class="number">0</span>]-&gt;sizeX, TextureImage[<span class="number">0</span>]-&gt;sizeY, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line">		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (TextureImage[<span class="number">0</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (TextureImage[<span class="number">0</span>]-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(TextureImage[<span class="number">0</span>]-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(TextureImage[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><h2 id="Animations-动画"><a href="#Animations-动画" class="headerlink" title="Animations(动画)"></a>Animations(动画)</h2><h4 id="注册闲置响应函数"><a href="#注册闲置响应函数" class="headerlink" title="注册闲置响应函数"></a>注册闲置响应函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutIdleFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="注册指定时间响应函数"><a href="#注册指定时间响应函数" class="headerlink" title="注册指定时间响应函数"></a>注册指定时间响应函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">glutTimerFunc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> msecs, <span class="keyword">void</span> (*func)(<span class="keyword">int</span> value), <span class="keyword">int</span> value)</span></span>; </span><br></pre></td></tr></table></figure>
<h4 id="闲置响应回调函数-以旋转为例"><a href="#闲置响应回调函数-以旋转为例" class="headerlink" title="闲置响应回调函数(以旋转为例)"></a>闲置响应回调函数(以旋转为例)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">void</span>) &#123;</span><br><span class="line">        spin = spin + <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (spin &gt; <span class="number">360.0</span>)</span><br><span class="line">        spin = spin - <span class="number">360.0</span>;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shaders-着色器"><a href="#Shaders-着色器" class="headerlink" title="Shaders(着色器)"></a>Shaders(着色器)</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>标量：float、int和bool</p>
</li>
<li><p>矢量：vec2、vec3、vec4</p>
<p>​            ivec2、ivec3、ivec4</p>
<p>​            bvec2、bvec3、bvec4</p>
</li>
<li><p>矩阵：mat2、mat3、mat4</p>
</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><p>const</p>
<p>变量值</p>
</li>
<li><p>attribute</p>
<p>只能出现在vertex shader中，只能修饰float类型的变量</p>
</li>
<li><p>uniform</p>
<p>从Host Language将我们需要的变量传递到GLSL中，主要出现在顶点（vertex shader）和片元（fragment shader）着色器</p>
</li>
<li><p>varying</p>
<p>用来传递顶点着色器（vertex shader）中的数据到片元（fragment shader）着色器中</p>
</li>
</ul>
<h3 id="顶点程序"><a href="#顶点程序" class="headerlink" title="顶点程序"></a>顶点程序</h3><p><img src='https://img-blog.csdnimg.cn/20201216173103310.png'></p>
<p>顶点程序都必须执行的一项任务就是把输入顶点程序的顶点位置从对象坐标系变换到裁剪坐标系。</p>
<h4 id="直通顶点程序"><a href="#直通顶点程序" class="headerlink" title="直通顶点程序"></a>直通顶点程序</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="built_in">gl_Position</span> = <span class="built_in">gl_ProjectionMatrix</span> * (<span class="built_in">gl_ModelViewMatrix</span> * <span class="built_in">gl_Vertex</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="片元程序"><a href="#片元程序" class="headerlink" title="片元程序"></a>片元程序</h3><p><img src='https://img-blog.csdnimg.cn/20201216173128560.png'></p>
<p>片元程序在光栅器之后执行，它们处理的对象是每个片元而不是每个顶点。</p>
<h4 id="直通片元程序"><a href="#直通片元程序" class="headerlink" title="直通片元程序"></a>直通片元程序</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">gl_FragColor</span> = <span class="built_in">gl_Color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="着色器与OpenGL的连接"><a href="#着色器与OpenGL的连接" class="headerlink" title="着色器与OpenGL的连接"></a>着色器与OpenGL的连接</h3><h4 id="读取GLSL源文件"><a href="#读取GLSL源文件" class="headerlink" title="读取GLSL源文件"></a>读取GLSL源文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create a null-terminated string by reading the provided file */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">readShaderSource</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* shaderFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE* fp = fopen(shaderFile, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* buf;</span><br><span class="line">	<span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">	size = ftell(fp);</span><br><span class="line">	fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	fread(buf, <span class="number">1</span>, size, fp);</span><br><span class="line">	buf[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化GLSL"><a href="#初始化GLSL" class="headerlink" title="初始化GLSL"></a>初始化GLSL</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLuint program;</span><br><span class="line">GLuint vxParam, vyParam, timeParam;</span><br><span class="line"><span class="comment">/* GLSL initialization */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initShader</span><span class="params">(<span class="keyword">const</span> GLchar* vShaderFile, <span class="keyword">const</span> GLchar* fShaderFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GLint status;</span><br><span class="line">	GLchar* vSource, * fSource;</span><br><span class="line">	GLuint vShader, fShader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read shader files */</span></span><br><span class="line">	vSource = readShaderSource(vShaderFile);</span><br><span class="line">	<span class="keyword">if</span> (vSource == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to read vertex shaderi\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fSource = readShaderSource(fShaderFile);</span><br><span class="line">	<span class="keyword">if</span> (fSource == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to read fragment shader&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create program and shader objects */</span></span><br><span class="line">	glewInit();</span><br><span class="line">	vShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">	fShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">	program = glCreateProgram();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* attach shaders to the program object */</span></span><br><span class="line">	glAttachShader(program, vShader);</span><br><span class="line">	glAttachShader(program, fShader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read shaders */</span></span><br><span class="line">	glShaderSource(vShader, <span class="number">1</span>, (<span class="keyword">const</span> GLchar**)&amp;vSource, <span class="literal">NULL</span>);</span><br><span class="line">	glShaderSource(fShader, <span class="number">1</span>, (<span class="keyword">const</span> GLchar**)&amp;fSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* compile shaders */</span></span><br><span class="line">	glCompileShader(vShader);</span><br><span class="line">	glCompileShader(fShader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* error check */</span></span><br><span class="line">	glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;status);</span><br><span class="line">	checkError(status, <span class="string">&quot;Failed to compile the vertex shader.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;status);</span><br><span class="line">	checkError(status, <span class="string">&quot;Failed to compile the fragment shader.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* link */</span></span><br><span class="line">	glLinkProgram(program);</span><br><span class="line">	glGetProgramiv(program, GL_LINK_STATUS, &amp;status);</span><br><span class="line">	checkError(status, <span class="string">&quot;Failed to link the shader program object.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* use program object */</span></span><br><span class="line">	glUseProgram(program);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up uniform parameter */</span></span><br><span class="line">	timeParam = glGetUniformLocation(program, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">	vxParam = glGetAttribLocation(program, <span class="string">&quot;vx&quot;</span>);</span><br><span class="line">	vyParam = glGetAttribLocation(program, <span class="string">&quot;vy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印错误信息"><a href="#打印错误信息" class="headerlink" title="打印错误信息"></a>打印错误信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* error printing function */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkError</span><span class="params">(GLint status, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (status == GL_FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Interaction-交互"><a href="#Interaction-交互" class="headerlink" title="Interaction(交互)"></a>Interaction(交互)</h2><h3 id="鼠标交互"><a href="#鼠标交互" class="headerlink" title="鼠标交互"></a>鼠标交互</h3><h4 id="注册鼠标交互函数"><a href="#注册鼠标交互函数" class="headerlink" title="注册鼠标交互函数"></a>注册鼠标交互函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册鼠标点击事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutMouseFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">int</span> button,<span class="keyword">int</span> state,<span class="keyword">int</span> x,<span class="keyword">int</span> y))</span></span>;</span><br><span class="line"><span class="comment">// 注册鼠标移动事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutMotionFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">int</span> x,<span class="keyword">int</span> y))</span></span>; <span class="comment">// 鼠标移动并且点击</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutPassiveMotionFunc</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">int</span> x,<span class="keyword">int</span> y))</span></span>;<span class="comment">// 鼠标移动 </span></span><br><span class="line"><span class="comment">// 注册鼠标窗口事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutEntryFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">int</span> state))</span></span>;   </span><br></pre></td></tr></table></figure>
<h4 id="鼠标交互函数原型"><a href="#鼠标交互函数原型" class="headerlink" title="鼠标交互函数原型"></a>鼠标交互函数原型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- func   处理鼠标click事件的函数名</span></span><br><span class="line"><span class="comment">- button 表明哪个鼠标键被按下或松开</span></span><br><span class="line"><span class="comment">		 可选值: GLUT_LEFT_BUTTON</span></span><br><span class="line"><span class="comment">                GLUT_MIDDLE_BUTTON</span></span><br><span class="line"><span class="comment">                GLUT_RIGHT_BUTTON</span></span><br><span class="line"><span class="comment">- state  表明鼠标键是按下还是松开</span></span><br><span class="line"><span class="comment">		 可选值: GLUT_DOWN</span></span><br><span class="line"><span class="comment">				GLUT_UP</span></span><br><span class="line"><span class="comment">- x,y	 表明鼠标当前的窗口坐标（原点为左上角）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">int</span> button,<span class="keyword">int</span> state,<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- func 	 处理各自类型motion的函数名</span></span><br><span class="line"><span class="comment">- x,y	 表明鼠标当前的窗口坐标（原点为左上角）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- func   处理这些事件的函数名</span></span><br><span class="line"><span class="comment">- state  表明是离开还是进入窗口</span></span><br><span class="line"><span class="comment">		 可选值：GLUT_LEFT</span></span><br><span class="line"><span class="comment">                GLUT_ENTERED</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>(*func)(<span class="keyword">int</span> state);   </span><br></pre></td></tr></table></figure>
<h5 id="处理鼠标点击事件的函数模板"><a href="#处理鼠标点击事件的函数模板" class="headerlink" title="处理鼠标点击事件的函数模板"></a>处理鼠标点击事件的函数模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (button) &#123;</span><br><span class="line">    <span class="keyword">case</span> GLUT_LEFT_BUTTON:</span><br><span class="line">        <span class="keyword">if</span> (state == GLUT_DOWN)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">glutIdleFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GLUT_MIDDLE_BUTTON:</span><br><span class="line">    	<span class="keyword">if</span> (state == GLUT_DOWN)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">glutIdleFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line">    <span class="keyword">case</span> GLUT_RIGHT_BUTTON:</span><br><span class="line">        <span class="keyword">if</span> (state == GLUT_DOWN)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">glutIdleFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="菜单事件"><a href="#菜单事件" class="headerlink" title="菜单事件"></a>菜单事件</h4><h5 id="注册菜单事件"><a href="#注册菜单事件" class="headerlink" title="注册菜单事件"></a>注册菜单事件</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册菜单事件处理函数</span></span><br><span class="line">glutCreateMenu(<span class="keyword">void</span>(*func)(<span class="keyword">int</span> op));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加菜单项</span></span><br><span class="line">glutAddMenuEntry(<span class="string">&quot;Red&quot;</span>, RED);</span><br><span class="line">glutAddMenuEntry(<span class="string">&quot;Green&quot;</span>, GREEN);</span><br><span class="line">glutAddMenuEntry(<span class="string">&quot;Blue&quot;</span>, BLUE);</span><br><span class="line">glutAddMenuEntry(<span class="string">&quot;Black&quot;</span>, BLACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定菜单触发的按键</span></span><br><span class="line">glutAttachMenu(GLUT_RIGHT_BUTTON);</span><br></pre></td></tr></table></figure>
<h5 id="处理菜单事件的函数模板"><a href="#处理菜单事件的函数模板" class="headerlink" title="处理菜单事件的函数模板"></a>处理菜单事件的函数模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processMenuEvents</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> RED:</span><br><span class="line">		glColor3f(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GREEN:</span><br><span class="line">		glColor3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BLUE:</span><br><span class="line">		glColor3f(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BLACK:</span><br><span class="line">		glColor3f(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h3><h4 id="注册键盘交互函数"><a href="#注册键盘交互函数" class="headerlink" title="注册键盘交互函数"></a>注册键盘交互函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册键盘事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glutKeyboardFunc</span><span class="params">(<span class="keyword">void</span>(*func)(<span class="keyword">unsigned</span> <span class="keyword">char</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="键盘交互函数原型"><a href="#键盘交互函数原型" class="headerlink" title="键盘交互函数原型"></a>键盘交互函数原型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameters:</span></span><br><span class="line"><span class="comment">- func   处理键盘事件的函数名</span></span><br><span class="line"><span class="comment">- key    表明按下的键的ASCII码</span></span><br><span class="line"><span class="comment">		 可选值: </span></span><br><span class="line"><span class="comment">                GLUT_KEY_F1               F1 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F2               F2 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F3               F3 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F4               F4 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F5               F5 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F6               F6 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F7               F7 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F8               F8 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F9               F9 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F10              F10 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F11              F11 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_F12              F12 function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_LEFT             Left function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_RIGHT            Up function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_UP               Right function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_DOWN             Down function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_PAGE_UP          Page Up function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_PAGE_DOWN        Page Down function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_HOME             Home function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_END              End function key</span></span><br><span class="line"><span class="comment">                GLUT_KEY_INSERT           Insert function key</span></span><br><span class="line"><span class="comment">               	此外，也可直接输入数字或字符（如27、‘w’)</span></span><br><span class="line"><span class="comment">- x,y	 表明键盘按下时鼠标的窗口坐标（原点为左上角）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>(*func)(<span class="keyword">unsigned</span> <span class="keyword">char</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>
<h5 id="处理键盘事件的函数模板"><a href="#处理键盘事件的函数模板" class="headerlink" title="处理键盘事件的函数模板"></a>处理键盘事件的函数模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>(*func)(<span class="keyword">unsigned</span> <span class="keyword">char</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">       	<span class="keyword">case</span> <span class="number">97</span>:</span><br><span class="line"> 		<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> GLUT_KEY_LEFT:</span><br><span class="line">			<span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line"> 		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:    </span><br><span class="line">        <span class="keyword">case</span> GLUT_KEY_RIGHT:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">119</span>:</span><br><span class="line"> 		<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> GLUT_KEY_UP:</span><br><span class="line">			<span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> GLUT_KEY_DOWN:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>References</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
</search>
